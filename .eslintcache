[{"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/index.js":"1","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/App.js":"2","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/reportWebVitals.js":"3","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/utils/antdIcons.js":"4","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/FileList.js":"5","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/FileSearch.js":"6","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/todo/index.js":"7","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/note/index.js":"8","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/aim/index.js":"9","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/utils/helper.js":"10","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/hooks/useContextMenu.js":"11","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/hooks/useKeyPressed.js":"12","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/todo/TodoList.js":"13","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/todo/initial.js":"14","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/aim/EditAim.js":"15","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/aim/initial.js":"16","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/aim/AimList.js":"17","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/note/initial.js":"18","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Column.js":"19","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Task.js":"20","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/utils/treeHelper.js":"21","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/utils/fileHelper.js":"22","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/hooks/useIpcRenderer.js":"23","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/setting/index.js":"24","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/crash/index.js":"25","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/index.js":"26","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/utils/exportHtml.js":"27","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/utils/exportMarkdown.js":"28","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/eventHandler/clickEvent.js":"29","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/eventHandler/keyboard.js":"30","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/eventHandler/clipboard.js":"31","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/eventHandler/resize.js":"32","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/eventHandler/mouseEvent.js":"33","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/eventHandler/event.js":"34","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/eventHandler/dragDrop.js":"35","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/utils/index.js":"36","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/config/index.js":"37","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/ui/tooltip/index.js":"38","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/contentState/index.js":"39","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/utils/getLinkInfo.js":"40","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/selection/dom.js":"41","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/utils/getImageInfo.js":"42","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/utils/domManipulate.js":"43","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/utils/dompurify.js":"44","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/ui/emojis/index.js":"45","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/selection/index.js":"46","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/escapeCharacter.js":"47","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/selection/cursor.js":"48","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/contentState/footnoteCtrl.js":"49","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/utils/importMarkdown.js":"50","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/contentState/dragDropCtrl.js":"51","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/contentState/linkCtrl.js":"52","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/contentState/imageCtrl.js":"53","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/contentState/tocCtrl.js":"54","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/contentState/emojiCtrl.js":"55","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/contentState/inputCtrl.js":"56","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/contentState/clickCtrl.js":"57","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/contentState/htmlBlock.js":"58","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/renderers/index.js":"59","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/contentState/containerCtrl.js":"60","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/contentState/searchCtrl.js":"61","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/contentState/formatCtrl.js":"62","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/marked/index.js":"63","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/contentState/tabCtrl.js":"64","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/contentState/paragraphCtrl.js":"65","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/contentState/copyCutCtrl.js":"66","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/contentState/pasteCtrl.js":"67","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/contentState/arrowCtrl.js":"68","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/contentState/core.js":"69","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/contentState/history.js":"70","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/contentState/tableDragBarCtrl.js":"71","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/contentState/tableBlockCtrl.js":"72","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/contentState/tableSelectCellsCtrl.js":"73","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/contentState/codeBlockCtrl.js":"74","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/contentState/deleteCtrl.js":"75","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/contentState/updateCtrl.js":"76","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/contentState/backspaceCtrl.js":"77","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/contentState/enterCtrl.js":"78","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/index.js":"79","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/utils/turndownService.js":"80","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/prism/index.js":"81","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/utils/cumputeCheckBoxStatus.js":"82","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/utils/getParentCheckBox.js":"83","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/rules.js":"84","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/index.js":"85","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/marked/options.js":"86","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/marked/parser.js":"87","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/marked/lexer.js":"88","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/marked/renderer.js":"89","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/utils.js":"90","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/marked/utils.js":"91","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/prism/loadLanguage.js":"92","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/marked/textRenderer.js":"93","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/marked/blockRules.js":"94","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/marked/slugger.js":"95","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/marked/inlineLexer.js":"96","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/snabbdom.js":"97","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderBlock/index.js":"98","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderInlines/index.js":"99","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/marked/urlify.js":"100","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/marked/inlineRules.js":"101","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderInlines/footnoteIdentifier.js":"102","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderBlock/renderIcon.js":"103","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderInlines/superSubScript.js":"104","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderInlines/referenceImage.js":"105","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderInlines/referenceLink.js":"106","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderInlines/htmlRuby.js":"107","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderInlines/referenceDefinition.js":"108","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderInlines/multipleMath.js":"109","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderInlines/htmlEscape.js":"110","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderInlines/strong.js":"111","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderInlines/text.js":"112","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderInlines/del.js":"113","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderInlines/em.js":"114","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderInlines/inlineCode.js":"115","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderInlines/emoji.js":"116","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderInlines/delEmStringFactory.js":"117","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderInlines/image.js":"118","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderInlines/loadImageAsync.js":"119","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderInlines/autoLinkExtension.js":"120","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderInlines/autoLink.js":"121","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderInlines/inlineMath.js":"122","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderInlines/codeFense.js":"123","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderInlines/softLineBreak.js":"124","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderInlines/hardLineBreak.js":"125","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderInlines/tailHeader.js":"126","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderInlines/hr.js":"127","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderInlines/htmlTag.js":"128","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderInlines/link.js":"129","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderInlines/header.js":"130","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderInlines/highlight.js":"131","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderInlines/backlash.js":"132","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderInlines/backlashInToken.js":"133","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderBlock/renderContainerBlock.js":"134","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderBlock/renderLeafBlock.js":"135","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderBlock/renderBlock.js":"136","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderBlock/renderTableDargBar.js":"137","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderBlock/renderCopyButton.js":"138","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderBlock/renderContainerEditIcon.js":"139","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderBlock/renderFootnoteJump.js":"140","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderBlock/renderToolBar.js":"141","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/sequence.js":"142","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/index.js":"143","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/utils/exportHtml.js":"144","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/utils/exportMarkdown.js":"145","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/utils/index.js":"146","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/eventHandler/event.js":"147","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/eventHandler/mouseEvent.js":"148","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/eventHandler/clipboard.js":"149","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/eventHandler/keyboard.js":"150","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/eventHandler/dragDrop.js":"151","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/eventHandler/clickEvent.js":"152","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/eventHandler/resize.js":"153","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/contentState/index.js":"154","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/config/index.js":"155","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/ui/tooltip/index.js":"156","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/utils/dompurify.js":"157","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/utils/getLinkInfo.js":"158","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/contentState/backspaceCtrl.js":"159","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/contentState/updateCtrl.js":"160","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/contentState/enterCtrl.js":"161","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/utils/domManipulate.js":"162","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/utils/getImageInfo.js":"163","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/contentState/codeBlockCtrl.js":"164","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/contentState/tableDragBarCtrl.js":"165","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/contentState/deleteCtrl.js":"166","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/contentState/tableSelectCellsCtrl.js":"167","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/contentState/tableBlockCtrl.js":"168","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/contentState/arrowCtrl.js":"169","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/contentState/core.js":"170","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/contentState/history.js":"171","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/contentState/copyCutCtrl.js":"172","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/contentState/tabCtrl.js":"173","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/contentState/pasteCtrl.js":"174","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/contentState/containerCtrl.js":"175","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/contentState/emojiCtrl.js":"176","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/contentState/formatCtrl.js":"177","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/contentState/inputCtrl.js":"178","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/contentState/htmlBlock.js":"179","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/contentState/searchCtrl.js":"180","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/contentState/clickCtrl.js":"181","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/contentState/tocCtrl.js":"182","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/contentState/paragraphCtrl.js":"183","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/contentState/linkCtrl.js":"184","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/contentState/footnoteCtrl.js":"185","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/contentState/imageCtrl.js":"186","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/utils/importMarkdown.js":"187","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/contentState/dragDropCtrl.js":"188","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/selection/cursor.js":"189","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/selection/dom.js":"190","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/escapeCharacter.js":"191","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/selection/index.js":"192","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/renderers/index.js":"193","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/ui/emojis/index.js":"194","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/marked/index.js":"195","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/index.js":"196","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/utils/cumputeCheckBoxStatus.js":"197","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/utils/getParentCheckBox.js":"198","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/rules.js":"199","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/utils/turndownService.js":"200","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/index.js":"201","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/prism/index.js":"202","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/sequence.js":"203","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/marked/renderer.js":"204","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/marked/parser.js":"205","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/marked/lexer.js":"206","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/marked/options.js":"207","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/snabbdom.js":"208","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/marked/utils.js":"209","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/utils.js":"210","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/prism/loadLanguage.js":"211","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderBlock/index.js":"212","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderInlines/index.js":"213","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/marked/textRenderer.js":"214","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/marked/slugger.js":"215","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/marked/blockRules.js":"216","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/marked/inlineLexer.js":"217","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderBlock/renderIcon.js":"218","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderBlock/renderLeafBlock.js":"219","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderInlines/backlashInToken.js":"220","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderInlines/backlash.js":"221","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderBlock/renderContainerBlock.js":"222","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderInlines/header.js":"223","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderBlock/renderBlock.js":"224","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderInlines/highlight.js":"225","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderInlines/link.js":"226","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderInlines/hr.js":"227","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderInlines/htmlTag.js":"228","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderInlines/autoLink.js":"229","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderInlines/inlineMath.js":"230","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderInlines/hardLineBreak.js":"231","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderInlines/image.js":"232","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderInlines/autoLinkExtension.js":"233","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderInlines/loadImageAsync.js":"234","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderInlines/emoji.js":"235","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderInlines/delEmStringFactory.js":"236","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderInlines/del.js":"237","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderInlines/htmlEscape.js":"238","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderInlines/inlineCode.js":"239","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderInlines/referenceDefinition.js":"240","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderInlines/strong.js":"241","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderInlines/htmlRuby.js":"242","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderInlines/text.js":"243","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderInlines/em.js":"244","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderInlines/referenceLink.js":"245","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderInlines/multipleMath.js":"246","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderInlines/tailHeader.js":"247","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderInlines/codeFense.js":"248","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderInlines/softLineBreak.js":"249","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderInlines/footnoteIdentifier.js":"250","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderInlines/referenceImage.js":"251","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderInlines/superSubScript.js":"252","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/marked/urlify.js":"253","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/marked/inlineRules.js":"254","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderBlock/renderToolBar.js":"255","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderBlock/renderContainerEditIcon.js":"256","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderBlock/renderCopyButton.js":"257","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderBlock/renderFootnoteJump.js":"258","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderBlock/renderTableDargBar.js":"259"},{"size":916,"mtime":1610296200881,"results":"260","hashOfConfig":"261"},{"size":10955,"mtime":1618941743510,"results":"262","hashOfConfig":"261"},{"size":362,"mtime":1607156125945,"results":"263","hashOfConfig":"261"},{"size":861,"mtime":1610184870996,"results":"264","hashOfConfig":"261"},{"size":5500,"mtime":1618638838822,"results":"265","hashOfConfig":"261"},{"size":1978,"mtime":1618638838820,"results":"266","hashOfConfig":"261"},{"size":1061,"mtime":1610198892850,"results":"267","hashOfConfig":"261"},{"size":1837,"mtime":1620868015916,"results":"268","hashOfConfig":"261"},{"size":2729,"mtime":1610198915311,"results":"269","hashOfConfig":"261"},{"size":658,"mtime":1610271712589,"results":"270","hashOfConfig":"261"},{"size":1112,"mtime":1618856466874,"results":"271","hashOfConfig":"261"},{"size":746,"mtime":1618856410510,"results":"272","hashOfConfig":"261"},{"size":3838,"mtime":1610185059191,"results":"273","hashOfConfig":"261"},{"size":1006,"mtime":1618856425571,"results":"274","hashOfConfig":"261"},{"size":6685,"mtime":1610185605487,"results":"275","hashOfConfig":"261"},{"size":773,"mtime":1610185767507,"results":"276","hashOfConfig":"261"},{"size":2346,"mtime":1610250059618,"results":"277","hashOfConfig":"261"},{"size":688,"mtime":1610185412764,"results":"278","hashOfConfig":"261"},{"size":986,"mtime":1610184733421,"results":"279","hashOfConfig":"261"},{"size":958,"mtime":1610208057449,"results":"280","hashOfConfig":"261"},{"size":7008,"mtime":1610289048020,"results":"281","hashOfConfig":"261"},{"size":447,"mtime":1610257880565,"results":"282","hashOfConfig":"261"},{"size":453,"mtime":1618638838820,"results":"283","hashOfConfig":"261"},{"size":4752,"mtime":1610873685202,"results":"284","hashOfConfig":"261"},{"size":103,"mtime":1610287098559,"results":"285","hashOfConfig":"261"},{"size":13834,"mtime":1618746472385,"results":"286","hashOfConfig":"261"},{"size":11156,"mtime":1618679819977,"results":"287","hashOfConfig":"261"},{"size":13632,"mtime":1618679819978,"results":"288","hashOfConfig":"261"},{"size":8655,"mtime":1618679819953,"results":"289","hashOfConfig":"261"},{"size":9260,"mtime":1618679819954,"results":"290","hashOfConfig":"261"},{"size":2323,"mtime":1618679819953,"results":"291","hashOfConfig":"261"},{"size":694,"mtime":1618679819954,"results":"292","hashOfConfig":"261"},{"size":2919,"mtime":1618679819954,"results":"293","hashOfConfig":"261"},{"size":2821,"mtime":1618679819954,"results":"294","hashOfConfig":"261"},{"size":1207,"mtime":1618679819953,"results":"295","hashOfConfig":"261"},{"size":10480,"mtime":1618679819979,"results":"296","hashOfConfig":"261"},{"size":9641,"mtime":1618679819947,"results":"297","hashOfConfig":"261"},{"size":1650,"mtime":1618679819976,"results":"298","hashOfConfig":"261"},{"size":21825,"mtime":1618679819950,"results":"299","hashOfConfig":"261"},{"size":497,"mtime":1618679819978,"results":"300","hashOfConfig":"261"},{"size":4884,"mtime":1618679819966,"results":"301","hashOfConfig":"261"},{"size":1003,"mtime":1618679819978,"results":"302","hashOfConfig":"261"},{"size":578,"mtime":1618679819977,"results":"303","hashOfConfig":"261"},{"size":62,"mtime":1618679819977,"results":"304","hashOfConfig":"261"},{"size":1330,"mtime":1618679819969,"results":"305","hashOfConfig":"261"},{"size":22383,"mtime":1618679819967,"results":"306","hashOfConfig":"261"},{"size":5033,"mtime":1618679819955,"results":"307","hashOfConfig":"261"},{"size":1337,"mtime":1618679819966,"results":"308","hashOfConfig":"261"},{"size":1965,"mtime":1618679819949,"results":"309","hashOfConfig":"261"},{"size":22211,"mtime":1618732829970,"results":"310","hashOfConfig":"261"},{"size":5797,"mtime":1618679819948,"results":"311","hashOfConfig":"261"},{"size":1045,"mtime":1618679819951,"results":"312","hashOfConfig":"261"},{"size":6483,"mtime":1618679819950,"results":"313","hashOfConfig":"261"},{"size":606,"mtime":1618679819953,"results":"314","hashOfConfig":"261"},{"size":1218,"mtime":1618679819949,"results":"315","hashOfConfig":"261"},{"size":10725,"mtime":1618679819950,"results":"316","hashOfConfig":"261"},{"size":8579,"mtime":1618745317129,"results":"317","hashOfConfig":"261"},{"size":2025,"mtime":1618679819950,"results":"318","hashOfConfig":"261"},{"size":891,"mtime":1618679819966,"results":"319","hashOfConfig":"261"},{"size":3766,"mtime":1618679819948,"results":"320","hashOfConfig":"261"},{"size":3733,"mtime":1618679819952,"results":"321","hashOfConfig":"261"},{"size":10654,"mtime":1618679819949,"results":"322","hashOfConfig":"261"},{"size":937,"mtime":1618679819956,"results":"323","hashOfConfig":"261"},{"size":13725,"mtime":1618679819952,"results":"324","hashOfConfig":"261"},{"size":33258,"mtime":1618679819951,"results":"325","hashOfConfig":"261"},{"size":10682,"mtime":1618679819948,"results":"326","hashOfConfig":"261"},{"size":17841,"mtime":1618679819951,"results":"327","hashOfConfig":"261"},{"size":6880,"mtime":1618679819947,"results":"328","hashOfConfig":"261"},{"size":2241,"mtime":1618679819948,"results":"329","hashOfConfig":"261"},{"size":1641,"mtime":1618679819949,"results":"330","hashOfConfig":"261"},{"size":10906,"mtime":1618679819952,"results":"331","hashOfConfig":"261"},{"size":13943,"mtime":1618679819952,"results":"332","hashOfConfig":"261"},{"size":8733,"mtime":1618679819952,"results":"333","hashOfConfig":"261"},{"size":4908,"mtime":1618679819948,"results":"334","hashOfConfig":"261"},{"size":2301,"mtime":1618679819948,"results":"335","hashOfConfig":"261"},{"size":20632,"mtime":1618740970423,"results":"336","hashOfConfig":"261"},{"size":17779,"mtime":1618742210188,"results":"337","hashOfConfig":"261"},{"size":18568,"mtime":1618744003871,"results":"338","hashOfConfig":"261"},{"size":16058,"mtime":1618679819955,"results":"339","hashOfConfig":"261"},{"size":2092,"mtime":1618732808632,"results":"340","hashOfConfig":"261"},{"size":1101,"mtime":1618679819965,"results":"341","hashOfConfig":"261"},{"size":337,"mtime":1618679819977,"results":"342","hashOfConfig":"261"},{"size":281,"mtime":1618679819978,"results":"343","hashOfConfig":"261"},{"size":2550,"mtime":1618679819965,"results":"344","hashOfConfig":"261"},{"size":8146,"mtime":1618679819958,"results":"345","hashOfConfig":"261"},{"size":968,"mtime":1618679819956,"results":"346","hashOfConfig":"261"},{"size":5688,"mtime":1618679819957,"results":"347","hashOfConfig":"261"},{"size":18789,"mtime":1618745670727,"results":"348","hashOfConfig":"261"},{"size":6220,"mtime":1618679819957,"results":"349","hashOfConfig":"261"},{"size":7954,"mtime":1618679819965,"results":"350","hashOfConfig":"261"},{"size":5156,"mtime":1618679819958,"results":"351","hashOfConfig":"261"},{"size":3936,"mtime":1618679819966,"results":"352","hashOfConfig":"261"},{"size":1197,"mtime":1618679819957,"results":"353","hashOfConfig":"261"},{"size":6848,"mtime":1618679819956,"results":"354","hashOfConfig":"261"},{"size":857,"mtime":1618679819957,"results":"355","hashOfConfig":"261"},{"size":11629,"mtime":1618679819956,"results":"356","hashOfConfig":"261"},{"size":1111,"mtime":1618679819965,"results":"357","hashOfConfig":"261"},{"size":275,"mtime":1618679819958,"results":"358","hashOfConfig":"261"},{"size":1611,"mtime":1618679819963,"results":"359","hashOfConfig":"261"},{"size":8398,"mtime":1618679819958,"results":"360","hashOfConfig":"261"},{"size":5272,"mtime":1618679819956,"results":"361","hashOfConfig":"261"},{"size":863,"mtime":1618679819962,"results":"362","hashOfConfig":"261"},{"size":3394,"mtime":1618679819959,"results":"363","hashOfConfig":"261"},{"size":835,"mtime":1618679819964,"results":"364","hashOfConfig":"261"},{"size":1264,"mtime":1618679819964,"results":"365","hashOfConfig":"261"},{"size":2712,"mtime":1618679819964,"results":"366","hashOfConfig":"261"},{"size":994,"mtime":1618679819963,"results":"367","hashOfConfig":"261"},{"size":1780,"mtime":1618679819964,"results":"368","hashOfConfig":"261"},{"size":311,"mtime":1618679819964,"results":"369","hashOfConfig":"261"},{"size":560,"mtime":1618679819962,"results":"370","hashOfConfig":"261"},{"size":149,"mtime":1618679819964,"results":"371","hashOfConfig":"261"},{"size":222,"mtime":1618679819965,"results":"372","hashOfConfig":"261"},{"size":143,"mtime":1618679819961,"results":"373","hashOfConfig":"261"},{"size":141,"mtime":1618679819961,"results":"374","hashOfConfig":"261"},{"size":776,"mtime":1618679819963,"results":"375","hashOfConfig":"261"},{"size":1978,"mtime":1618679819962,"results":"376","hashOfConfig":"261"},{"size":1110,"mtime":1618679819961,"results":"377","hashOfConfig":"261"},{"size":4285,"mtime":1618679819963,"results":"378","hashOfConfig":"261"},{"size":2690,"mtime":1618679819963,"results":"379","hashOfConfig":"261"},{"size":641,"mtime":1618679819960,"results":"380","hashOfConfig":"261"},{"size":907,"mtime":1618679819960,"results":"381","hashOfConfig":"261"},{"size":1771,"mtime":1618679819963,"results":"382","hashOfConfig":"261"},{"size":531,"mtime":1618679819961,"results":"383","hashOfConfig":"261"},{"size":334,"mtime":1618679819964,"results":"384","hashOfConfig":"261"},{"size":545,"mtime":1618679819962,"results":"385","hashOfConfig":"261"},{"size":373,"mtime":1618679819964,"results":"386","hashOfConfig":"261"},{"size":301,"mtime":1618679819962,"results":"387","hashOfConfig":"261"},{"size":3218,"mtime":1618679819963,"results":"388","hashOfConfig":"261"},{"size":3932,"mtime":1618679819963,"results":"389","hashOfConfig":"261"},{"size":797,"mtime":1618679819962,"results":"390","hashOfConfig":"261"},{"size":897,"mtime":1618679819962,"results":"391","hashOfConfig":"261"},{"size":370,"mtime":1618679819960,"results":"392","hashOfConfig":"261"},{"size":865,"mtime":1618679819961,"results":"393","hashOfConfig":"261"},{"size":5989,"mtime":1618679819959,"results":"394","hashOfConfig":"261"},{"size":8484,"mtime":1618679819959,"results":"395","hashOfConfig":"261"},{"size":388,"mtime":1618679819958,"results":"396","hashOfConfig":"261"},{"size":290,"mtime":1618679819960,"results":"397","hashOfConfig":"261"},{"size":475,"mtime":1618679819959,"results":"398","hashOfConfig":"261"},{"size":484,"mtime":1618679819959,"results":"399","hashOfConfig":"261"},{"size":122,"mtime":1618679819959,"results":"400","hashOfConfig":"261"},{"size":1736,"mtime":1618679819960,"results":"401","hashOfConfig":"261"},{"size":145,"mtime":1618727016398,"results":"402","hashOfConfig":"261"},{"size":13807,"mtime":1618856672011,"results":"403","hashOfConfig":"261"},{"size":11385,"mtime":1618856675886,"results":"404","hashOfConfig":"261"},{"size":13632,"mtime":1618679819978,"results":"405","hashOfConfig":"261"},{"size":10480,"mtime":1618679819979,"results":"406","hashOfConfig":"261"},{"size":2821,"mtime":1618679819954,"results":"407","hashOfConfig":"261"},{"size":2919,"mtime":1618679819954,"results":"408","hashOfConfig":"261"},{"size":2323,"mtime":1618679819953,"results":"409","hashOfConfig":"261"},{"size":9427,"mtime":1618856683569,"results":"410","hashOfConfig":"261"},{"size":1207,"mtime":1618679819953,"results":"411","hashOfConfig":"261"},{"size":8655,"mtime":1618679819953,"results":"412","hashOfConfig":"261"},{"size":694,"mtime":1618679819954,"results":"413","hashOfConfig":"261"},{"size":21825,"mtime":1618679819950,"results":"414","hashOfConfig":"261"},{"size":9641,"mtime":1618679819947,"results":"415","hashOfConfig":"261"},{"size":1650,"mtime":1618679819976,"results":"416","hashOfConfig":"261"},{"size":62,"mtime":1618679819977,"results":"417","hashOfConfig":"261"},{"size":497,"mtime":1618679819978,"results":"418","hashOfConfig":"261"},{"size":17851,"mtime":1618856581590,"results":"419","hashOfConfig":"261"},{"size":20638,"mtime":1618850990358,"results":"420","hashOfConfig":"261"},{"size":18533,"mtime":1618856661649,"results":"421","hashOfConfig":"261"},{"size":578,"mtime":1618679819977,"results":"422","hashOfConfig":"261"},{"size":1003,"mtime":1618679819978,"results":"423","hashOfConfig":"261"},{"size":5052,"mtime":1618856704809,"results":"424","hashOfConfig":"261"},{"size":10906,"mtime":1618679819952,"results":"425","hashOfConfig":"261"},{"size":2301,"mtime":1618679819948,"results":"426","hashOfConfig":"261"},{"size":8733,"mtime":1618679819952,"results":"427","hashOfConfig":"261"},{"size":13943,"mtime":1618679819952,"results":"428","hashOfConfig":"261"},{"size":6880,"mtime":1618679819947,"results":"429","hashOfConfig":"261"},{"size":2241,"mtime":1618679819948,"results":"430","hashOfConfig":"261"},{"size":1641,"mtime":1618679819949,"results":"431","hashOfConfig":"261"},{"size":10682,"mtime":1618679819948,"results":"432","hashOfConfig":"261"},{"size":13725,"mtime":1618679819952,"results":"433","hashOfConfig":"261"},{"size":17841,"mtime":1618679819951,"results":"434","hashOfConfig":"261"},{"size":3766,"mtime":1618679819948,"results":"435","hashOfConfig":"261"},{"size":1266,"mtime":1618856688793,"results":"436","hashOfConfig":"261"},{"size":11285,"mtime":1618851189997,"results":"437","hashOfConfig":"261"},{"size":11510,"mtime":1618856679957,"results":"438","hashOfConfig":"261"},{"size":2025,"mtime":1618679819950,"results":"439","hashOfConfig":"261"},{"size":3733,"mtime":1618679819952,"results":"440","hashOfConfig":"261"},{"size":8579,"mtime":1618745317129,"results":"441","hashOfConfig":"261"},{"size":606,"mtime":1618679819953,"results":"442","hashOfConfig":"261"},{"size":34594,"mtime":1618856646594,"results":"443","hashOfConfig":"261"},{"size":1045,"mtime":1618679819951,"results":"444","hashOfConfig":"261"},{"size":1965,"mtime":1618679819949,"results":"445","hashOfConfig":"261"},{"size":6483,"mtime":1618679819950,"results":"446","hashOfConfig":"261"},{"size":22223,"mtime":1618851319354,"results":"447","hashOfConfig":"261"},{"size":5797,"mtime":1618679819948,"results":"448","hashOfConfig":"261"},{"size":1337,"mtime":1618679819966,"results":"449","hashOfConfig":"261"},{"size":4884,"mtime":1618679819966,"results":"450","hashOfConfig":"261"},{"size":5033,"mtime":1618679819955,"results":"451","hashOfConfig":"261"},{"size":22383,"mtime":1618679819967,"results":"452","hashOfConfig":"261"},{"size":891,"mtime":1618679819966,"results":"453","hashOfConfig":"261"},{"size":1330,"mtime":1618679819969,"results":"454","hashOfConfig":"261"},{"size":937,"mtime":1618679819956,"results":"455","hashOfConfig":"261"},{"size":8146,"mtime":1618679819958,"results":"456","hashOfConfig":"261"},{"size":337,"mtime":1618679819977,"results":"457","hashOfConfig":"261"},{"size":281,"mtime":1618679819978,"results":"458","hashOfConfig":"261"},{"size":2550,"mtime":1618679819965,"results":"459","hashOfConfig":"261"},{"size":2092,"mtime":1618732808632,"results":"460","hashOfConfig":"261"},{"size":17143,"mtime":1618854512077,"results":"461","hashOfConfig":"261"},{"size":1101,"mtime":1618679819965,"results":"462","hashOfConfig":"261"},{"size":145,"mtime":1618727016398,"results":"463","hashOfConfig":"261"},{"size":6220,"mtime":1618679819957,"results":"464","hashOfConfig":"261"},{"size":5688,"mtime":1618679819957,"results":"465","hashOfConfig":"261"},{"size":18789,"mtime":1618745670727,"results":"466","hashOfConfig":"261"},{"size":968,"mtime":1618679819956,"results":"467","hashOfConfig":"261"},{"size":1111,"mtime":1618679819965,"results":"468","hashOfConfig":"261"},{"size":5156,"mtime":1618679819958,"results":"469","hashOfConfig":"261"},{"size":7954,"mtime":1618679819965,"results":"470","hashOfConfig":"261"},{"size":3936,"mtime":1618679819966,"results":"471","hashOfConfig":"261"},{"size":275,"mtime":1618679819958,"results":"472","hashOfConfig":"261"},{"size":1611,"mtime":1618679819963,"results":"473","hashOfConfig":"261"},{"size":1197,"mtime":1618679819957,"results":"474","hashOfConfig":"261"},{"size":857,"mtime":1618679819957,"results":"475","hashOfConfig":"261"},{"size":6848,"mtime":1618679819956,"results":"476","hashOfConfig":"261"},{"size":11629,"mtime":1618679819956,"results":"477","hashOfConfig":"261"},{"size":3394,"mtime":1618679819959,"results":"478","hashOfConfig":"261"},{"size":8869,"mtime":1618856538908,"results":"479","hashOfConfig":"261"},{"size":865,"mtime":1618679819961,"results":"480","hashOfConfig":"261"},{"size":370,"mtime":1618679819960,"results":"481","hashOfConfig":"261"},{"size":5989,"mtime":1618679819959,"results":"482","hashOfConfig":"261"},{"size":797,"mtime":1618679819962,"results":"483","hashOfConfig":"261"},{"size":388,"mtime":1618679819958,"results":"484","hashOfConfig":"261"},{"size":897,"mtime":1618679819962,"results":"485","hashOfConfig":"261"},{"size":3932,"mtime":1618679819963,"results":"486","hashOfConfig":"261"},{"size":301,"mtime":1618679819962,"results":"487","hashOfConfig":"261"},{"size":3218,"mtime":1618679819963,"results":"488","hashOfConfig":"261"},{"size":907,"mtime":1618679819960,"results":"489","hashOfConfig":"261"},{"size":1771,"mtime":1618679819963,"results":"490","hashOfConfig":"261"},{"size":545,"mtime":1618679819962,"results":"491","hashOfConfig":"261"},{"size":4285,"mtime":1618679819963,"results":"492","hashOfConfig":"261"},{"size":641,"mtime":1618679819960,"results":"493","hashOfConfig":"261"},{"size":2690,"mtime":1618679819963,"results":"494","hashOfConfig":"261"},{"size":1978,"mtime":1618679819962,"results":"495","hashOfConfig":"261"},{"size":1110,"mtime":1618679819961,"results":"496","hashOfConfig":"261"},{"size":143,"mtime":1618679819961,"results":"497","hashOfConfig":"261"},{"size":560,"mtime":1618679819962,"results":"498","hashOfConfig":"261"},{"size":776,"mtime":1618679819963,"results":"499","hashOfConfig":"261"},{"size":1780,"mtime":1618679819964,"results":"500","hashOfConfig":"261"},{"size":149,"mtime":1618679819964,"results":"501","hashOfConfig":"261"},{"size":994,"mtime":1618679819963,"results":"502","hashOfConfig":"261"},{"size":222,"mtime":1618679819965,"results":"503","hashOfConfig":"261"},{"size":141,"mtime":1618679819961,"results":"504","hashOfConfig":"261"},{"size":2712,"mtime":1618679819964,"results":"505","hashOfConfig":"261"},{"size":311,"mtime":1618679819964,"results":"506","hashOfConfig":"261"},{"size":373,"mtime":1618679819964,"results":"507","hashOfConfig":"261"},{"size":531,"mtime":1618679819961,"results":"508","hashOfConfig":"261"},{"size":334,"mtime":1618679819964,"results":"509","hashOfConfig":"261"},{"size":863,"mtime":1618679819962,"results":"510","hashOfConfig":"261"},{"size":1264,"mtime":1618679819964,"results":"511","hashOfConfig":"261"},{"size":835,"mtime":1618679819964,"results":"512","hashOfConfig":"261"},{"size":8398,"mtime":1618679819958,"results":"513","hashOfConfig":"261"},{"size":5272,"mtime":1618679819956,"results":"514","hashOfConfig":"261"},{"size":1736,"mtime":1618679819960,"results":"515","hashOfConfig":"261"},{"size":484,"mtime":1618679819959,"results":"516","hashOfConfig":"261"},{"size":475,"mtime":1618679819959,"results":"517","hashOfConfig":"261"},{"size":122,"mtime":1618679819959,"results":"518","hashOfConfig":"261"},{"size":290,"mtime":1618679819960,"results":"519","hashOfConfig":"261"},{"filePath":"520","messages":"521","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},"1teqt1h",{"filePath":"523","messages":"524","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"525","usedDeprecatedRules":"522"},{"filePath":"526","messages":"527","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"528","messages":"529","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"530","messages":"531","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"532","messages":"533","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"534","messages":"535","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"536","usedDeprecatedRules":"522"},{"filePath":"537","messages":"538","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"539","messages":"540","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"541","usedDeprecatedRules":"522"},{"filePath":"542","messages":"543","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"544","messages":"545","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"546","usedDeprecatedRules":"522"},{"filePath":"547","messages":"548","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"549","usedDeprecatedRules":"522"},{"filePath":"550","messages":"551","errorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"552","usedDeprecatedRules":"522"},{"filePath":"553","messages":"554","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"555","usedDeprecatedRules":"522"},{"filePath":"556","messages":"557","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"558","usedDeprecatedRules":"522"},{"filePath":"559","messages":"560","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"561","messages":"562","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"563","messages":"564","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"565"},{"filePath":"566","messages":"567","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"568","messages":"569","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"570","messages":"571","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"572","messages":"573","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"574","messages":"575","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"576","messages":"577","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"578","messages":"579","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"580","messages":"581","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"583","messages":"584","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"585","messages":"586","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"587","usedDeprecatedRules":"582"},{"filePath":"588","messages":"589","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"590","messages":"591","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"592","usedDeprecatedRules":"582"},{"filePath":"593","messages":"594","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"595","messages":"596","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"597","messages":"598","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"599","messages":"600","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"601","messages":"602","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"603","messages":"604","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"605","messages":"606","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"607","messages":"608","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"609","messages":"610","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"611","messages":"612","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"613","messages":"614","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"615","messages":"616","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"617","messages":"618","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"619","messages":"620","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"621","messages":"622","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"623","messages":"624","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"625","usedDeprecatedRules":"582"},{"filePath":"626","messages":"627","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"628","messages":"629","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"630","messages":"631","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"632","messages":"633","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"634","messages":"635","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"636","messages":"637","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"638","usedDeprecatedRules":"582"},{"filePath":"639","messages":"640","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"641","messages":"642","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"643","messages":"644","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"645","messages":"646","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"647","usedDeprecatedRules":"582"},{"filePath":"648","messages":"649","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"650","usedDeprecatedRules":"582"},{"filePath":"651","messages":"652","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"653","messages":"654","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"655","messages":"656","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"657","messages":"658","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"659","messages":"660","errorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"661","usedDeprecatedRules":"582"},{"filePath":"662","messages":"663","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"664","messages":"665","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"666","usedDeprecatedRules":"582"},{"filePath":"667","messages":"668","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"669","usedDeprecatedRules":"582"},{"filePath":"670","messages":"671","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"672","usedDeprecatedRules":"582"},{"filePath":"673","messages":"674","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"675","usedDeprecatedRules":"582"},{"filePath":"676","messages":"677","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"678","usedDeprecatedRules":"582"},{"filePath":"679","messages":"680","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"681","messages":"682","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"683","messages":"684","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"685","usedDeprecatedRules":"582"},{"filePath":"686","messages":"687","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"688","usedDeprecatedRules":"582"},{"filePath":"689","messages":"690","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"691","messages":"692","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"693","messages":"694","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"695","messages":"696","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"697","messages":"698","errorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"699","usedDeprecatedRules":"582"},{"filePath":"700","messages":"701","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"702","messages":"703","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"704","messages":"705","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"706","messages":"707","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"708","messages":"709","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"710","messages":"711","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"712","messages":"713","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"714","messages":"715","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"716","messages":"717","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"718","usedDeprecatedRules":"582"},{"filePath":"719","messages":"720","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"721","messages":"722","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"723","usedDeprecatedRules":"582"},{"filePath":"724","messages":"725","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"726","messages":"727","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"728","messages":"729","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"730","usedDeprecatedRules":"582"},{"filePath":"731","messages":"732","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"733","usedDeprecatedRules":"582"},{"filePath":"734","messages":"735","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"736","messages":"737","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"738","messages":"739","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"740","messages":"741","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"742","messages":"743","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"744","messages":"745","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"746","usedDeprecatedRules":"582"},{"filePath":"747","messages":"748","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"749","usedDeprecatedRules":"582"},{"filePath":"750","messages":"751","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"752","messages":"753","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"754","messages":"755","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"756","messages":"757","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"758","messages":"759","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"760","messages":"761","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"762","messages":"763","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"764","messages":"765","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"766","messages":"767","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"768","messages":"769","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"770","messages":"771","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"772","messages":"773","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"774","messages":"775","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"776","messages":"777","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"778","messages":"779","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"780","messages":"781","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"782","messages":"783","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"784","messages":"785","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"786","messages":"787","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"788","messages":"789","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"790","messages":"791","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"792","messages":"793","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"794","messages":"795","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"796","messages":"797","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"798","messages":"799","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"800","messages":"801","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"802","messages":"803","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"804","messages":"805","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"806","messages":"807","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"808","messages":"809","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"810","messages":"811","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"812","messages":"813","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"814","messages":"815","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"816","messages":"817","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"818","usedDeprecatedRules":"582"},{"filePath":"819","messages":"820","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"821","messages":"822","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"823","usedDeprecatedRules":"582"},{"filePath":"824","messages":"825","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"826","messages":"827","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"828","messages":"829","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"830","messages":"831","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"832","messages":"833","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"834","messages":"835","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"836","messages":"837","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"582"},{"filePath":"838","messages":"839","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"840","messages":"841","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"842","messages":"843","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"587","usedDeprecatedRules":"522"},{"filePath":"844","messages":"845","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"846","messages":"847","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"848","messages":"849","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"850","messages":"851","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"852","messages":"853","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"854","messages":"855","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"856","messages":"857","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"858","messages":"859","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"860","messages":"861","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"862","messages":"863","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"864","messages":"865","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"866","messages":"867","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"868","messages":"869","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"870","messages":"871","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"872","messages":"873","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"874","messages":"875","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"876","messages":"877","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"878","messages":"879","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"880","messages":"881","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"882","messages":"883","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"685","usedDeprecatedRules":"522"},{"filePath":"884","messages":"885","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"886","messages":"887","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"888","messages":"889","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"688","usedDeprecatedRules":"522"},{"filePath":"890","messages":"891","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"678","usedDeprecatedRules":"522"},{"filePath":"892","messages":"893","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"894","messages":"895","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"896","messages":"897","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"672","usedDeprecatedRules":"522"},{"filePath":"898","messages":"899","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"666","usedDeprecatedRules":"522"},{"filePath":"900","messages":"901","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"675","usedDeprecatedRules":"522"},{"filePath":"902","messages":"903","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"904","messages":"905","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"906","messages":"907","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"908","messages":"909","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"910","messages":"911","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"912","messages":"913","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"914","messages":"915","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"916","usedDeprecatedRules":"522"},{"filePath":"917","messages":"918","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"919","messages":"920","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"921","messages":"922","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"638","usedDeprecatedRules":"522"},{"filePath":"923","messages":"924","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"925","messages":"926","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"927","messages":"928","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"929","messages":"930","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"931","messages":"932","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"933","messages":"934","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"935","messages":"936","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"937","messages":"938","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"625","usedDeprecatedRules":"522"},{"filePath":"939","messages":"940","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"941","messages":"942","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"943","messages":"944","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"945","messages":"946","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"947","messages":"948","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"949","messages":"950","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"951","messages":"952","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"953","messages":"954","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"955","messages":"956","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"957","messages":"958","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"959","messages":"960","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"961","messages":"962","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"963","messages":"964","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"965","messages":"966","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"967","usedDeprecatedRules":"522"},{"filePath":"968","messages":"969","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"718","usedDeprecatedRules":"522"},{"filePath":"970","messages":"971","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"972","messages":"973","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"730","usedDeprecatedRules":"522"},{"filePath":"974","messages":"975","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"976","messages":"977","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"733","usedDeprecatedRules":"522"},{"filePath":"978","messages":"979","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"746","usedDeprecatedRules":"522"},{"filePath":"980","messages":"981","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"749","usedDeprecatedRules":"522"},{"filePath":"982","messages":"983","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"984","messages":"985","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"986","messages":"987","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"988","messages":"989","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"990","messages":"991","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"992","messages":"993","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"994","messages":"995","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"818","usedDeprecatedRules":"522"},{"filePath":"996","messages":"997","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"998","messages":"999","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"1000","messages":"1001","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"1002","messages":"1003","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"1004","messages":"1005","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"1006","messages":"1007","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"1008","messages":"1009","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"1010","messages":"1011","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"1012","messages":"1013","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"1014","messages":"1015","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"1016","messages":"1017","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"1018","messages":"1019","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"1020","messages":"1021","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"1022","messages":"1023","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"1024","messages":"1025","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"1026","messages":"1027","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"1028","messages":"1029","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"1030","messages":"1031","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"1032","messages":"1033","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"1034","messages":"1035","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"1036","messages":"1037","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"1038","messages":"1039","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"1040","messages":"1041","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"1042","messages":"1043","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"1044","messages":"1045","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"1046","messages":"1047","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"1048","messages":"1049","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"1050","messages":"1051","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"1052","messages":"1053","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"1054","messages":"1055","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"1056","messages":"1057","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"1058","messages":"1059","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"1060","messages":"1061","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"1062","messages":"1063","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"1064","messages":"1065","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"1066","messages":"1067","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"1068","messages":"1069","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"1070","messages":"1071","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},{"filePath":"1072","messages":"1073","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"522"},"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/index.js",[],["1074","1075"],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/App.js",["1076","1077","1078"],"import { useState } from 'react';\nimport styles from './App.less';\nimport { Row, Col } from 'antd';\nimport moment from 'moment';\nimport FileSearch from './components/FileSearch';\nimport FileList from './components/FileList';\nimport Note from './note';\nimport Todo from './todo';\nimport Aim from './aim';\nimport {\n  defaultFiles,\n  importChildren,\n  findItemById,\n  editItemById,\n  createItemByFatherId,\n  deleteItemById,\n  findItemsByIds,\n  getIconByFileType,\n  deleteExtraAttr,\n  deepClone,\n} from './utils/treeHelper';\nimport emptyImg from '../public/empty.png';\nimport shortid from 'shortid';\nimport fileHelper from './utils/fileHelper';\nimport useIpcRenderer from './hooks/useIpcRenderer';\n// Node API\nconst { remote, ipcRenderer } = window.require('electron');\nconst { join, basename, extname, dirname } = window.require('path');\nconst Store = window.require('electron-store');\n\nconst fileStore = new Store({ name: 'Files Data' });\nconst settingStore = new Store({ name: 'settings' });\n// fileStore.delete('files');\n\nconst getAutoSync = () =>\n  ['accessKey', 'secretKey', 'bucket', 'enableAutoSync'].every(\n    (key) => !!settingStore.get(key)\n  );\n\n/**\n * state分析\n * - 文件列表 【】\n * - 搜索后的文件列表 key\n * - 未保存的文件列表 [id]\n * - 已经打开的文件列表 [id]\n * - 当前选中的文件\n */\nfunction App() {\n  const [files, setFiles] = useState(fileStore.get('files') || defaultFiles);\n  const [activeFileId, setActiveFileId] = useState('');\n  const [openedFileIds, setOpenedFileIds] = useState([]);\n  const [unsavedFileIds, setUnsavedFileIds] = useState([]);\n  const [newFile, setNewFile] = useState(null);\n\n  const activeFile = findItemById(files, activeFileId);\n  const openedFiles = findItemsByIds(files, openedFileIds);\n  const unsavedFiles = findItemsByIds(files, unsavedFileIds);\n  const savedLocation =\n    settingStore.get('savedFileLocatiion') ||\n    `${remote.app.getPath('documents')}/cloud-note/`;\n\n  const saveFile2Store = (data) => {\n    const newData = deleteExtraAttr(deepClone(data));\n    fileStore.set('files', newData);\n  };\n\n  const clearUnsavedFile = (id) => {\n    const newUnsavedFileIds = unsavedFileIds.filter((fileId) => fileId !== id);\n    setUnsavedFileIds(newUnsavedFileIds);\n  };\n\n  const closeOpenedFile = (id) => {\n    const newOpenedFileIds = openedFileIds.filter((openId) => openId !== id);\n    setOpenedFileIds(newOpenedFileIds);\n    if (newOpenedFileIds.length > 0) {\n      setActiveFileId(newOpenedFileIds[newOpenedFileIds.length - 1]);\n    } else {\n      setActiveFileId('');\n    }\n  };\n\n  const openClickedFile = (id, isLoaded, path) => {\n    const curFile = findItemById(files, id);\n    console.log('++++', path, id, curFile, isLoaded, getAutoSync());\n    if (!isLoaded && path) {\n      // TODO\n      if (getAutoSync()) {\n        ipcRenderer.send('download-file', {\n          key: `${curFile.title}.md`,\n          path: curFile.path,\n          id: curFile.id,\n          updatedAt: curFile.updatedAt,\n        });\n      } else {\n        fileHelper.readFile(path).then((val) => {\n          console.log('readFile-222', path, val);\n          const newFiles = editItemById(files, id, {\n            body: val,\n            isLoaded: true,\n          });\n          setFiles(newFiles);\n          if (!openedFileIds.includes(id)) {\n            setOpenedFileIds([...openedFileIds, id]);\n          }\n        });\n      }\n      setActiveFileId(id);\n    } else {\n      setActiveFileId(id);\n      if (!openedFileIds.includes(id)) {\n        setOpenedFileIds([...openedFileIds, id]);\n      }\n    }\n  };\n  const deleteFile = (id, path) => {\n    fileHelper.deleteFile(path).then(() => {\n      const newFiles = deleteItemById(files, id);\n      saveFile2Store(newFiles);\n      setFiles(newFiles);\n      closeOpenedFile(id);\n      clearUnsavedFile(id);\n    });\n  };\n  const createNewFile = (fatherId, type, isLeaf) => {\n    const folder = isLeaf ? {} : { children: [] };\n    const newId = shortid.generate();\n    const newPath = join(\n      savedLocation,\n      `${newId}${type === 'note' ? '.md' : '.json'}`\n    );\n    const newFile = {\n      id: newId,\n      title: '',\n      path: newPath,\n      key: newId,\n      type,\n      icon: getIconByFileType(type, isLeaf),\n      createAt: moment().valueOf(),\n      isLeaf,\n      isSync: false,\n      updatedAt: 0,\n      ...folder,\n    };\n    const newFiles = createItemByFatherId(files, fatherId, newFile);\n    fileHelper\n      .writeFile(newPath, type === 'note' ? '## 请输入markdown' : '{}')\n      .then((res) => {\n        console.log('新建', newFiles, res);\n        setNewFile(newFile);\n        setFiles(newFiles);\n      });\n  };\n  const renameFile = (id, path, title, type) => {\n    const newPath = `${dirname(path)}/${title}${\n      type === 'note' ? '.md' : '.json'\n    }`;\n    fileHelper.renameFile(path, newPath).then(() => {\n      const newFiles = editItemById(files, id, { title, path: newPath });\n      saveFile2Store(newFiles);\n      setFiles(newFiles);\n      setNewFile(null);\n    });\n  };\n\n  const fileChange = (id, value) => {\n    console.log('fileChange', id, value);\n    if (value !== activeFile.body) {\n      const newFiles = editItemById(files, id, { body: value });\n      setFiles(newFiles);\n      if (!unsavedFileIds.includes(id)) {\n        setUnsavedFileIds([...unsavedFileIds, id]);\n      }\n    }\n  };\n\n  const saveEditFile = () => {\n    const { path, body, title } = activeFile;\n    if (activeFile.type === 'note') {\n      fileHelper.writeFile(path, body).then(() => {\n        setUnsavedFileIds(unsavedFileIds.filter((id) => id !== activeFileId));\n        if (getAutoSync()) {\n          ipcRenderer.send('upload-file', {\n            key: `${title}.md`,\n            path: path,\n          });\n        }\n      });\n    }\n  };\n\n  const onImportFiles = (id, type) => {\n    remote.dialog\n      .showOpenDialog({\n        title: '选择导入MD文档',\n        filters: [{ name: 'Markdown Files', extension: ['md'] }],\n        properties: ['openFile', 'multiSelections'],\n      })\n      .then(({ filePaths }) => {\n        if (Array.isArray(filePaths)) {\n          // TODO 过滤已经添加过的文件\n          const children = filePaths.map((path) => {\n            const newId = shortid.generate();\n            return {\n              id: newId,\n              title: basename(path, extname(path)),\n              path,\n              key: newId,\n              type,\n              icon: getIconByFileType(type, true),\n              createAt: moment().valueOf(),\n              isLeaf: true,\n              isSync: false,\n              updatedAt: 0,\n            };\n          });\n          const newFiles = importChildren(files, id, children);\n          saveFile2Store(newFiles);\n          setFiles(newFiles);\n          if (children.length > 0) {\n            remote.dialog.showMessageBox({\n              type: 'info',\n              title: `导入成功`,\n              message: `成功导入了${children.length}个文件`,\n            });\n          }\n        }\n      });\n  };\n\n  const activeFileUploaded = () => {\n    const newFiles = editItemById(files, activeFileId, {\n      isSynced: true,\n      uploadedAt: moment().valueOf(),\n    });\n    setFiles(newFiles);\n    saveFile2Store(newFiles);\n  };\n\n  const activeFileDownloaded = (_, data) => {\n    console.log('activeFileDownloaded++++', data);\n    const curFile = findItemById(files, data.id);\n    console.log('activeFileDownloaded++++', curFile.path);\n    fileHelper.readFile(curFile.path).then((value) => {\n      console.log('readFile++++++', value);\n      let newData;\n      if (data.status === 'downloaded-success') {\n        newData = {\n          body: value,\n          isLoaded: true,\n          isSynced: true,\n          updatedAt: moment().valueOf(),\n        };\n      } else {\n        newData = {\n          body: value,\n          isLoaded: true,\n        };\n      }\n      console.log('activeFileDownloaded', newData);\n      const newFiles = editItemById(files, data.id, newData);\n      setFiles(newFiles);\n      saveFile2Store(newFiles);\n    });\n  };\n  useIpcRenderer({\n    'active-file-uploaded': activeFileUploaded,\n    'file-downloaded': activeFileDownloaded,\n    'save-edit-file': saveEditFile,\n  });\n  console.log('activeFileId', activeFile);\n  return (\n    <div className={styles.App}>\n      <div style={{ height: '100%', display: 'flex' }}>\n        <div\n          style={{\n            width: '28%',\n            background: '#6E6E6E',\n            color: 'white',\n            minWidth: 260,\n          }}\n        >\n          <div className={styles.dragArea} />\n          <FileSearch\n            title=\"\"\n            onFileSearch={(val) => {\n              console.log(val);\n            }}\n          />\n          <FileList\n            activeId={activeFileId}\n            files={deepClone(files)}\n            newFile={newFile}\n            openedFiles={openedFiles}\n            onImportFiles={onImportFiles}\n            closeOpenedFile={closeOpenedFile}\n            unsavedFileIds={unsavedFileIds}\n            onFileClick={openClickedFile}\n            createNewFile={createNewFile}\n            onFileDelete={deleteFile}\n            onFileRename={renameFile}\n          />\n        </div>\n        <div style={{ flex: 1, backgroundColor: '#fafbfc' }}>\n          {!activeFile ? (\n            <div className={styles.empty}>\n              <div\n                style={{ width: '100%', position: 'absolute', top: 0 }}\n                className={styles.dragArea}\n              />\n              <img src={emptyImg} alt=\"没有数据\" />\n              <span className={styles.emptyWord}>空空如也</span>\n            </div>\n          ) : (\n            <>\n              <h1\n                className={styles.dragArea}\n                style={{\n                  display: 'flex',\n                  alignItems: 'center',\n                  justifyContent: 'center',\n                  height: 58,\n                  padding: '0 58px',\n                  fontSize: 26,\n                  fontWeight: 600,\n                  margin: 0,\n                  backgroundColor: '#fafbfc',\n                }}\n              >\n                {unsavedFileIds.includes(activeFileId) && (\n                  <span className={styles.unsaveIcon} />\n                )}\n                {activeFile.title}\n              </h1>\n              {activeFile.type === 'todo' ? (\n                <Todo activeFile={activeFile} onChange={fileChange} />\n              ) : activeFile.type === 'note' ? (\n                <Note activeFile={activeFile} onChange={fileChange} />\n              ) : activeFile.type === 'aim' ? (\n                <Aim activeFile={activeFile} onChange={fileChange} />\n              ) : (\n                <div className={styles.empty}>\n                  <h3 style={{ color: 'red' }}>\n                    {activeFile.title}, 正在开发中...\n                  </h3>\n                </div>\n              )}\n            </>\n          )}\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/reportWebVitals.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/utils/antdIcons.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/FileList.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/FileSearch.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/todo/index.js",["1079","1080","1081","1082"],"import React, { useState } from 'react';\n// import { useIdb } from 'react-use-idb';\nimport moment from 'moment';\nimport styles from './index.less';\nimport shortid from 'shortid';\nimport { ITodo, newTodo, ESort, initTodo } from './initial';\nimport { message } from 'antd';\nimport TodoList from './TodoList';\n\nconst Todo = (props) => {\n  const newId = shortid.generate();\n  const initTodos = initTodo(newTodo(moment(), newId), newId);\n  const [allTodos, setAllTodos] = useState(initTodos);\n  const { currentId = '', editId, data = [] } = allTodos || {};\n  const [currentTodo] = data.filter((item) => item.id === currentId);\n\n  const changeCurrentTodo = (todo) => {\n    const newDatas = data.filter((item) => item.id !== currentId);\n    newDatas.push({ ...todo, modifyTime: moment().valueOf() });\n    setAllTodos({ ...allTodos, data: newDatas });\n  };\n\n  return (\n    <div className={styles.Todo}>\n      <div className={styles.content}>\n        <TodoList todoData={currentTodo} onChange={changeCurrentTodo} />\n      </div>\n    </div>\n  );\n};\n\nexport default Todo;\n","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/note/index.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/aim/index.js",["1083"],"import React, { useState } from 'react';\n// import { useIdb } from 'react-use-idb';\nimport moment from 'moment';\nimport styles from './index.less';\nimport AimList from './AimList';\nimport { EAimType, EAimSort, initAim } from './initial';\nimport { message } from 'antd';\nimport EditAim from './EditAim';\nimport EmptyStatus from '../../public/empty.png';\n\nconst Aim = (props) => {\n  const initAims = initAim(moment());\n  const [allAims, setAllAims] = useState(initAims);\n  const { currentId = allAims.data[0].id, editId, data = [] } = allAims;\n  const [currentAim] = data.filter((item) => item.id === currentId);\n  console.log('currentAim', initAims, currentAim);\n  const changeCurrentAim = (aim) => {\n    const newDatas = data.filter((item) => item.id !== currentId);\n    newDatas.push({ ...aim, modifyTime: moment().valueOf() });\n    setAllAims({ ...allAims, editId: '', data: newDatas });\n  };\n\n  const addBranchTimes = (index) => {\n    const { data } = allAims;\n    const newData = data.map((item) => {\n      if (item.id === currentId) {\n        item.currentTimes += 1;\n        if (index >= 0) {\n          item.branchs[index].currentTimes += 1;\n        }\n      }\n      return item;\n    });\n\n    setAllAims({\n      ...allAims,\n      data: newData,\n    });\n  };\n  const onEditChange = (type, id, title) => {\n    if (type === EAimType.start) {\n      setAllAims({ ...allAims, editId: id });\n      return;\n    }\n    const { data } = allAims;\n    if (type === EAimType.delete) {\n      const newData = data.filter((item) => item.id !== id);\n      setAllAims({ ...allAims, data: newData });\n      return;\n    }\n    if (type === EAimType.top) {\n      const newData = data.map((item) => {\n        if (item.id === id) {\n          item.sort =\n            item.sort === EAimSort.top ? EAimSort.normal : EAimSort.top;\n          item.modifyTime = moment().valueOf();\n        }\n        return item;\n      });\n      setAllAims({ ...allAims, editId: '', data: newData });\n      return;\n    }\n    if (type === EAimType.rename) {\n      if (!title) {\n        message.error('标题不能为空');\n        return;\n      }\n      const newData = data.map((item) => {\n        if (item.id === id) {\n          item.title = title;\n          item.modifyTime = moment().valueOf();\n        }\n        return item;\n      });\n      setAllAims({ ...allAims, editId: '', data: newData });\n    }\n  };\n\n  return (\n    <div className={styles.Aim}>\n      <div className={styles.content}>\n        <EditAim\n          editId={editId}\n          data={currentAim}\n          onEditChange={onEditChange}\n          onSubmit={changeCurrentAim}\n        />\n        <AimList data={currentAim} addBranchTimes={addBranchTimes} />\n      </div>\n    </div>\n  );\n};\nexport default Aim;\n","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/utils/helper.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/hooks/useContextMenu.js",["1084"],"import { useEffect, useRef } from 'react';\nimport { getParentNode } from '../utils/helper';\n// import nodejs modules\nconst { remote } = window.require('electron');\nconst { Menu, MenuItem } = remote;\n\nconst useContextMenu = (menus, targetClass) => {\n  const clickElement = useRef(null);\n  useEffect(() => {\n    const menu = new Menu();\n    menus.forEach((item) => {\n      menu.append(new MenuItem(item));\n    });\n    const handleContextMenu = ({ target }) => {\n      // 只有 e.target被 target 包裹时才出现\n      // const targetEle = document.querySelector(target);\n      // if (targetEle && targetEle.contains(e.target)) {\n      //if (target.classList.contains(targetClass)) {\n      const parentNode = getParentNode(target, targetClass);\n      if (parentNode) {\n        clickElement.current = parentNode;\n        menu.popup({ window: remote.getCurrentWindow() });\n      }\n    };\n    window.addEventListener('contextmenu', handleContextMenu);\n    return () => {\n      window.removeEventListener('contextmenu', handleContextMenu);\n    };\n  }, []);\n  return clickElement;\n};\n\nexport default useContextMenu;\n","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/hooks/useKeyPressed.js",["1085"],"import { useState, useEffect } from 'react';\n\nconst useKeyPressed = (targetKeyCode) => {\n  const [keyPressed, setKeyPressed] = useState(false);\n  useEffect(() => {\n    const keyDownHandler = ({ keyCode }) => {\n      if (keyCode === targetKeyCode) {\n        setKeyPressed(true);\n      }\n    };\n    const keyUpHandler = ({ keyCode }) => {\n      if (keyCode === targetKeyCode) {\n        setKeyPressed(false);\n      }\n    };\n    document.addEventListener('keyup', keyUpHandler);\n    document.addEventListener('keydown', keyDownHandler);\n    return () => {\n      document.removeEventListener('keyup', keyUpHandler);\n      document.removeEventListener('keydown', keyDownHandler);\n    };\n  }, []);\n  return keyPressed;\n};\n\nexport default useKeyPressed;\n","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/todo/TodoList.js",["1086","1087","1088","1089","1090","1091","1092"],"import React, { useState } from 'react';\nimport moment from 'moment';\nimport styles from './index.less';\nimport { IColumn, ITask, EStatus, ERate, ERepeat } from './initial';\nimport shortid from 'shortid';\nimport { DragDropContext } from 'react-beautiful-dnd';\nimport Column from '../components/Column';\nimport { Input, Rate, Dropdown, Button, Menu } from 'antd';\nimport { ITodo } from './initial';\n\nconst switchColumnTask = (todoData, source, destination) => {\n  const { columns } = todoData;\n  let task;\n  let targetColumnIndex;\n  const newColumns = columns.map((column, index) => {\n    if (column.id === source.droppableId) {\n      task = column.tasks[source.index];\n      column.tasks.splice(source.index, 1);\n    }\n    if (column.id === destination.droppableId) {\n      targetColumnIndex = index;\n    }\n    return column;\n  });\n  if ((targetColumnIndex || targetColumnIndex === 0) && task) {\n    newColumns[targetColumnIndex].tasks.splice(destination.index, 0, task);\n  }\n  return { ...todoData, columns: newColumns };\n};\n\nconst deleteColumnTask = (todoData, source) => ({\n  ...todoData,\n  columns: todoData.columns.map((column) => {\n    if (column.id === source.droppableId) {\n      column.tasks.splice(source.index, 1);\n    }\n    return {\n      ...column,\n    };\n  }),\n});\n\nconst sortTaskByRate = (columns)=>\n  columns.map((column) => {\n    column.tasks.sort((a, b) => b.rate - a.rate);\n    return column;\n  });\n\n\nconst TodoList = (props) => {\n  const { todoData, onChange } = props;\n  const { columns = [] } = todoData;\n  const [taskRate, setTaskRate] = useState(ERate.zero);\n  const [inputTask, setInputTask] = useState('');\n  const [taskRepeat, setTaskRepeat] = useState(ERepeat.once);\n\n  const handleDragEnd = (result) => {\n    const { source, destination } = result;\n    if (!destination) {\n      const newTodoData = deleteColumnTask({ ...todoData }, source);\n      onChange(newTodoData);\n      return;\n    }\n    if (\n      source.droppableId === destination.droppableId &&\n      source.index === destination.index\n    ) {\n      return;\n    }\n    const newTodoData = switchColumnTask(todoData, source, destination);\n    onChange(newTodoData);\n  };\n  const rate = (\n    <Rate\n      allowClear={false}\n      value={taskRate}\n      defaultValue={ERate.zero}\n      count={4}\n      tooltips={[\n        '不紧急不重要',\n        '不紧急很重要',\n        '很紧急不重要',\n        '很紧急很重要',\n      ]}\n      style={{ fontSize: 14 }}\n      onChange={setTaskRate}\n    />\n  );\n  const handleAddTask = (value) => {\n    if (!inputTask) {\n      return;\n    }\n    columns[0].tasks.unshift({\n      id: shortid.generate(),\n      status: EStatus.todo,\n      content: inputTask,\n      rate: taskRate,\n      repeat: taskRepeat,\n    });\n    onChange({ ...todoData, columns });\n    setInputTask('');\n    setTaskRate(ERate.one);\n  };\n\n  const sortedColumns = sortTaskByRate(columns);\n  return (\n    <DragDropContext onDragEnd={handleDragEnd}>\n      {/* <div className={styles.title}>象限法则日程</div> */}\n      <Input.Search\n        value={inputTask}\n        className={styles.inputSearch}\n        placeholder=\"添加代办事项，记得打上紧急重要分哦～\"\n        enterButton={\n          <Button type=\"primary\" style={{ width: 80, background: '#6E6E6E' }}>\n            添加\n          </Button>\n        }\n        onChange={(e) => setInputTask(e.target.value)}\n        style={{\n          display: 'block',\n          width: '46%',\n          margin: '0 auto 12px',\n          marginTop: 30,\n        }}\n        size=\"middle\"\n        suffix={rate}\n        onSearch={handleAddTask}\n      />\n      <div className={styles.columns}>\n        {sortedColumns.map((column) => {\n          return <Column key={column.id} column={column} />;\n        })}\n      </div>\n    </DragDropContext>\n  );\n};\n\nexport default TodoList;\n","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/todo/initial.js",["1093","1094"],"import shortid from 'shortid';\nimport moment from 'moment';\n\nexport const ERepeat = {\n  once: 0,\n  everyday: 1,\n  weekly: 2,\n};\n\nexport const ERate = {\n  zero: 0,\n  one: 1,\n  two: 2,\n  three: 3,\n  four: 4,\n};\n\nexport const EStatus = {\n  todo: 0,\n  doing: 1,\n  done: 2,\n};\n\nexport const ESort = {\n  top: 1,\n  normal: 2,\n};\n\nexport const newTodo = (momentFn, id) => {\n  console.log('momentFn', momentFn, id);\n  const curTime = momentFn.valueOf();\n  return {\n    id,\n    title: momentFn.format('YYYYMMDD'),\n    createTime: curTime,\n    modifyTime: curTime,\n    sort: ESort.normal,\n    columns: [\n      {\n        id: 'column-todo',\n        name: '代办',\n        tasks: [],\n      },\n      {\n        id: 'column-inprogress',\n        name: '进行中',\n        tasks: [],\n      },\n      {\n        id: 'column-done',\n        name: '已完成',\n        tasks: [],\n      },\n    ],\n  };\n};\n\nexport const initTodo = (newTodo, newId) => {\n  return {\n    currentId: newId,\n    editId: '',\n    data: [newTodo],\n  };\n};\n","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/aim/EditAim.js",["1095","1096","1097"],"import React, { useState, useEffect, ChangeEvent } from 'react';\nimport { Input, Button, Select, DatePicker, InputNumber } from 'antd';\nimport { PlusOutlined } from '@ant-design/icons';\nimport moment from 'moment';\nimport styles from './index.less';\nimport shortid from 'shortid';\nimport { EAimType } from './initial';\n\nconst EditAim = (props) => {\n  const { data, editId, onSubmit, onEditChange } = props || {};\n  const [title, setTitle] = useState(data.title || '');\n  const [desc, setDesc] = useState(data.desc || '');\n  const [times, setTimes] = useState(data.times || 0);\n  const [startDate, setStartDate] = useState(\n    data.startDate || moment().format('YYYYMMDD')\n  );\n  const [branchs, setBranchs] = useState(\n    data.branchs || [{ id: shortid.generate(), name: '' }]\n  );\n  useEffect(() => {\n    setTitle(data.title);\n    setDesc(data.desc);\n    setTimes(data.times);\n    setStartDate(data.startDate);\n    setBranchs(data.branchs);\n  }, [data.id]);\n\n  const handleAddBranch = () => {\n    branchs.push({\n      id: shortid.generate(),\n      name: '',\n      desc: '',\n      times: 0,\n      currentTimes: 0,\n    });\n    setBranchs([...branchs]);\n    if (branchs.length === 1) {\n      setTimes(0);\n    }\n  };\n\n  const handleSubmit = () => {\n    onSubmit({\n      ...data,\n      createTime: moment().valueOf(),\n      title,\n      desc,\n      times,\n      startDate,\n      branchs,\n    });\n  };\n  const handleBranchChange = (key, e, index) => {\n    let newBranchs = [...branchs];\n    newBranchs[index][key] = e.target.value;\n    setBranchs(newBranchs);\n  };\n  const setBranchTimes = (num, index) => {\n    let newBranchs = [...branchs];\n    setTimes(times - newBranchs[index].times + num);\n    newBranchs[index].times = num;\n    setBranchs(newBranchs);\n  };\n  console.log('editAim', data.id);\n  const isEditing = data.id === editId;\n  return (\n    <div className={styles.EditAim}>\n      <div className={styles.formItem}>\n        <span className={styles.label}>目标名称：</span>\n        {isEditing ? (\n          <Input\n            onChange={(e) => setTitle(e.target.value)}\n            value={title}\n            style={{ width: '60%' }}\n            placeholder=\"请输入\"\n          />\n        ) : (\n          <div className={styles.aimTitle}>\n            {title}\n            <span\n              className={styles.edit}\n              onClick={() => onEditChange(EAimType.start, data.id)}\n            >\n              编辑\n            </span>\n          </div>\n        )}\n      </div>\n      <div className={styles.formItem}>\n        <span className={styles.label}>描述：</span>\n        {isEditing ? (\n          <Input.TextArea\n            rows={2}\n            onChange={(e) => setDesc(e.target.value)}\n            value={desc}\n            style={{ width: '60%' }}\n            placeholder=\"请输入\"\n          />\n        ) : (\n          <div style={{ width: '60%', wordWrap: 'break-word' }}>{desc}</div>\n        )}\n      </div>\n      {branchs.map((branch, index) => {\n        if (!branch) return null;\n        if (!isEditing && !branch.name) return null;\n        return (\n          <div key={branch.id}>\n            <div className={styles.formItem}>\n              <span className={styles.label}>分支{index + 1}：</span>\n              {isEditing ? (\n                <div className={styles.branchTitle}>\n                  <Input\n                    value={branch.name}\n                    onChange={(e) => handleBranchChange('name', e, index)}\n                    placeholder=\"请输入\"\n                  />\n                  <div className={styles.branchTimes}>\n                    <InputNumber\n                      placeholder=\"打卡次数\"\n                      style={{ flex: 1, margin: '0 6px' }}\n                      min={0}\n                      value={branch.times}\n                      onChange={(val) => setBranchTimes(Number(val), index)}\n                    />\n                    次打卡\n                  </div>\n                </div>\n              ) : (\n                <div className={styles.branchTitle}>\n                  {branch.name}\n                  <span>{branch.times}次打卡</span>\n                </div>\n              )}\n            </div>\n            <div className={styles.formItem}>\n              <span className={styles.label}></span>\n              {isEditing ? (\n                <Input.TextArea\n                  value={branch.desc}\n                  onChange={(e) => handleBranchChange('desc', e, index)}\n                  rows={2}\n                  style={{ width: '60%' }}\n                  placeholder=\"请输入\"\n                />\n              ) : (\n                <div style={{ width: '60%' }}>{branch.desc}</div>\n              )}\n            </div>\n          </div>\n        );\n      })}\n      {isEditing && (\n        <div className={styles.formItem}>\n          <span className={styles.label}></span>\n          <Button\n            type=\"dashed\"\n            style={{ width: '60%' }}\n            onClick={handleAddBranch}\n          >\n            <PlusOutlined /> 添加分支\n          </Button>\n        </div>\n      )}\n\n      <div className={styles.formItem}>\n        <span className={styles.label}>开始时间：</span>\n        <div className={styles.dateTimes} style={{ width: '60%' }}>\n          <div style={{ flex: 1 }}>\n            {isEditing ? (\n              <DatePicker\n                value={moment(startDate)}\n                onChange={(date) =>\n                  setStartDate(moment(date).format('YYYYMMDD'))\n                }\n                placeholder=\"开始时间\"\n                style={{ width: 280 }}\n              />\n            ) : (\n              <div>{startDate}</div>\n            )}\n          </div>\n          <div className={styles.times}>\n            <span className={styles.label}>预期投入：</span>\n            {isEditing ? (\n              <InputNumber\n                disabled={branchs.length > 0}\n                style={{ flex: 1, marginRight: 4 }}\n                min={0}\n                value={times}\n                onChange={(val) => setTimes(Number(val))}\n              />\n            ) : (\n              <span style={{ color: 'red', marginRight: 4 }}>{times}</span>\n            )}\n            次打卡\n          </div>\n        </div>\n      </div>\n      {isEditing && (\n        <div className={styles.formItem}>\n          <span className={styles.label}></span>\n          <div style={{ width: '60%', textAlign: 'left' }}>\n            <Button\n              type=\"primary\"\n              style={{ width: 180 }}\n              onClick={handleSubmit}\n            >\n              保存\n            </Button>\n          </div>\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default EditAim;\n","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/aim/initial.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/aim/AimList.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/note/initial.js",[],["1098","1099"],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Column.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Task.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/utils/treeHelper.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/utils/fileHelper.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/hooks/useIpcRenderer.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/setting/index.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/crash/index.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/index.js",[],["1100","1101"],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/utils/exportHtml.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/utils/exportMarkdown.js",["1102","1103"],"/**\n * Hi contributors!\n *\n * Before you edit or update codes in this file,\n * make sure you have read this bellow:\n * Commonmark Spec: https://spec.commonmark.org/0.29/\n * GitHub Flavored Markdown Spec: https://github.github.com/gfm/\n * Pandoc Markdown: https://pandoc.org/MANUAL.html#pandocs-markdown\n * The output markdown needs to obey the standards of these Spec.\n */\n\nclass ExportMarkdown {\n  constructor (blocks, listIndentation = 1, isGitlabCompatibilityEnabled = false) {\n    this.blocks = blocks\n    this.listType = [] // 'ul' or 'ol'\n    // helper to translate the first tight item in a nested list\n    this.isLooseParentList = true\n    this.isGitlabCompatibilityEnabled = !!isGitlabCompatibilityEnabled\n\n    // set and validate settings\n    this.listIndentation = 'number'\n    if (listIndentation === 'dfm') {\n      this.listIndentation = 'dfm'\n      this.listIndentationCount = 4\n    } else if (typeof listIndentation === 'number') {\n      this.listIndentationCount = Math.min(Math.max(listIndentation, 1), 4)\n    } else {\n      this.listIndentationCount = 1\n    }\n  }\n\n  generate () {\n    return this.translateBlocks2Markdown(this.blocks)\n  }\n\n  translateBlocks2Markdown (blocks, indent = '', listIndent = '') {\n    const result = []\n    // helper for CommonMark 264\n    let lastListBullet = ''\n\n    for (const block of blocks) {\n      if (block.type !== 'ul' && block.type !== 'ol') {\n        lastListBullet = ''\n      }\n\n      switch (block.type) {\n        case 'p':\n        case 'hr': {\n          this.insertLineBreak(result, indent)\n          result.push(this.translateBlocks2Markdown(block.children, indent))\n          break\n        }\n        case 'span': {\n          result.push(this.normalizeParagraphText(block, indent))\n          break\n        }\n        case 'h1':\n        case 'h2':\n        case 'h3':\n        case 'h4':\n        case 'h5':\n        case 'h6': {\n          this.insertLineBreak(result, indent)\n          result.push(this.normalizeHeaderText(block, indent))\n          break\n        }\n        case 'figure': {\n          this.insertLineBreak(result, indent)\n          switch (block.functionType) {\n            case 'table': {\n              const table = block.children[0]\n              result.push(this.normalizeTable(table, indent))\n              break\n            }\n            case 'html': {\n              result.push(this.normalizeHTML(block, indent))\n              break\n            }\n            case 'footnote': {\n              result.push(this.normalizeFootnote(block, indent))\n              break\n            }\n            case 'multiplemath': {\n              result.push(this.normalizeMultipleMath(block, indent))\n              break\n            }\n            case 'mermaid':\n            case 'flowchart':\n            case 'sequence':\n            case 'vega-lite': {\n              result.push(this.normalizeContainer(block, indent))\n              break\n            }\n          }\n          break\n        }\n        case 'li': {\n          const insertNewLine = block.isLooseListItem\n\n          // helper variable to correct the first tight item in a nested list\n          this.isLooseParentList = insertNewLine\n          if (insertNewLine) {\n            this.insertLineBreak(result, indent)\n          }\n          result.push(this.normalizeListItem(block, indent + listIndent))\n          this.isLooseParentList = true\n          break\n        }\n        case 'ul': {\n          let insertNewLine = this.isLooseParentList\n          this.isLooseParentList = true\n\n          // Start a new list without separation due changing the bullet or ordered list delimiter starts a new list.\n          const { bulletMarkerOrDelimiter } = block.children[0]\n          if (lastListBullet && lastListBullet !== bulletMarkerOrDelimiter) {\n            insertNewLine = false\n          }\n          lastListBullet = bulletMarkerOrDelimiter\n          if (insertNewLine) {\n            this.insertLineBreak(result, indent)\n          }\n\n          this.listType.push({ type: 'ul' })\n          result.push(this.normalizeList(block, indent, listIndent))\n          this.listType.pop()\n          break\n        }\n        case 'ol': {\n          let insertNewLine = this.isLooseParentList\n          this.isLooseParentList = true\n\n          // Start a new list without separation due changing the bullet or ordered list delimiter starts a new list.\n          const { bulletMarkerOrDelimiter } = block.children[0]\n          if (lastListBullet && lastListBullet !== bulletMarkerOrDelimiter) {\n            insertNewLine = false\n          }\n          lastListBullet = bulletMarkerOrDelimiter\n          if (insertNewLine) {\n            this.insertLineBreak(result, indent)\n          }\n          const listCount = block.start !== undefined ? block.start : 1\n          this.listType.push({ type: 'ol', listCount })\n          result.push(this.normalizeList(block, indent, listIndent))\n          this.listType.pop()\n          break\n        }\n        case 'pre': {\n          this.insertLineBreak(result, indent)\n          if (block.functionType === 'frontmatter') {\n            result.push(this.normalizeFrontMatter(block, indent))\n          } else {\n            result.push(this.normalizeCodeBlock(block, indent))\n          }\n          break\n        }\n        case 'blockquote': {\n          this.insertLineBreak(result, indent)\n          result.push(this.normalizeBlockquote(block, indent))\n          break\n        }\n        default: {\n          console.warn('translateBlocks2Markdown: Unknown block type:', block.type)\n          break\n        }\n      }\n    }\n    return result.join('')\n  }\n\n  insertLineBreak (result, indent) {\n    if (!result.length) return\n    result.push(`${indent}\\n`)\n  }\n\n  normalizeParagraphText (block, indent) {\n    const { text } = block\n    const lines = text.split('\\n')\n    return lines.map(line => `${indent}${line}`).join('\\n') + '\\n'\n  }\n\n  normalizeHeaderText (block, indent) {\n    const { headingStyle, marker } = block\n    const { text } = block.children[0]\n    if (headingStyle === 'atx') {\n      const match = text.match(/(#{1,6})(.*)/)\n      const atxHeadingText = `${match[1]} ${match[2].trim()}`\n      return `${indent}${atxHeadingText}\\n`\n    } else if (headingStyle === 'setext') {\n      const lines = text.trim().split('\\n')\n      return lines.map(line => `${indent}${line}`).join('\\n') + `\\n${indent}${marker.trim()}\\n`\n    }\n  }\n\n  normalizeBlockquote (block, indent) {\n    const { children } = block\n    const newIndent = `${indent}> `\n    return this.translateBlocks2Markdown(children, newIndent)\n  }\n\n  normalizeFrontMatter (block, indent) { // preBlock\n    let startToken\n    let endToken\n    switch (block.lang) {\n      case 'yaml':\n        startToken = '---\\n'\n        endToken = '---\\n'\n        break\n      case 'toml':\n        startToken = '+++\\n'\n        endToken = '+++\\n'\n        break\n      case 'json':\n        if (block.style === ';') {\n          startToken = ';;;\\n'\n          endToken = ';;;\\n'\n        } else {\n          startToken = '{\\n'\n          endToken = '}\\n'\n        }\n        break\n    }\n\n    const result = []\n    result.push(startToken)\n    for (const line of block.children[0].children) {\n      result.push(`${line.text}\\n`)\n    }\n    result.push(endToken)\n    return result.join('')\n  }\n\n  normalizeMultipleMath (block, /* figure */ indent) {\n    const { isGitlabCompatibilityEnabled } = this\n    let startToken = '$$'\n    let endToken = '$$'\n    if (isGitlabCompatibilityEnabled && block.mathStyle === 'gitlab') {\n      startToken = '```math'\n      endToken = '```'\n    }\n\n    const result = []\n    result.push(`${indent}${startToken}\\n`)\n    for (const line of block.children[0].children[0].children) {\n      result.push(`${indent}${line.text}\\n`)\n    }\n    result.push(`${indent}${endToken}\\n`)\n    return result.join('')\n  }\n\n  // `mermaid` `flowchart` `sequence` `vega-lite`\n  normalizeContainer (block, indent) {\n    const result = []\n    const diagramType = block.children[0].functionType\n    result.push('```' + diagramType + '\\n')\n    for (const line of block.children[0].children[0].children) {\n      result.push(`${line.text}\\n`)\n    }\n    result.push('```\\n')\n    return result.join('')\n  }\n\n  normalizeCodeBlock (block, indent) {\n    const result = []\n    const codeContent = block.children[1].children[0]\n    const textList = codeContent.text.split('\\n')\n    const { functionType } = block\n    if (functionType === 'fencecode') {\n      result.push(`${indent}${block.lang ? '```' + block.lang + '\\n' : '```\\n'}`)\n      textList.forEach(text => {\n        result.push(`${indent}${text}\\n`)\n      })\n      result.push(indent + '```\\n')\n    } else {\n      textList.forEach(text => {\n        result.push(`${indent}    ${text}\\n`)\n      })\n    }\n\n    return result.join('')\n  }\n\n  normalizeHTML (block, indent) { // figure\n    const result = []\n    const codeContentText = block.children[0].children[0].children[0].text\n    const lines = codeContentText.split('\\n')\n    for (const line of lines) {\n      result.push(`${indent}${line}\\n`)\n    }\n    return result.join('')\n  }\n\n  normalizeTable (table, indent) {\n    const result = []\n    const { row, column } = table\n    const tableData = []\n    const tHeader = table.children[0]\n    const tBody = table.children[1]\n    const escapeText = str => {\n      return str.replace(/([^\\\\])\\|/g, '$1\\\\|')\n    }\n\n    tableData.push(tHeader.children[0].children.map(th => escapeText(th.children[0].text).trim()))\n    if (tBody) {\n      tBody.children.forEach(bodyRow => {\n        tableData.push(bodyRow.children.map(td => escapeText(td.children[0].text).trim()))\n      })\n    }\n\n    const columnWidth = tHeader.children[0].children.map(th => ({ width: 5, align: th.align }))\n\n    let i\n    let j\n\n    for (i = 0; i <= row; i++) {\n      for (j = 0; j <= column; j++) {\n        columnWidth[j].width = Math.max(columnWidth[j].width, tableData[i][j].length + 2) // add 2, because have two space around text\n      }\n    }\n    tableData.forEach((r, i) => {\n      const rs = indent + '|' + r.map((cell, j) => {\n        const raw = ` ${cell + ' '.repeat(columnWidth[j].width)}`\n        return raw.substring(0, columnWidth[j].width)\n      }).join('|') + '|'\n      result.push(rs)\n      if (i === 0) {\n        const cutOff = indent + '|' + columnWidth.map(({ width, align }) => {\n          let raw = '-'.repeat(width - 2)\n          switch (align) {\n            case 'left':\n              raw = `:${raw} `\n              break\n            case 'center':\n              raw = `:${raw}:`\n              break\n            case 'right':\n              raw = ` ${raw}:`\n              break\n            default:\n              raw = ` ${raw} `\n              break\n          }\n          return raw\n        }).join('|') + '|'\n        result.push(cutOff)\n      }\n    })\n    return result.join('\\n') + '\\n'\n  }\n\n  normalizeList (block, indent, listIndent) {\n    const { children } = block\n    return this.translateBlocks2Markdown(children, indent, listIndent)\n  }\n\n  normalizeListItem (block, indent) {\n    const result = []\n    const listInfo = this.listType[this.listType.length - 1]\n    const isUnorderedList = listInfo.type === 'ul'\n    let { children, bulletMarkerOrDelimiter } = block\n    let itemMarker\n\n    if (isUnorderedList) {\n      itemMarker = bulletMarkerOrDelimiter ? `${bulletMarkerOrDelimiter} ` : '- '\n    } else {\n      // NOTE: GitHub and Bitbucket limit the list count to 99 but this is nowhere defined.\n      //  We limit the number to 99 for Daring Fireball Markdown to prevent indentation issues.\n      let n = listInfo.listCount\n      if ((this.listIndentation === 'dfm' && n > 99) || n > 999999999) {\n        n = 1\n      }\n      listInfo.listCount++\n\n      const delimiter = bulletMarkerOrDelimiter || '.'\n      itemMarker = `${n}${delimiter} `\n    }\n\n    // Subsequent paragraph indentation\n    const newIndent = indent + ' '.repeat(itemMarker.length)\n\n    // New list indentation. We already added one space to the indentation\n    let listIndent = ''\n    const { listIndentation } = this\n    if (listIndentation === 'dfm') {\n      listIndent = ' '.repeat(4 - itemMarker.length)\n    } else if (listIndentation === 'number') {\n      listIndent = ' '.repeat(this.listIndentationCount - 1)\n    }\n\n    // TODO: Indent subsequent paragraphs by one tab. - not important\n    //  Problem: \"translateBlocks2Markdown\" use \"indent\" in spaces to indent elements. How should\n    //  we integrate tabs in blockquotes and subsequent paragraphs and how to combine with spaces?\n    //  I don't know how to combine tabs and spaces and it seems not specified, so work for another day.\n\n    if (isUnorderedList && block.listItemType === 'task') {\n      const firstChild = children[0]\n      itemMarker += firstChild.checked ? '[x] ' : '[ ] '\n      children = children.slice(1)\n    }\n\n    result.push(`${indent}${itemMarker}`)\n    result.push(this.translateBlocks2Markdown(children, newIndent, listIndent).substring(newIndent.length))\n    return result.join('')\n  }\n\n  normalizeFootnote (block, indent) {\n    const result = []\n    const identifier = block.children[0].text\n    result.push(`${indent}[^${identifier}]:`)\n    const hasMultipleBlocks = block.children.length > 2 || block.children[1].type !== 'p'\n    if (hasMultipleBlocks) {\n      result.push('\\n')\n      const newIndent = indent + ' '.repeat(4)\n      result.push(this.translateBlocks2Markdown(block.children.slice(1), newIndent))\n    } else {\n      result.push(' ')\n      const paragraphContent = block.children[1].children[0]\n      result.push(this.normalizeParagraphText(paragraphContent, indent))\n    }\n\n    return result.join('')\n  }\n}\n\nexport default ExportMarkdown\n","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/eventHandler/clickEvent.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/eventHandler/keyboard.js",["1104"],"import { EVENT_KEYS } from '../config'\nimport selection from '../selection'\nimport { findNearestParagraph } from '../selection/dom'\nimport { getParagraphReference, getImageInfo } from '../utils'\nimport { checkEditEmoji } from '../ui/emojis'\n\nclass Keyboard {\n  constructor (muya) {\n    this.muya = muya\n    this.isComposed = false\n    this.shownFloat = new Set()\n    this.recordIsComposed()\n    this.dispatchEditorState()\n    this.keydownBinding()\n    this.keyupBinding()\n    this.inputBinding()\n    this.listen()\n  }\n\n  listen () {\n    // cache shown float box\n    this.muya.eventCenter.subscribe('muya-float', (tool, status) => {\n      status ? this.shownFloat.add(tool) : this.shownFloat.delete(tool)\n      if (tool.name === 'ag-front-menu' && !status) {\n        const seletedParagraph = this.muya.container.querySelector('.ag-selected')\n        if (seletedParagraph) {\n          this.muya.contentState.selectedBlock = null\n          // prevent rerender, so change the class manually.\n          seletedParagraph.classList.toggle('ag-selected')\n        }\n      }\n    })\n  }\n\n  hideAllFloatTools () {\n    for (const tool of this.shownFloat) {\n      tool.hide()\n    }\n  }\n\n  recordIsComposed () {\n    const { container, eventCenter, contentState } = this.muya\n    const handler = event => {\n      if (event.type === 'compositionstart') {\n        this.isComposed = true\n      } else if (event.type === 'compositionend') {\n        this.isComposed = false\n        // Because the compose event will not cause `input` event, So need call `inputHandler` by ourself\n        contentState.inputHandler(event)\n        eventCenter.dispatch('stateChange')\n      }\n    }\n\n    eventCenter.attachDOMEvent(container, 'compositionend', handler)\n    // eventCenter.attachDOMEvent(container, 'compositionupdate', handler)\n    eventCenter.attachDOMEvent(container, 'compositionstart', handler)\n  }\n\n  dispatchEditorState () {\n    const { container, eventCenter } = this.muya\n\n    let timer = null\n    const changeHandler = event => {\n      if (\n        event.type === 'keyup' &&\n        (event.key === EVENT_KEYS.ArrowUp || event.key === EVENT_KEYS.ArrowDown) &&\n        this.shownFloat.size > 0\n      ) {\n        return\n      }\n      // Cursor outside editor area or over not editable elements.\n      if (event.target.closest('[contenteditable=false]')) {\n        return\n      }\n\n      // We need check cursor is null, because we may copy the html preview content,\n      // and no need to dispatch change.\n      const { start, end } = selection.getCursorRange()\n      if (!start || !end) {\n        return\n      }\n\n      if (timer) clearTimeout(timer)\n      timer = setTimeout(() => {\n        this.muya.dispatchSelectionChange()\n        this.muya.dispatchSelectionFormats()\n        if (!this.isComposed && event.type === 'click') {\n          this.muya.dispatchChange()\n        }\n      })\n    }\n\n    eventCenter.attachDOMEvent(container, 'click', changeHandler)\n    eventCenter.attachDOMEvent(container, 'keyup', changeHandler)\n  }\n\n  keydownBinding () {\n    const { container, eventCenter, contentState } = this.muya\n    const docHandler = event => {\n      switch (event.code) {\n        case EVENT_KEYS.Enter:\n          return contentState.docEnterHandler(event)\n        case EVENT_KEYS.Space: {\n          if (contentState.selectedImage) {\n            const { token } = contentState.selectedImage\n            const { src } = getImageInfo(token.src || token.attrs.src)\n            if (src) {\n              eventCenter.dispatch('preview-image', {\n                data: src\n              })\n            }\n          }\n          break\n        }\n        case EVENT_KEYS.Backspace: {\n          return contentState.docBackspaceHandler(event)\n        }\n        case EVENT_KEYS.Delete: {\n          return contentState.docDeleteHandler(event)\n        }\n        case EVENT_KEYS.ArrowUp: // fallthrough\n        case EVENT_KEYS.ArrowDown: // fallthrough\n        case EVENT_KEYS.ArrowLeft: // fallthrough\n        case EVENT_KEYS.ArrowRight: // fallthrough\n          return contentState.docArrowHandler(event)\n      }\n    }\n\n    const handler = event => {\n      if (event.metaKey || event.ctrlKey) {\n        container.classList.add('ag-meta-or-ctrl')\n      }\n\n      if (\n        this.shownFloat.size > 0 &&\n        (\n          event.key === EVENT_KEYS.Enter ||\n          event.key === EVENT_KEYS.Escape ||\n          event.key === EVENT_KEYS.Tab ||\n          event.key === EVENT_KEYS.ArrowUp ||\n          event.key === EVENT_KEYS.ArrowDown\n        )\n      ) {\n        let needPreventDefault = false\n\n        for (const tool of this.shownFloat) {\n          if (\n            tool.name === 'ag-format-picker' ||\n            tool.name === 'ag-table-picker' ||\n            tool.name === 'ag-quick-insert' ||\n            tool.name === 'ag-emoji-picker' ||\n            tool.name === 'ag-front-menu' ||\n            tool.name === 'ag-list-picker' ||\n            tool.name === 'ag-image-selector'\n          ) {\n            needPreventDefault = true\n            break\n          }\n        }\n        if (needPreventDefault) {\n          event.preventDefault()\n        }\n        // event.stopPropagation()\n        return\n      }\n      switch (event.key) {\n        case EVENT_KEYS.Backspace:\n          contentState.backspaceHandler(event)\n          break\n        case EVENT_KEYS.Delete:\n          contentState.deleteHandler(event)\n          break\n        case EVENT_KEYS.Enter:\n          if (!this.isComposed) {\n            contentState.enterHandler(event)\n            this.muya.dispatchChange()\n          }\n          break\n        case EVENT_KEYS.ArrowUp: // fallthrough\n        case EVENT_KEYS.ArrowDown: // fallthrough\n        case EVENT_KEYS.ArrowLeft: // fallthrough\n        case EVENT_KEYS.ArrowRight: // fallthrough\n          if (!this.isComposed) {\n            contentState.arrowHandler(event)\n          }\n          break\n        case EVENT_KEYS.Tab:\n          contentState.tabHandler(event)\n          break\n        default:\n          break\n      }\n    }\n\n    eventCenter.attachDOMEvent(container, 'keydown', handler)\n    eventCenter.attachDOMEvent(document, 'keydown', docHandler)\n  }\n\n  inputBinding () {\n    const { container, eventCenter, contentState } = this.muya\n    const inputHandler = event => {\n      if (!this.isComposed) {\n        contentState.inputHandler(event)\n        this.muya.dispatchChange()\n      }\n\n      const { lang, paragraph } = contentState.checkEditLanguage()\n      if (lang) {\n        eventCenter.dispatch('muya-code-picker', {\n          reference: getParagraphReference(paragraph, paragraph.id),\n          lang,\n          cb: item => {\n            contentState.selectLanguage(paragraph, item.name)\n          }\n        })\n      } else {\n        // hide code picker float box\n        eventCenter.dispatch('muya-code-picker', { reference: null })\n      }\n    }\n\n    eventCenter.attachDOMEvent(container, 'input', inputHandler)\n  }\n\n  keyupBinding () {\n    const { container, eventCenter, contentState } = this.muya\n    const handler = event => {\n      container.classList.remove('ag-meta-or-ctrl')\n      // check if edit emoji\n      const node = selection.getSelectionStart()\n      const paragraph = findNearestParagraph(node)\n      const emojiNode = checkEditEmoji(node)\n      contentState.selectedImage = null\n      if (\n        paragraph &&\n        emojiNode &&\n        event.key !== EVENT_KEYS.Enter &&\n        event.key !== EVENT_KEYS.ArrowDown &&\n        event.key !== EVENT_KEYS.ArrowUp &&\n        event.key !== EVENT_KEYS.Tab &&\n        event.key !== EVENT_KEYS.Escape\n      ) {\n        const reference = getParagraphReference(emojiNode, paragraph.id)\n        eventCenter.dispatch('muya-emoji-picker', {\n          reference,\n          emojiNode\n        })\n      }\n      if (!emojiNode) {\n        eventCenter.dispatch('muya-emoji-picker', {\n          emojiNode\n        })\n      }\n\n      const { anchor, focus, start, end } = selection.getCursorRange()\n      if (!anchor || !focus) {\n        return\n      }\n      if (\n        !this.isComposed\n      ) {\n        const { anchor: oldAnchor, focus: oldFocus } = contentState.cursor\n        if (\n          anchor.key !== oldAnchor.key ||\n          anchor.offset !== oldAnchor.offset ||\n          focus.key !== oldFocus.key ||\n          focus.offset !== oldFocus.offset\n        ) {\n          const needRender = contentState.checkNeedRender(contentState.cursor) || contentState.checkNeedRender({ start, end })\n          contentState.cursor = { anchor, focus }\n          if (needRender) {\n            return contentState.partialRender()\n          }\n        }\n      }\n\n      const block = contentState.getBlock(anchor.key)\n      if (\n        anchor.key === focus.key &&\n        anchor.offset !== focus.offset &&\n        block.functionType !== 'codeContent' &&\n        block.functionType !== 'languageInput'\n      ) {\n        const reference = contentState.getPositionReference()\n        const { formats } = contentState.selectionFormats()\n        eventCenter.dispatch('muya-format-picker', { reference, formats })\n      } else {\n        eventCenter.dispatch('muya-format-picker', { reference: null })\n      }\n    }\n\n    eventCenter.attachDOMEvent(container, 'keyup', handler) // temp use input event\n  }\n}\n\nexport default Keyboard\n","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/eventHandler/clipboard.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/eventHandler/resize.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/eventHandler/mouseEvent.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/eventHandler/event.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/eventHandler/dragDrop.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/utils/index.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/config/index.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/ui/tooltip/index.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/contentState/index.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/utils/getLinkInfo.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/selection/dom.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/utils/getImageInfo.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/utils/domManipulate.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/utils/dompurify.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/ui/emojis/index.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/selection/index.js",["1105","1106","1107"],"/**\n * This file is copy from [medium-editor](https://github.com/yabwe/medium-editor)\n * and customize for specialized use.\n */\nimport Cursor from './cursor'\nimport { CLASS_OR_ID } from '../config'\nimport {\n  isBlockContainer,\n  traverseUp,\n  getFirstSelectableLeafNode,\n  getClosestBlockContainer,\n  getCursorPositionWithinMarkedText,\n  findNearestParagraph,\n  getTextContent,\n  getOffsetOfParagraph\n} from './dom'\n\nconst filterOnlyParentElements = node => {\n  return isBlockContainer(node) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP\n}\n\nclass Selection {\n  constructor (doc) {\n    this.doc = doc // document\n  }\n\n  findMatchingSelectionParent (testElementFunction, contentWindow) {\n    const selection = contentWindow.getSelection()\n    let range\n    let current\n\n    if (selection.rangeCount === 0) {\n      return false\n    }\n\n    range = selection.getRangeAt(0)\n    current = range.commonAncestorContainer\n\n    return traverseUp(current, testElementFunction)\n  }\n\n  // https://stackoverflow.com/questions/17678843/cant-restore-selection-after-html-modify-even-if-its-the-same-html\n  // Tim Down\n  //\n  // {object} selectionState - the selection to import\n  // {DOMElement} root - the root element the selection is being restored inside of\n  // {boolean} [favorLaterSelectionAnchor] - defaults to false. If true, import the cursor immediately\n  //      subsequent to an anchor tag if it would otherwise be placed right at the trailing edge inside the\n  //      anchor. This cursor positioning, even though visually equivalent to the user, can affect behavior\n  //      in MS IE.\n  importSelection (selectionState, root, favorLaterSelectionAnchor) {\n    if (!selectionState || !root) {\n      throw new Error('your must provide a [selectionState] and a [root] element')\n    }\n\n    let range = this.doc.createRange()\n    range.setStart(root, 0)\n    range.collapse(true)\n\n    let node = root\n    const nodeStack = []\n    let charIndex = 0\n    let foundStart = false\n    let foundEnd = false\n    let trailingImageCount = 0\n    let stop = false\n    let nextCharIndex\n    let allowRangeToStartAtEndOfNode = false\n    let lastTextNode = null\n\n    // When importing selection, the start of the selection may lie at the end of an element\n    // or at the beginning of an element.  Since visually there is no difference between these 2\n    // we will try to move the selection to the beginning of an element since this is generally\n    // what users will expect and it's a more predictable behavior.\n    //\n    // However, there are some specific cases when we don't want to do this:\n    //  1) We're attempting to move the cursor outside of the end of an anchor [favorLaterSelectionAnchor = true]\n    //  2) The selection starts with an image, which is special since an image doesn't have any 'content'\n    //     as far as selection and ranges are concerned\n    //  3) The selection starts after a specified number of empty block elements (selectionState.emptyBlocksIndex)\n    //\n    // For these cases, we want the selection to start at a very specific location, so we should NOT\n    // automatically move the cursor to the beginning of the first actual chunk of text\n    if (favorLaterSelectionAnchor || selectionState.startsWithImage || typeof selectionState.emptyBlocksIndex !== 'undefined') {\n      allowRangeToStartAtEndOfNode = true\n    }\n\n    while (!stop && node) {\n      // Only iterate over elements and text nodes\n      if (node.nodeType > 3) {\n        node = nodeStack.pop()\n        continue\n      }\n\n      // If we hit a text node, we need to add the amount of characters to the overall count\n      if (node.nodeType === 3 && !foundEnd) {\n        nextCharIndex = charIndex + node.length\n        // Check if we're at or beyond the start of the selection we're importing\n        if (!foundStart && selectionState.start >= charIndex && selectionState.start <= nextCharIndex) {\n          // NOTE: We only want to allow a selection to start at the END of an element if\n          //  allowRangeToStartAtEndOfNode is true\n          if (allowRangeToStartAtEndOfNode || selectionState.start < nextCharIndex) {\n            range.setStart(node, selectionState.start - charIndex)\n            foundStart = true\n          } else {\n            // We're at the end of a text node where the selection could start but we shouldn't\n            // make the selection start here because allowRangeToStartAtEndOfNode is false.\n            // However, we should keep a reference to this node in case there aren't any more\n            // text nodes after this, so that we have somewhere to import the selection to\n            lastTextNode = node\n          }\n        }\n        // We've found the start of the selection, check if we're at or beyond the end of the selection we're importing\n        if (foundStart && selectionState.end >= charIndex && selectionState.end <= nextCharIndex) {\n          if (!selectionState.trailingImageCount) {\n            range.setEnd(node, selectionState.end - charIndex)\n            stop = true\n          } else {\n            foundEnd = true\n          }\n        }\n        charIndex = nextCharIndex\n      } else {\n        if (selectionState.trailingImageCount && foundEnd) {\n          if (node.nodeName.toLowerCase() === 'img') {\n            trailingImageCount++\n          }\n          if (trailingImageCount === selectionState.trailingImageCount) {\n            // Find which index the image is in its parent's children\n            let endIndex = 0\n            while (node.parentNode.childNodes[endIndex] !== node) {\n              endIndex++\n            }\n            range.setEnd(node.parentNode, endIndex + 1)\n            stop = true\n          }\n        }\n\n        if (!stop && node.nodeType === 1) {\n          // this is an element\n          // add all its children to the stack\n          let i = node.childNodes.length - 1\n          while (i >= 0) {\n            nodeStack.push(node.childNodes[i])\n            i -= 1\n          }\n        }\n      }\n\n      if (!stop) {\n        node = nodeStack.pop()\n      }\n    }\n\n    // If we've gone through the entire text but didn't find the beginning of a text node\n    // to make the selection start at, we should fall back to starting the selection\n    // at the END of the last text node we found\n    if (!foundStart && lastTextNode) {\n      range.setStart(lastTextNode, lastTextNode.length)\n      range.setEnd(lastTextNode, lastTextNode.length)\n    }\n\n    if (typeof selectionState.emptyBlocksIndex !== 'undefined') {\n      range = this.importSelectionMoveCursorPastBlocks(root, selectionState.emptyBlocksIndex, range)\n    }\n\n    // If the selection is right at the ending edge of a link, put it outside the anchor tag instead of inside.\n    if (favorLaterSelectionAnchor) {\n      range = this.importSelectionMoveCursorPastAnchor(selectionState, range)\n    }\n\n    this.selectRange(range)\n  }\n\n  // Utility method called from importSelection only\n  importSelectionMoveCursorPastAnchor (selectionState, range) {\n    const nodeInsideAnchorTagFunction = function (node) {\n      return node.nodeName.toLowerCase() === 'a'\n    }\n    if (selectionState.start === selectionState.end &&\n      range.startContainer.nodeType === 3 &&\n      range.startOffset === range.startContainer.nodeValue.length &&\n      traverseUp(range.startContainer, nodeInsideAnchorTagFunction)) {\n      let prevNode = range.startContainer\n      let currentNode = range.startContainer.parentNode\n      while (currentNode !== null && currentNode.nodeName.toLowerCase() !== 'a') {\n        if (currentNode.childNodes[currentNode.childNodes.length - 1] !== prevNode) {\n          currentNode = null\n        } else {\n          prevNode = currentNode\n          currentNode = currentNode.parentNode\n        }\n      }\n      if (currentNode !== null && currentNode.nodeName.toLowerCase() === 'a') {\n        let currentNodeIndex = null\n        for (let i = 0; currentNodeIndex === null && i < currentNode.parentNode.childNodes.length; i++) {\n          if (currentNode.parentNode.childNodes[i] === currentNode) {\n            currentNodeIndex = i\n          }\n        }\n        range.setStart(currentNode.parentNode, currentNodeIndex + 1)\n        range.collapse(true)\n      }\n    }\n    return range\n  }\n\n  // Uses the emptyBlocksIndex calculated by getIndexRelativeToAdjacentEmptyBlocks\n  // to move the cursor back to the start of the correct paragraph\n  importSelectionMoveCursorPastBlocks (root, index = 1, range) {\n    const treeWalker = this.doc.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, filterOnlyParentElements, false)\n    const startContainer = range.startContainer\n    let startBlock\n    let targetNode\n    let currIndex = 0\n    // If index is 0, we still want to move to the next block\n\n    // Chrome counts newlines and spaces that separate block elements as actual elements.\n    // If the selection is inside one of these text nodes, and it has a previous sibling\n    // which is a block element, we want the treewalker to start at the previous sibling\n    // and NOT at the parent of the textnode\n    if (startContainer.nodeType === 3 && isBlockContainer(startContainer.previousSibling)) {\n      startBlock = startContainer.previousSibling\n    } else {\n      startBlock = getClosestBlockContainer(startContainer)\n    }\n\n    // Skip over empty blocks until we hit the block we want the selection to be in\n    while (treeWalker.nextNode()) {\n      if (!targetNode) {\n        // Loop through all blocks until we hit the starting block element\n        if (startBlock === treeWalker.currentNode) {\n          targetNode = treeWalker.currentNode\n        }\n      } else {\n        targetNode = treeWalker.currentNode\n        currIndex++\n        // We hit the target index, bail\n        if (currIndex === index) {\n          break\n        }\n        // If we find a non-empty block, ignore the emptyBlocksIndex and just put selection here\n        if (targetNode.textContent.length > 0) {\n          break\n        }\n      }\n    }\n\n    if (!targetNode) {\n      targetNode = startBlock\n    }\n\n    // We're selecting a high-level block node, so make sure the cursor gets moved into the deepest\n    // element at the beginning of the block\n    range.setStart(getFirstSelectableLeafNode(targetNode), 0)\n\n    return range\n  }\n\n  // https://stackoverflow.com/questions/4176923/html-of-selected-text\n  // by Tim Down\n  getSelectionHtml () {\n    const sel = this.doc.getSelection()\n    let i\n    let html = ''\n    let len\n    let container\n    if (sel.rangeCount) {\n      container = this.doc.createElement('div')\n      for (i = 0, len = sel.rangeCount; i < len; i += 1) {\n        container.appendChild(sel.getRangeAt(i).cloneContents())\n      }\n      html = container.innerHTML\n    }\n    return html\n  }\n\n  chopHtmlByCursor (root) {\n    const { left } = this.getCaretOffsets(root)\n    const markedText = root.textContent\n    const { type, info } = getCursorPositionWithinMarkedText(markedText, left)\n    const pre = markedText.slice(0, left)\n    const post = markedText.slice(left)\n    switch (type) {\n      case 'OUT':\n        return {\n          pre,\n          post\n        }\n      case 'IN':\n        return {\n          pre: `${pre}${info}`,\n          post: `${info}${post}`\n        }\n      case 'LEFT':\n        return {\n          pre: markedText.slice(0, left - info),\n          post: markedText.slice(left - info)\n        }\n      case 'RIGHT':\n        return {\n          pre: markedText.slice(0, left + info),\n          post: markedText.slice(left + info)\n        }\n    }\n  }\n\n  /**\n   *  Find the caret position within an element irrespective of any inline tags it may contain.\n   *\n   *  @param {DOMElement} An element containing the cursor to find offsets relative to.\n   *  @param {Range} A Range representing cursor position. Will window.getSelection if none is passed.\n   *  @return {Object} 'left' and 'right' attributes contain offsets from beginning and end of Element\n   */\n  getCaretOffsets (element, range) {\n    let preCaretRange\n    let postCaretRange\n\n    if (!range) {\n      range = window.getSelection().getRangeAt(0)\n    }\n\n    preCaretRange = range.cloneRange()\n    postCaretRange = range.cloneRange()\n\n    preCaretRange.selectNodeContents(element)\n    preCaretRange.setEnd(range.endContainer, range.endOffset)\n\n    postCaretRange.selectNodeContents(element)\n    postCaretRange.setStart(range.endContainer, range.endOffset)\n\n    return {\n      left: preCaretRange.toString().length,\n      right: postCaretRange.toString().length\n    }\n  }\n\n  selectNode (node) {\n    const range = this.doc.createRange()\n    range.selectNodeContents(node)\n    this.selectRange(range)\n  }\n\n  select (startNode, startOffset, endNode, endOffset) {\n    const range = this.doc.createRange()\n    range.setStart(startNode, startOffset)\n    if (endNode) {\n      range.setEnd(endNode, endOffset)\n    } else {\n      range.collapse(true)\n    }\n    this.selectRange(range)\n    return range\n  }\n\n  setFocus (focusNode, focusOffset) {\n    const selection = this.doc.getSelection()\n    selection.extend(focusNode, focusOffset)\n  }\n\n  /**\n   *  Clear the current highlighted selection and set the caret to the start or the end of that prior selection, defaults to end.\n   *\n   *  @param {boolean} moveCursorToStart  A boolean representing whether or not to set the caret to the beginning of the prior selection.\n   */\n  clearSelection (moveCursorToStart) {\n    const { rangeCount } = this.doc.getSelection()\n    if (!rangeCount) return\n    if (moveCursorToStart) {\n      this.doc.getSelection().collapseToStart()\n    } else {\n      this.doc.getSelection().collapseToEnd()\n    }\n  }\n\n  /**\n   * Move cursor to the given node with the given offset.\n   *\n   * @param  {DomElement}  node    Element where to jump\n   * @param  {integer}     offset  Where in the element should we jump, 0 by default\n   */\n  moveCursor (node, offset) {\n    this.select(node, offset)\n  }\n\n  getSelectionRange () {\n    const selection = this.doc.getSelection()\n    if (selection.rangeCount === 0) {\n      return null\n    }\n    return selection.getRangeAt(0)\n  }\n\n  selectRange (range) {\n    const selection = this.doc.getSelection()\n\n    selection.removeAllRanges()\n    selection.addRange(range)\n  }\n\n  // https://stackoverflow.com/questions/1197401/\n  // how-can-i-get-the-element-the-caret-is-in-with-javascript-when-using-contenteditable\n  // by You\n  getSelectionStart () {\n    const node = this.doc.getSelection().anchorNode\n    const startNode = (node && node.nodeType === 3 ? node.parentNode : node)\n\n    return startNode\n  }\n\n  setCursorRange (cursorRange) {\n    const { anchor, focus } = cursorRange\n    const anchorParagraph = document.querySelector(`#${anchor.key}`)\n    const focusParagraph = document.querySelector(`#${focus.key}`)\n    const getNodeAndOffset = (node, offset) => {\n      if (node.nodeType === 3) {\n        return {\n          node,\n          offset\n        }\n      }\n\n      const childNodes = node.childNodes\n      const len = childNodes.length\n      let i\n      let count = 0\n      for (i = 0; i < len; i++) {\n        const child = childNodes[i]\n        const textContent = getTextContent(child, [CLASS_OR_ID.AG_MATH_RENDER, CLASS_OR_ID.AG_RUBY_RENDER])\n        const textLength = textContent.length\n        if (child.classList && child.classList.contains(CLASS_OR_ID.AG_FRONT_ICON)) {\n          continue\n        }\n\n        // Fix #1460 - put the cursor at the next text node or element if it can be put at the last of /^\\n$/ or the next text node/element.\n        if (/^\\n$/.test(textContent) && i !== len - 1 ? count + textLength > offset : count + textLength >= offset) {\n          if (\n            child.classList && child.classList.contains('ag-inline-image')\n          ) {\n            const imageContainer = child.querySelector('.ag-image-container')\n            const hasImg = imageContainer.querySelector('img')\n\n            if (!hasImg) {\n              return {\n                node: child,\n                offset: 0\n              }\n            }\n            if (count + textLength === offset) {\n              if (child.nextElementSibling) {\n                return {\n                  node: child.nextElementSibling,\n                  offset: 0\n                }\n              } else {\n                return {\n                  node: imageContainer,\n                  offset: 1\n                }\n              }\n            } else if (count === offset && count === 0) {\n              return {\n                node: imageContainer,\n                offset: 0\n              }\n            } else {\n              return {\n                node: child,\n                offset: 0\n              }\n            }\n          } else {\n            return getNodeAndOffset(child, offset - count)\n          }\n        } else {\n          count += textLength\n        }\n      }\n      return { node, offset }\n    }\n\n    let { node: anchorNode, offset: anchorOffset } = getNodeAndOffset(anchorParagraph, anchor.offset)\n    let { node: focusNode, offset: focusOffset } = getNodeAndOffset(focusParagraph, focus.offset)\n\n    if (anchorNode.nodeType === 3 || anchorNode.nodeType === 1 && !anchorNode.classList.contains('ag-image-container')) {\n      anchorOffset = Math.min(anchorOffset, anchorNode.textContent.length)\n      focusOffset = Math.min(focusOffset, focusNode.textContent.length)\n    }\n\n    // First set the anchor node and anchor offset, make it collapsed\n    this.select(anchorNode, anchorOffset)\n    // Secondly, set the focus node and focus offset.\n    this.setFocus(focusNode, focusOffset)\n  }\n\n  isValidCursorNode (node) {\n    if (!node) return false\n    if (node.nodeType === 3) {\n      node = node.parentNode\n    }\n\n    return node.closest('span.ag-paragraph')\n  }\n\n  getCursorRange () {\n    let { anchorNode, anchorOffset, focusNode, focusOffset } = this.doc.getSelection()\n    const isAnchorValid = this.isValidCursorNode(anchorNode)\n    const isFocusValid = this.isValidCursorNode(focusNode)\n    let needFix = false\n    if (!isAnchorValid && isFocusValid) {\n      needFix = true\n      anchorNode = focusNode\n      anchorOffset = focusOffset\n    } else if (isAnchorValid && !isFocusValid) {\n      needFix = true\n      focusNode = anchorNode\n      focusOffset = anchorOffset\n    } else if (!isAnchorValid && !isFocusValid) {\n      const editor = document.querySelector('#ag-editor-id').parentNode\n      editor.blur()\n\n      return new Cursor({\n        start: null,\n        end: null,\n        anchor: null,\n        focus: null\n      })\n    }\n\n    // fix bug click empty line, the cursor will jump to the end of pre line.\n    if (\n      anchorNode === focusNode &&\n      anchorOffset === focusOffset &&\n      anchorNode.textContent === '\\n' &&\n      focusOffset === 0\n    ) {\n      focusOffset = anchorOffset = 1\n    }\n\n    const anchorParagraph = findNearestParagraph(anchorNode)\n    const focusParagraph = findNearestParagraph(focusNode)\n\n    let aOffset = getOffsetOfParagraph(anchorNode, anchorParagraph) + anchorOffset\n    let fOffset = getOffsetOfParagraph(focusNode, focusParagraph) + focusOffset\n\n    // fix input after image.\n    if (\n      anchorNode === focusNode &&\n      anchorOffset === focusOffset &&\n      anchorNode.parentNode.classList.contains('ag-image-container') &&\n      anchorNode.previousElementSibling &&\n      anchorNode.previousElementSibling.nodeName === 'IMG'\n    ) {\n      const imageWrapper = anchorNode.parentNode.parentNode\n      const preElement = imageWrapper.previousElementSibling\n      aOffset = 0\n      if (preElement) {\n        aOffset += getOffsetOfParagraph(preElement, anchorParagraph)\n        aOffset += getTextContent(preElement, [CLASS_OR_ID.AG_MATH_RENDER, CLASS_OR_ID.AG_RUBY_RENDER]).length\n      }\n      aOffset += getTextContent(imageWrapper, [CLASS_OR_ID.AG_MATH_RENDER, CLASS_OR_ID.AG_RUBY_RENDER]).length\n      fOffset = aOffset\n    }\n\n    if (\n      anchorNode === focusNode &&\n      anchorNode.nodeType === 1 &&\n      anchorNode.classList.contains('ag-image-container')\n    ) {\n      const imageWrapper = anchorNode.parentNode\n      const preElement = imageWrapper.previousElementSibling\n      aOffset = 0\n      if (preElement) {\n        aOffset += getOffsetOfParagraph(preElement, anchorParagraph)\n        aOffset += getTextContent(preElement, [CLASS_OR_ID.AG_MATH_RENDER, CLASS_OR_ID.AG_RUBY_RENDER]).length\n      }\n      if (anchorOffset === 1) {\n        aOffset += getTextContent(imageWrapper, [CLASS_OR_ID.AG_MATH_RENDER, CLASS_OR_ID.AG_RUBY_RENDER]).length\n      }\n      fOffset = aOffset\n    }\n\n    const anchor = { key: anchorParagraph.id, offset: aOffset }\n\n    const focus = { key: focusParagraph.id, offset: fOffset }\n    const result = new Cursor({ anchor, focus })\n\n    if (needFix) {\n      this.setCursorRange(result)\n    }\n\n    return result\n  }\n\n  // topOffset is the line counts above cursor, and bottomOffset is line counts bellow cursor.\n  getCursorYOffset (paragraph) {\n    const { y } = this.getCursorCoords()\n    const { height, top } = paragraph.getBoundingClientRect()\n    const lineHeight = parseFloat(getComputedStyle(paragraph).lineHeight)\n    const topOffset = Math.round((y - top) / lineHeight)\n    const bottomOffset = Math.round((top + height - lineHeight - y) / lineHeight)\n\n    return {\n      topOffset,\n      bottomOffset\n    }\n  }\n\n  getCursorCoords () {\n    const sel = this.doc.getSelection()\n    let range\n    let x = 0\n    let y = 0\n    let width = 0\n\n    if (sel.rangeCount) {\n      range = sel.getRangeAt(0).cloneRange()\n      if (range.getClientRects) {\n        // range.collapse(true)\n        let rects = range.getClientRects()\n        if (rects.length === 0 && range.startContainer && (range.startContainer.nodeType === Node.ELEMENT_NODE || range.startContainer.nodeType === Node.TEXT_NODE)) {\n          rects = range.startContainer.parentElement.getClientRects()\n          // prevent tiny vibrations\n          if (rects.length) {\n            const rect = rects[0]\n            rect.y = rect.y + 1\n          }\n        }\n        if (rects.length) {\n          const { left, top, x: rectX, y: rectY, width: rWidth } = rects[0]\n          x = rectX || left\n          y = rectY || top\n          width = rWidth\n        }\n      }\n    }\n\n    return { x, y, width }\n  }\n\n  getSelectionEnd () {\n    const node = this.doc.getSelection().focusNode\n    const endNode = (node && node.nodeType === 3 ? node.parentNode : node)\n\n    return endNode\n  }\n}\n\nexport default new Selection(document)\n","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/escapeCharacter.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/selection/cursor.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/contentState/footnoteCtrl.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/utils/importMarkdown.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/contentState/dragDropCtrl.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/contentState/linkCtrl.js",["1108"],"const linkCtrl = ContentState => {\n  /**\n   * Change a link into text.\n   */\n  ContentState.prototype.unlink = function (linkInfo) {\n    const { key, token } = linkInfo\n    const block = this.getBlock(key)\n    const { text } = block\n    let anchor\n    switch (token.type) {\n      case 'html_tag':\n        anchor = token.content\n        break\n      case 'link':\n        anchor = token.href\n        break\n      case 'text': {\n        const match = /^\\[(.+?)\\]/.exec(token.raw)\n        if (match && match[1]) {\n          anchor = match[1]\n        }\n        break\n      }\n    }\n    if (!anchor) {\n      console.error('Can not find anchor when unlink')\n      return\n    }\n    block.text = text.substring(0, token.range.start) + anchor + text.substring(token.range.end)\n    this.cursor = {\n      start: {\n        key,\n        offset: token.range.start\n      },\n      end: {\n        key,\n        offset: +token.range.start + anchor.length\n      }\n    }\n\n    this.singleRender(block)\n    return this.muya.dispatchChange()\n  }\n}\n\nexport default linkCtrl\n","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/contentState/imageCtrl.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/contentState/tocCtrl.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/contentState/emojiCtrl.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/contentState/inputCtrl.js",["1109","1110"],"import selection from '../selection'\nimport { getTextContent } from '../selection/dom'\nimport { beginRules } from '../parser/rules'\nimport { tokenizer } from '../parser/'\nimport { CLASS_OR_ID } from '../config'\n\nconst BRACKET_HASH = {\n  '{': '}',\n  '[': ']',\n  '(': ')',\n  '*': '*',\n  _: '_',\n  '\"': '\"',\n  '\\'': '\\'',\n  $: '$',\n  '~': '~'\n}\n\nconst BACK_HASH = {\n  '}': '{',\n  ']': '[',\n  ')': '(',\n  '*': '*',\n  _: '_',\n  '\"': '\"',\n  '\\'': '\\'',\n  $: '$',\n  '~': '~'\n}\n\n// TODO: refactor later.\nlet renderCodeBlockTimer = null\n\nconst inputCtrl = ContentState => {\n  // Input @ to quick insert paragraph\n  ContentState.prototype.checkQuickInsert = function (block) {\n    const { type, text, functionType } = block\n    if (type !== 'span' || functionType !== 'paragraphContent') return false\n    return /^@\\S*$/.test(text)\n  }\n\n  ContentState.prototype.checkCursorInTokenType = function (functionType, text, offset, type) {\n    if (!/atxLine|paragraphContent|cellContent/.test(functionType)) {\n      return false\n    }\n\n    const tokens = tokenizer(text, {\n      hasBeginRules: false,\n      options: this.muya.options\n    })\n    return tokens.filter(t => t.type === type).some(t => offset >= t.range.start && offset <= t.range.end)\n  }\n\n  ContentState.prototype.checkNotSameToken = function (functionType, oldText, text) {\n    if (!/atxLine|paragraphContent|cellContent/.test(functionType)) {\n      return false\n    }\n\n    const oldTokens = tokenizer(oldText, {\n      options: this.muya.options\n    })\n    const tokens = tokenizer(text, {\n      options: this.muya.options\n    })\n\n    const oldCache = {}\n    const cache = {}\n\n    for (const { type } of oldTokens) {\n      if (oldCache[type]) {\n        oldCache[type]++\n      } else {\n        oldCache[type] = 1\n      }\n    }\n\n    for (const { type } of tokens) {\n      if (cache[type]) {\n        cache[type]++\n      } else {\n        cache[type] = 1\n      }\n    }\n\n    if (Object.keys(oldCache).length !== Object.keys(cache).length) {\n      return true\n    }\n\n    for (const key of Object.keys(oldCache)) {\n      if (!cache[key] || oldCache[key] !== cache[key]) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  ContentState.prototype.inputHandler = function (event, notEqual = false) {\n    const { start, end } = selection.getCursorRange()\n    if (!start || !end) {\n      return\n    }\n    const { start: oldStart, end: oldEnd } = this.cursor\n    const key = start.key\n    const block = this.getBlock(key)\n    const paragraph = document.querySelector(`#${key}`)\n\n    // Fix issue 1447\n    // Fixme: any better solution?\n    if (\n      oldStart.key === oldEnd.key &&\n      oldStart.offset === oldEnd.offset &&\n      block.text.endsWith('\\n') &&\n      oldStart.offset === block.text.length &&\n      event.inputType === 'insertText'\n    ) {\n      event.preventDefault()\n      block.text += event.data\n      const offset = block.text.length\n      this.cursor = {\n        start: { key, offset },\n        end: { key, offset }\n      }\n      this.singleRender(block)\n      return this.inputHandler(event, true)\n    }\n\n    let text = getTextContent(paragraph, [CLASS_OR_ID.AG_MATH_RENDER, CLASS_OR_ID.AG_RUBY_RENDER])\n\n    let needRender = false\n    let needRenderAll = false\n    if (oldStart.key !== oldEnd.key) {\n      const startBlock = this.getBlock(oldStart.key)\n      const startOutmostBlock = this.findOutMostBlock(startBlock)\n      const endBlock = this.getBlock(oldEnd.key)\n      const endOutmostBlock = this.findOutMostBlock(endBlock)\n      if (\n        // fix #918.\n        startBlock.functionType === 'languageInput'\n      ) {\n        if (startOutmostBlock === endOutmostBlock && !endBlock.nextSibling) {\n          this.removeBlocks(startBlock, endBlock, false)\n          endBlock.text = ''\n        } else if (startOutmostBlock !== endOutmostBlock) {\n          const preBlock = this.getParent(startBlock)\n          const pBlock = this.createBlock('p')\n          this.removeBlocks(startBlock, endBlock)\n          startBlock.functionType = 'paragraphContent'\n          this.appendChild(pBlock, startBlock)\n          this.insertBefore(pBlock, preBlock)\n          this.removeBlock(preBlock)\n        } else {\n          this.removeBlocks(startBlock, endBlock)\n        }\n      } else {\n        this.removeBlocks(startBlock, endBlock)\n      }\n      if (this.blocks.length === 1) {\n        needRenderAll = true\n      }\n      needRender = true\n    }\n\n    // auto pair (not need to auto pair in math block)\n    if (block && (block.text !== text || notEqual)) {\n      if (\n        start.key === end.key &&\n        start.offset === end.offset &&\n        event.type === 'input'\n      ) {\n        const { offset } = start\n        const { autoPairBracket, autoPairMarkdownSyntax, autoPairQuote } = this.muya.options\n        const inputChar = text.charAt(+offset - 1)\n        const preInputChar = text.charAt(+offset - 2)\n        const prePreInputChar = text.charAt(+offset - 3)\n        const postInputChar = text.charAt(+offset)\n\n        if (/^delete/.test(event.inputType)) {\n          // handle `deleteContentBackward` or `deleteContentForward`\n          const deletedChar = block.text[offset]\n          if (event.inputType === 'deleteContentBackward' && postInputChar === BRACKET_HASH[deletedChar]) {\n            needRender = true\n            text = text.substring(0, offset) + text.substring(offset + 1)\n          }\n          if (event.inputType === 'deleteContentForward' && inputChar === BACK_HASH[deletedChar]) {\n            needRender = true\n            start.offset -= 1\n            end.offset -= 1\n            text = text.substring(0, offset - 1) + text.substring(offset)\n          }\n          /* eslint-disable no-useless-escape */\n        } else if (\n          (event.inputType.indexOf('delete') === -1) &&\n          (inputChar === postInputChar) &&\n          (\n            (autoPairQuote && /[']{1}/.test(inputChar)) ||\n            (autoPairQuote && /[\"]{1}/.test(inputChar)) ||\n            (autoPairBracket && /[\\}\\]\\)]{1}/.test(inputChar)) ||\n            (autoPairMarkdownSyntax && /[$]{1}/.test(inputChar)) ||\n            (autoPairMarkdownSyntax && /[*$`~_]{1}/.test(inputChar)) && /[_*~]{1}/.test(prePreInputChar)\n          )\n        ) {\n          needRender = true\n          text = text.substring(0, offset) + text.substring(offset + 1)\n        } else {\n          /* eslint-disable no-useless-escape */\n          // Not Unicode aware, since things like \\p{Alphabetic} or \\p{L} are not supported yet\n          const isInInlineMath = this.checkCursorInTokenType(block.functionType, text, offset, 'inline_math')\n          const isInInlineCode = this.checkCursorInTokenType(block.functionType, text, offset, 'inline_code')\n          if (\n            !/\\\\/.test(preInputChar) &&\n            ((autoPairQuote && /[']{1}/.test(inputChar) && !(/[a-zA-Z\\d]{1}/.test(preInputChar))) ||\n            (autoPairQuote && /[\"]{1}/.test(inputChar)) ||\n            (autoPairBracket && /[\\{\\[\\(]{1}/.test(inputChar)) ||\n            (block.functionType !== 'codeContent' && !isInInlineMath && !isInInlineCode && autoPairMarkdownSyntax && /[*$`~_]{1}/.test(inputChar)))\n          ) {\n            needRender = true\n            text = BRACKET_HASH[event.data]\n              ? text.substring(0, offset) + BRACKET_HASH[inputChar] + text.substring(offset)\n              : text\n          }\n          /* eslint-enable no-useless-escape */\n          // Delete the last `*` of `**` when you insert one space between `**` to create a bullet list.\n          if (\n            /\\s/.test(event.data) &&\n            /^\\* /.test(text) &&\n            preInputChar === '*' &&\n            postInputChar === '*'\n          ) {\n            text = text.substring(0, offset) + text.substring(offset + 1)\n            needRender = true\n          }\n        }\n      }\n\n      if (this.checkNotSameToken(block.functionType, block.text, text)) {\n        needRender = true\n      }\n      // Just work for `Shift + Enter` to create a soft and hard line break.\n      if (\n        block.text.endsWith('\\n') &&\n        start.offset === text.length &&\n        (event.inputType === 'insertText' || event.type === 'compositionend')\n      ) {\n        block.text += event.data\n        start.offset++\n        end.offset++\n      } else if (\n        block.text.length === oldStart.offset &&\n        block.text[oldStart.offset - 2] === '\\n' &&\n        event.inputType === 'deleteContentBackward'\n      ) {\n        block.text = block.text.substring(0, oldStart.offset - 1)\n        start.offset = block.text.length\n        end.offset = block.text.length\n      } else {\n        block.text = text\n      }\n\n      // Update code block language when modify code block identifer\n      if (block.functionType === 'languageInput') {\n        const parent = this.getParent(block)\n        parent.lang = block.text\n      }\n\n      if (beginRules.reference_definition.test(text)) {\n        needRenderAll = true\n      }\n    }\n\n    // show quick insert\n    const rect = paragraph.getBoundingClientRect()\n    const checkQuickInsert = this.checkQuickInsert(block)\n    const reference = this.getPositionReference()\n    reference.getBoundingClientRect = function () {\n      const { x, y, left, top, height, bottom } = rect\n\n      return Object.assign({}, {\n        left,\n        x,\n        top,\n        y,\n        bottom,\n        height,\n        width: 0,\n        right: left\n      })\n    }\n\n    this.muya.eventCenter.dispatch('muya-quick-insert', reference, block, !!checkQuickInsert)\n\n    this.cursor = { start, end }\n\n    // Throttle render if edit in code block.\n    if (block && block.type === 'span' && block.functionType === 'codeContent') {\n      if (renderCodeBlockTimer) {\n        clearTimeout(renderCodeBlockTimer)\n      }\n      if (needRender) {\n        this.partialRender()\n      } else {\n        renderCodeBlockTimer = setTimeout(() => {\n          this.partialRender()\n        }, 300)\n      }\n      return\n    }\n\n    const checkMarkedUpdate = /atxLine|paragraphContent|cellContent/.test(block.functionType) ? this.checkNeedRender() : false\n    let inlineUpdatedBlock = null\n    if (/atxLine|paragraphContent|cellContent|thematicBreakLine/.test(block.functionType)) {\n      inlineUpdatedBlock = this.isCollapse() && this.checkInlineUpdate(block)\n    }\n\n    // just for fix #707,need render All if in combines pre list and next list into one list.\n    if (inlineUpdatedBlock) {\n      const liBlock = this.getParent(inlineUpdatedBlock)\n      if (liBlock && liBlock.type === 'li' && liBlock.preSibling && liBlock.nextSibling) {\n        needRenderAll = true\n      }\n    }\n\n    if (checkMarkedUpdate || inlineUpdatedBlock || needRender) {\n      return needRenderAll ? this.render() : this.partialRender()\n    }\n  }\n}\n\nexport default inputCtrl\n","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/contentState/clickCtrl.js",["1111"],"import selection from '../selection'\nimport { isMuyaEditorElement } from '../selection/dom'\nimport { HAS_TEXT_BLOCK_REG, CLASS_OR_ID } from '../config'\nimport { getParentCheckBox } from '../utils/getParentCheckBox'\nimport { cumputeCheckboxStatus } from '../utils/cumputeCheckBoxStatus'\n\nconst clickCtrl = ContentState => {\n  ContentState.prototype.clickHandler = function (event) {\n    const { eventCenter } = this.muya\n    const { target } = event\n    if (isMuyaEditorElement(target)) {\n      const lastBlock = this.getLastBlock()\n      const archor = this.findOutMostBlock(lastBlock)\n      const archorParagraph = document.querySelector(`#${archor.key}`)\n      const rect = archorParagraph.getBoundingClientRect()\n      // If click below the last paragraph\n      // and the last paragraph is not empty, create a new empty paragraph\n      if (event.clientY > rect.top + rect.height) {\n        let needToInsertNewParagraph = false\n        if (lastBlock.type === 'span') {\n          if (/atxLine|paragraphContent/.test(lastBlock.functionType) && /\\S/.test(lastBlock.text)) {\n            needToInsertNewParagraph = true\n          }\n          if (!/atxLine|paragraphContent/.test(lastBlock.functionType)) {\n            needToInsertNewParagraph = true\n          }\n        } else {\n          needToInsertNewParagraph = true\n        }\n\n        if (needToInsertNewParagraph) {\n          event.preventDefault()\n          const paragraphBlock = this.createBlockP()\n          this.insertAfter(paragraphBlock, archor)\n          const key = paragraphBlock.children[0].key\n          const offset = 0\n          this.cursor = {\n            start: { key, offset },\n            end: { key, offset }\n          }\n\n          return this.render()\n        }\n      }\n    }\n    // handle front menu click\n    const { start: oldStart, end: oldEnd } = this.cursor\n    if (oldStart && oldEnd) {\n      let hasSameParent = false\n      const startBlock = this.getBlock(oldStart.key)\n      const endBlock = this.getBlock(oldEnd.key)\n      if (startBlock && endBlock) {\n        const startOutBlock = this.findOutMostBlock(startBlock)\n        const endOutBlock = this.findOutMostBlock(endBlock)\n        hasSameParent = startOutBlock === endOutBlock\n      }\n      // show the muya-front-menu only when the cursor in the same paragraph\n      if (target.closest('.ag-front-icon') && hasSameParent) {\n        const currentBlock = this.findOutMostBlock(startBlock)\n        const frontIcon = target.closest('.ag-front-icon')\n        const rect = frontIcon.getBoundingClientRect()\n        const reference = {\n          getBoundingClientRect () {\n            return rect\n          },\n          clientWidth: rect.width,\n          clientHeight: rect.height,\n          id: currentBlock.key\n        }\n        this.selectedBlock = currentBlock\n        eventCenter.dispatch('muya-front-menu', { reference, outmostBlock: currentBlock, startBlock, endBlock })\n        return this.partialRender()\n      }\n    }\n    const { start, end } = selection.getCursorRange()\n    // fix #625, the selection maybe not in edit area.\n    if (!start || !end) {\n      return\n    }\n    // format-click\n    const node = selection.getSelectionStart()\n    const inlineNode = node ? node.closest('.ag-inline-rule') : null\n\n    // link-format-click\n    let parentNode = inlineNode\n    while (parentNode !== null && parentNode.classList.contains(CLASS_OR_ID.AG_INLINE_RULE)) {\n      if (parentNode.tagName === 'A') {\n        const formatType = 'link' // auto link or []() link\n        const data = {\n          text: inlineNode.textContent,\n          href: parentNode.getAttribute('href')\n        }\n        eventCenter.dispatch('format-click', {\n          event,\n          formatType,\n          data\n        })\n        break\n      } else {\n        parentNode = parentNode.parentNode\n      }\n    }\n\n    if (inlineNode) {\n      let formatType = null\n      let data = null\n      switch (inlineNode.tagName) {\n        case 'SPAN': {\n          if (inlineNode.hasAttribute('data-emoji')) {\n            formatType = 'emoji'\n            data = inlineNode.getAttribute('data-emoji')\n          } else if (inlineNode.classList.contains('ag-math-text')) {\n            formatType = 'inline_math'\n            data = inlineNode.textContent\n          }\n          break\n        }\n        case 'STRONG': {\n          formatType = 'strong'\n          data = inlineNode.textContent\n          break\n        }\n        case 'EM': {\n          formatType = 'em'\n          data = inlineNode.textContent\n          break\n        }\n        case 'DEL': {\n          formatType = 'del'\n          data = inlineNode.textContent\n          break\n        }\n        case 'CODE': {\n          formatType = 'inline_code'\n          data = inlineNode.textContent\n          break\n        }\n      }\n      if (formatType) {\n        eventCenter.dispatch('format-click', {\n          event,\n          formatType,\n          data\n        })\n      }\n    }\n    const block = this.getBlock(start.key)\n    let needRender = false\n    // is show format float box?\n    if (\n      start.key === end.key &&\n      start.offset !== end.offset &&\n      HAS_TEXT_BLOCK_REG.test(block.type) &&\n      block.functionType !== 'codeContent' &&\n      block.functionType !== 'languageInput'\n    ) {\n      const reference = this.getPositionReference()\n      const { formats } = this.selectionFormats()\n      eventCenter.dispatch('muya-format-picker', { reference, formats })\n    }\n\n    // update '```xxx' to code block when you click other place or use press arrow key.\n    if (block && start.key !== this.cursor.start.key) {\n      const oldBlock = this.getBlock(this.cursor.start.key)\n      if (oldBlock) {\n        needRender = needRender || this.codeBlockUpdate(oldBlock)\n      }\n    }\n\n    // change active status when paragraph changed\n    if (\n      start.key !== this.cursor.start.key ||\n      end.key !== this.cursor.end.key\n    ) {\n      needRender = true\n    }\n\n    const needMarkedUpdate = this.checkNeedRender(this.cursor) || this.checkNeedRender({ start, end })\n\n    if (needRender) {\n      this.cursor = { start, end }\n      return this.partialRender()\n    } else if (needMarkedUpdate) {\n      // Fix: whole select can not be canceled #613\n      requestAnimationFrame(() => {\n        const cursor = selection.getCursorRange()\n        if (!cursor.start || !cursor.end) {\n          return\n        }\n        this.cursor = cursor\n\n        return this.partialRender()\n      })\n    } else {\n      this.cursor = { start, end }\n    }\n  }\n\n  ContentState.prototype.setCheckBoxState = function (checkbox, checked) {\n    checkbox.checked = checked\n    const block = this.getBlock(checkbox.id)\n    block.checked = checked\n    checkbox.classList.toggle(CLASS_OR_ID.AG_CHECKBOX_CHECKED)\n  }\n\n  ContentState.prototype.updateParentsCheckBoxState = function (checkbox) {\n    let parent = getParentCheckBox(checkbox)\n    while (parent !== null) {\n      const checked = cumputeCheckboxStatus(parent)\n      if (parent.checked !== checked) {\n        this.setCheckBoxState(parent, checked)\n        parent = getParentCheckBox(parent)\n      } else {\n        break\n      }\n    }\n  }\n\n  ContentState.prototype.updateChildrenCheckBoxState = function (checkbox, checked) {\n    const checkboxes = checkbox.parentElement.querySelectorAll(`input ~ ul .${CLASS_OR_ID.AG_TASK_LIST_ITEM_CHECKBOX}`)\n    const len = checkboxes.length\n    for (let i = 0; i < len; i++) {\n      const checkbox = checkboxes[i]\n      if (checkbox.checked !== checked) {\n        this.setCheckBoxState(checkbox, checked)\n      }\n    }\n  }\n\n  // handle task list item checkbox click\n  ContentState.prototype.listItemCheckBoxClick = function (checkbox) {\n    const { checked } = checkbox\n    this.setCheckBoxState(checkbox, checked)\n\n    // A task checked, then related task should be update\n    const { autoCheck } = this.muya.options\n    if (autoCheck) {\n      this.updateChildrenCheckBoxState(checkbox, checked)\n      this.updateParentsCheckBoxState(checkbox)\n    }\n\n    const block = this.getBlock(checkbox.id)\n    const parentBlock = this.getParent(block)\n    const firstEditableBlock = this.firstInDescendant(parentBlock)\n    const { key } = firstEditableBlock\n    const offset = 0\n    this.cursor = { start: { key, offset }, end: { key, offset } }\n    return this.partialRender()\n  }\n}\n\nexport default clickCtrl\n","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/contentState/htmlBlock.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/renderers/index.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/contentState/containerCtrl.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/contentState/searchCtrl.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/contentState/formatCtrl.js",["1112","1113","1114","1115","1116","1117","1118","1119","1120"],"import selection from '../selection'\nimport { tokenizer, generator } from '../parser/'\nimport { FORMAT_MARKER_MAP, FORMAT_TYPES } from '../config'\nimport { getImageInfo } from '../utils/getImageInfo'\n\nconst getOffset = (offset, { range: { start, end }, type, tag, anchor, alt }) => {\n  const dis = offset - start\n  const len = end - start\n  switch (type) {\n    case 'strong':\n    case 'del':\n    case 'em':\n    case 'inline_code':\n    case 'inline_math': {\n      const MARKER_LEN = (type === 'strong' || type === 'del') ? 2 : 1\n      if (dis < 0) return 0\n      if (dis >= 0 && dis < MARKER_LEN) return -dis\n      if (dis >= MARKER_LEN && dis <= len - MARKER_LEN) return -MARKER_LEN\n      if (dis > len - MARKER_LEN && dis <= len) return len - dis - 2 * MARKER_LEN\n      if (dis > len) return -2 * MARKER_LEN\n      break\n    }\n    case 'html_tag': { // handle underline, sup, sub\n      const OPEN_MARKER_LEN = FORMAT_MARKER_MAP[tag].open.length\n      const CLOSE_MARKER_LEN = FORMAT_MARKER_MAP[tag].close.length\n      if (dis < 0) return 0\n      if (dis >= 0 && dis < OPEN_MARKER_LEN) return -dis\n      if (dis >= OPEN_MARKER_LEN && dis <= len - CLOSE_MARKER_LEN) return -OPEN_MARKER_LEN\n      if (dis > len - CLOSE_MARKER_LEN && dis <= len) return len - dis - OPEN_MARKER_LEN - CLOSE_MARKER_LEN\n      if (dis > len) return -OPEN_MARKER_LEN - CLOSE_MARKER_LEN\n      break\n    }\n    case 'link': {\n      const MARKER_LEN = 1\n      if (dis < MARKER_LEN) return 0\n      if (dis >= MARKER_LEN && dis <= MARKER_LEN + anchor.length) return -1\n      if (dis > MARKER_LEN + anchor.length) return anchor.length - dis\n      break\n    }\n    case 'image': {\n      const MARKER_LEN = 1\n      if (dis < MARKER_LEN) return 0\n      if (dis >= MARKER_LEN && dis < MARKER_LEN * 2) return -1\n      if (dis >= MARKER_LEN * 2 && dis <= MARKER_LEN * 2 + alt.length) return -2\n      if (dis > MARKER_LEN * 2 + alt.length) return alt.length - dis\n      break\n    }\n  }\n}\n\nconst clearFormat = (token, { start, end }) => {\n  if (start) {\n    const deltaStart = getOffset(start.offset, token)\n    start.delata += deltaStart\n  }\n  if (end) {\n    const delataEnd = getOffset(end.offset, token)\n    end.delata += delataEnd\n  }\n  switch (token.type) {\n    case 'strong':\n    case 'del':\n    case 'em':\n    case 'link':\n    case 'html_tag': { // underline, sub, sup\n      const { parent } = token\n      const index = parent.indexOf(token)\n      parent.splice(index, 1, ...token.children)\n      break\n    }\n    case 'image': {\n      token.type = 'text'\n      token.raw = token.alt\n      delete token.marker\n      delete token.src\n      break\n    }\n    case 'inline_math':\n    case 'inline_code': {\n      token.type = 'text'\n      token.raw = token.content\n      delete token.marker\n      break\n    }\n  }\n}\n\nconst addFormat = (type, block, { start, end }) => {\n  if (\n    block.type !== 'span' ||\n    (block.type === 'span' && !/paragraphContent|cellContent|atxLine/.test(block.functionType))\n  ) {\n    return false\n  }\n  switch (type) {\n    case 'em':\n    case 'del':\n    case 'inline_code':\n    case 'strong':\n    case 'inline_math': {\n      const MARKER = FORMAT_MARKER_MAP[type]\n      const oldText = block.text\n      block.text = oldText.substring(0, start.offset) +\n        MARKER + oldText.substring(start.offset, end.offset) +\n        MARKER + oldText.substring(end.offset)\n      start.offset += MARKER.length\n      end.offset += MARKER.length\n      break\n    }\n    case 'sub':\n    case 'sup':\n    case 'mark':\n    case 'u': {\n      const MARKER = FORMAT_MARKER_MAP[type]\n      const oldText = block.text\n      block.text = oldText.substring(0, start.offset) +\n        MARKER.open + oldText.substring(start.offset, end.offset) +\n        MARKER.close + oldText.substring(end.offset)\n      start.offset += MARKER.open.length\n      end.offset += MARKER.open.length\n      break\n    }\n    case 'link':\n    case 'image': {\n      const oldText = block.text\n      const anchorTextLen = end.offset - start.offset\n      block.text = oldText.substring(0, start.offset) +\n        (type === 'link' ? '[' : '![') +\n        oldText.substring(start.offset, end.offset) + ']()' +\n        oldText.substring(end.offset)\n      // put cursor between `()`\n      start.offset += type === 'link' ? 3 + anchorTextLen : 4 + anchorTextLen\n      end.offset = start.offset\n      break\n    }\n  }\n}\n\nconst checkTokenIsInlineFormat = token => {\n  const { type, tag } = token\n  if (FORMAT_TYPES.includes(type)) return true\n  if (type === 'html_tag' && /^(?:u|sub|sup|mark)$/i.test(tag)) return true\n  return false\n}\n\nconst formatCtrl = ContentState => {\n  ContentState.prototype.selectionFormats = function ({ start, end } = selection.getCursorRange()) {\n    if (!start || !end) {\n      return { formats: [], tokens: [], neighbors: [] }\n    }\n\n    const startBlock = this.getBlock(start.key)\n    const formats = []\n    const neighbors = []\n    let tokens = []\n    if (start.key === end.key) {\n      const { text } = startBlock\n      tokens = tokenizer(text, {\n        options: this.muya.options\n      })\n      ;(function iterator (tks) {\n        for (const token of tks) {\n          if (\n            checkTokenIsInlineFormat(token) &&\n            start.offset >= token.range.start &&\n            end.offset <= token.range.end\n          ) {\n            formats.push(token)\n          }\n          if (\n            checkTokenIsInlineFormat(token) &&\n            ((start.offset >= token.range.start && start.offset <= token.range.end) ||\n            (end.offset >= token.range.start && end.offset <= token.range.end) ||\n            (start.offset <= token.range.start && token.range.end <= end.offset))\n          ) {\n            neighbors.push(token)\n          }\n          if (token.children && token.children.length) {\n            iterator(token.children)\n          }\n        }\n      })(tokens)\n    }\n\n    return { formats, tokens, neighbors }\n  }\n\n  ContentState.prototype.clearBlockFormat = function (block, { start, end } = selection.getCursorRange(), type) {\n    if (!start || !end) {\n      return\n    }\n    if (block.type === 'pre') return false\n    const { key } = block\n    let tokens\n    let neighbors\n    if (start.key === end.key && start.key === key) {\n      ({ tokens, neighbors } = this.selectionFormats({ start, end }))\n    } else if (start.key !== end.key && start.key === key) {\n      ({ tokens, neighbors } = this.selectionFormats({ start, end: { key: start.key, offset: block.text.length } }))\n    } else if (start.key !== end.key && end.key === key) {\n      ({ tokens, neighbors } = this.selectionFormats({\n        start: {\n          key: end.key,\n          offset: 0\n        },\n        end\n      }))\n    } else {\n      ({ tokens, neighbors } = this.selectionFormats({\n        start: {\n          key,\n          offset: 0\n        },\n        end: {\n          key,\n          offset: block.text.length\n        }\n      }))\n    }\n\n    neighbors = type ? neighbors.filter(n => {\n      return n.type === type ||\n      n.type === 'html_tag' && n.tag === type\n    }) : neighbors\n\n    for (const neighbor of neighbors) {\n      clearFormat(neighbor, { start, end })\n    }\n    start.offset += start.delata\n    end.offset += end.delata\n    block.text = generator(tokens)\n  }\n\n  ContentState.prototype.format = function (type) {\n    const { start, end } = selection.getCursorRange()\n    if (!start || !end) {\n      return\n    }\n\n    const startBlock = this.getBlock(start.key)\n    const endBlock = this.getBlock(end.key)\n    start.delata = end.delata = 0\n    if (start.key === end.key) {\n      const { formats, tokens, neighbors } = this.selectionFormats()\n      const currentFormats = formats.filter(format => {\n        return format.type === type ||\n          format.type === 'html_tag' && format.tag === type\n      }).reverse()\n      const currentNeightbors = neighbors.filter(format => {\n        return format.type === type ||\n        format.type === 'html_tag' && format.tag === type\n      }).reverse()\n      // cache delata\n      if (type === 'clear') {\n        for (const neighbor of neighbors) {\n          clearFormat(neighbor, { start, end })\n        }\n        start.offset += start.delata\n        end.offset += end.delata\n        startBlock.text = generator(tokens)\n      } else if (currentFormats.length) {\n        for (const token of currentFormats) {\n          clearFormat(token, { start, end })\n        }\n        start.offset += start.delata\n        end.offset += end.delata\n        startBlock.text = generator(tokens)\n      } else {\n        if (currentNeightbors.length) {\n          for (const neighbor of currentNeightbors) {\n            clearFormat(neighbor, { start, end })\n          }\n        }\n        start.offset += start.delata\n        end.offset += end.delata\n        startBlock.text = generator(tokens)\n        addFormat(type, startBlock, { start, end })\n        if (type === 'image') {\n          // Show image selector when create a inline image by menu/shortcut/or just input `![]()`\n          requestAnimationFrame(() => {\n            const startNode = selection.getSelectionStart()\n            if (startNode) {\n              const imageWrapper = startNode.closest('.ag-inline-image')\n              if (imageWrapper && imageWrapper.classList.contains('ag-empty-image')) {\n                const imageInfo = getImageInfo(imageWrapper)\n                this.muya.eventCenter.dispatch('muya-image-selector', {\n                  reference: imageWrapper,\n                  imageInfo,\n                  cb: () => {}\n                })\n              }\n            }\n          })\n        }\n      }\n      this.cursor = { start, end }\n      this.partialRender()\n    } else {\n      let nextBlock = startBlock\n      const formatType = type !== 'clear' ? type : undefined\n      while (nextBlock && nextBlock !== endBlock) {\n        this.clearBlockFormat(nextBlock, { start, end }, formatType)\n        nextBlock = this.findNextBlockInLocation(nextBlock)\n      }\n      this.clearBlockFormat(endBlock, { start, end }, formatType)\n\n      if (type !== 'clear') {\n        addFormat(type, startBlock, {\n          start,\n          end: { offset: startBlock.text.length }\n        })\n        nextBlock = this.findNextBlockInLocation(startBlock)\n        while (nextBlock && nextBlock !== endBlock) {\n          addFormat(type, nextBlock, {\n            start: { offset: 0 },\n            end: { offset: nextBlock.text.length }\n          })\n          nextBlock = this.findNextBlockInLocation(nextBlock)\n        }\n        addFormat(type, endBlock, {\n          start: { offset: 0 },\n          end\n        })\n      }\n\n      this.cursor = { start, end }\n      this.partialRender()\n    }\n  }\n}\n\nexport default formatCtrl\n","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/marked/index.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/contentState/tabCtrl.js",["1121","1122","1123"],"import selection from '../selection'\nimport { HTML_TAGS, VOID_HTML_TAGS, HAS_TEXT_BLOCK_REG } from '../config'\nimport { tokenizer } from '../parser'\n\n/**\n * parseSelector\n * div#id.className => {tag: 'div', id: 'id', className: 'className', isVoid: false}\n */\n\nconst parseSelector = (str = '') => {\n  const REG_EXP = /(#|\\.)([^#.]+)/\n  let tag = ''\n  let id = ''\n  let className = ''\n  let isVoid = false\n  let cap\n  for (const tagName of HTML_TAGS) {\n    if (str.startsWith(tagName) && (!str[tagName.length] || /#|\\./.test(str[tagName.length]))) {\n      tag = tagName\n      if (VOID_HTML_TAGS.indexOf(tagName) > -1) isVoid = true\n      str = str.substring(tagName.length)\n    }\n  }\n  if (tag !== '') {\n    cap = REG_EXP.exec(str)\n    while (cap && str.length) {\n      if (cap[1] === '#') {\n        id = cap[2]\n      } else {\n        className = cap[2]\n      }\n      str = str.substring(cap[0].length)\n      cap = REG_EXP.exec(str)\n    }\n  }\n  return { tag, id, className, isVoid }\n}\n\nconst BOTH_SIDES_FORMATS = ['strong', 'em', 'inline_code', 'image', 'link', 'reference_image', 'reference_link', 'emoji', 'del', 'html_tag', 'inline_math']\n\nconst tabCtrl = ContentState => {\n  ContentState.prototype.findNextCell = function (block) {\n    if (block.functionType !== 'cellContent') {\n      throw new Error('only th and td can have next cell')\n    }\n    const cellBlock = this.getParent(block)\n    const nextSibling = this.getBlock(cellBlock.nextSibling)\n    const rowBlock = this.getBlock(cellBlock.parent)\n    const tbOrTh = this.getBlock(rowBlock.parent)\n    if (nextSibling) {\n      return this.firstInDescendant(nextSibling)\n    } else {\n      if (rowBlock.nextSibling) {\n        const nextRow = this.getBlock(rowBlock.nextSibling)\n        return this.firstInDescendant(nextRow)\n      } else if (tbOrTh.type === 'thead') {\n        const tBody = this.getBlock(tbOrTh.nextSibling)\n        if (tBody && tBody.children.length) {\n          return this.firstInDescendant(tBody)\n        }\n      }\n    }\n\n    return false\n  }\n\n  ContentState.prototype.findPreviousCell = function (block) {\n    if (block.functionType !== 'cellContent') {\n      throw new Error('only th and td can have previous cell')\n    }\n    const cellBlock = this.getParent(block)\n    const previousSibling = this.getBlock(cellBlock.preSibling)\n    const rowBlock = this.getBlock(cellBlock.parent)\n    const tbOrTh = this.getBlock(rowBlock.parent)\n    if (previousSibling) {\n      return this.firstInDescendant(previousSibling)\n    } else {\n      if (rowBlock.preSibling) {\n        const previousRow = this.getBlock(rowBlock.preSibling)\n        return this.lastInDescendant(previousRow)\n      } else if (tbOrTh.type === 'tbody') {\n        const tHead = this.getBlock(tbOrTh.preSibling)\n        if (tHead && tHead.children.length) {\n          return this.lastInDescendant(tHead)\n        }\n      }\n    }\n    return block\n  }\n\n  ContentState.prototype.isUnindentableListItem = function (block) {\n    const parent = this.getParent(block)\n    const listItem = this.getParent(parent)\n    const list = this.getParent(listItem)\n    const listParent = this.getParent(list)\n    if (!this.isCollapse()) return false\n    if (listParent && listParent.type === 'li') {\n      return !list.preSibling ? 'REPLACEMENT' : 'INDENT'\n    }\n    return false\n  }\n\n  ContentState.prototype.isIndentableListItem = function () {\n    const { start, end } = this.cursor\n    const startBlock = this.getBlock(start.key)\n    const parent = this.getParent(startBlock)\n    if (parent.type !== 'p' || !parent.parent) {\n      return false\n    }\n\n    const listItem = this.getParent(parent)\n    if (listItem.type !== 'li' || start.key !== end.key || start.offset !== end.offset) {\n      return false\n    }\n\n    // Now we know it's a list item. Check whether we can indent the list item.\n    const list = this.getParent(listItem)\n    return list && /ol|ul/.test(list.type) && listItem.preSibling\n  }\n\n  ContentState.prototype.unindentListItem = function (block, type) {\n    const pBlock = this.getParent(block)\n    const listItem = this.getParent(pBlock)\n    const list = this.getParent(listItem)\n    const listParent = this.getParent(list)\n    if (type === 'REPLACEMENT') {\n      this.insertBefore(pBlock, list)\n      if (this.isOnlyChild(listItem)) {\n        this.removeBlock(list)\n      } else {\n        this.removeBlock(listItem)\n      }\n    } else if (type === 'INDENT') {\n      if (list.children.length === 1) {\n        this.removeBlock(list)\n      } else {\n        const newList = this.createBlock(list.type)\n        let target = this.getNextSibling(listItem)\n        while (target) {\n          this.appendChild(newList, target)\n          const temp = target\n          target = this.getNextSibling(target)\n          this.removeBlock(temp, list)\n        }\n\n        if (newList.children.length) this.appendChild(listItem, newList)\n        this.removeBlock(listItem, list)\n        if (!list.children.length) {\n          this.removeBlock(list)\n        }\n      }\n      this.insertAfter(listItem, listParent)\n      let target = this.getNextSibling(list)\n      while (target) {\n        this.appendChild(listItem, target)\n        this.removeBlock(target, listParent)\n        target = this.getNextSibling(target)\n      }\n    }\n\n    return this.partialRender()\n  }\n\n  ContentState.prototype.indentListItem = function () {\n    const { start } = this.cursor\n    const startBlock = this.getBlock(start.key)\n    const parent = this.getParent(startBlock)\n    const listItem = this.getParent(parent)\n    const list = this.getParent(listItem)\n    const prevListItem = this.getPreSibling(listItem)\n\n    this.removeBlock(listItem)\n\n    // Search for a list in previous block\n    let newList = this.getLastChild(prevListItem)\n    if (!newList || !/ol|ul/.test(newList.type)) {\n      newList = this.createBlock(list.type)\n      this.appendChild(prevListItem, newList)\n    }\n\n    // Update item type only if we insert into an existing list\n    if (newList.children.length !== 0) {\n      listItem.isLooseListItem = newList.children[0].isLooseListItem\n    }\n\n    this.appendChild(newList, listItem)\n    return this.partialRender()\n  }\n\n  ContentState.prototype.insertTab = function () {\n    const tabSize = this.tabSize\n    const tabCharacter = String.fromCharCode(160).repeat(tabSize)\n    const { start, end } = this.cursor\n    const startBlock = this.getBlock(start.key)\n    const endBlock = this.getBlock(end.key)\n    if (start.key === end.key && start.offset === end.offset) {\n      startBlock.text = startBlock.text.substring(0, start.offset) +\n        tabCharacter + endBlock.text.substring(end.offset)\n      const key = start.key\n      const offset = start.offset + tabCharacter.length\n      this.cursor = {\n        start: { key, offset },\n        end: { key, offset }\n      }\n      return this.partialRender()\n    }\n  }\n\n  ContentState.prototype.checkCursorAtEndFormat = function (text, offset) {\n    const { labels } = this.stateRender\n    const tokens = tokenizer(text, {\n      hasBeginRules: false,\n      labels,\n      options: this.muya.options\n    })\n    let result = null\n    const walkTokens = tkns => {\n      for (const token of tkns) {\n        const { marker, type, range, children, srcAndTitle, hrefAndTitle, backlash, closeTag, isFullLink, label } = token\n        const { start, end } = range\n        if (BOTH_SIDES_FORMATS.includes(type) && offset > start && offset < end) {\n          switch (type) {\n            case 'strong':\n            case 'em':\n            case 'inline_code':\n            case 'emoji':\n            case 'del':\n            case 'inline_math': {\n              if (marker && offset === end - marker.length) {\n                result = {\n                  offset: marker.length\n                }\n                return\n              }\n              break\n            }\n            case 'image':\n            case 'link': {\n              const linkTitleLen = (srcAndTitle || hrefAndTitle).length\n              const secondLashLen = backlash && backlash.second ? backlash.second.length : 0\n              if (offset === end - 3 - (linkTitleLen + secondLashLen)) {\n                result = {\n                  offset: 2\n                }\n                return\n              } else if (offset === end - 1) {\n                result = {\n                  offset: 1\n                }\n                return\n              }\n              break\n            }\n            case 'reference_image':\n            case 'reference_link': {\n              const labelLen = label ? label.length : 0\n              const secondLashLen = backlash && backlash.second ? backlash.second.length : 0\n              if (isFullLink) {\n                if (offset === end - 3 - labelLen - secondLashLen) {\n                  result = {\n                    offset: 2\n                  }\n                  return\n                } else if (offset === end - 1) {\n                  result = {\n                    offset: 1\n                  }\n                  return\n                }\n              } else if (offset === end - 1) {\n                result = {\n                  offset: 1\n                }\n                return\n              }\n              break\n            }\n            case 'html_tag': {\n              if (closeTag && offset === end - closeTag.length) {\n                result = {\n                  offset: closeTag.length\n                }\n                return\n              }\n              break\n            }\n            default:\n              break\n          }\n        }\n        if (children && children.length) {\n          walkTokens(children)\n        }\n      }\n    }\n    walkTokens(tokens)\n\n    return result\n  }\n\n  ContentState.prototype.tabHandler = function (event) {\n    // disable tab focus\n    event.preventDefault()\n\n    const { start, end } = selection.getCursorRange()\n    if (!start || !end) {\n      return\n    }\n    const startBlock = this.getBlock(start.key)\n    const endBlock = this.getBlock(end.key)\n\n    if (event.shiftKey && !startBlock.functionType === 'cellContent') {\n      const unindentType = this.isUnindentableListItem(startBlock)\n      if (unindentType) {\n        this.unindentListItem(startBlock, unindentType)\n      }\n      return\n    }\n\n    // Handle `tab` to jump to the end of format when the cursor is at the end of format content.\n    if (\n      start.key === end.key &&\n      start.offset === end.offset &&\n      HAS_TEXT_BLOCK_REG.test(startBlock.type) &&\n      startBlock.functionType !== 'codeContent' && // code content has no inline syntax\n      startBlock.functionType !== 'languageInput' // language input textarea has no inline syntax\n    ) {\n      const { text, key } = startBlock\n      const { offset } = start\n      const atEnd = this.checkCursorAtEndFormat(text, offset)\n      if (atEnd) {\n        this.cursor = {\n          start: { key, offset: offset + atEnd.offset },\n          end: { key, offset: offset + atEnd.offset }\n        }\n        return this.partialRender()\n      }\n    }\n\n    // Auto-complete of inline html tag and html block and `html` code block.\n    if (\n      start.key === end.key &&\n      start.offset === end.offset &&\n      startBlock.type === 'span' &&\n      (!startBlock.functionType || startBlock.functionType === 'codeContent' && /markup|html|xml|svg|mathml/.test(startBlock.lang))\n    ) {\n      const { text } = startBlock\n      const lastWordBeforeCursor = text.substring(0, start.offset).split(/\\s+/).pop()\n      const { tag, isVoid, id, className } = parseSelector(lastWordBeforeCursor)\n\n      if (tag) {\n        const preText = text.substring(0, start.offset - lastWordBeforeCursor.length)\n        const postText = text.substring(end.offset)\n        if (!tag) return\n        let html = `<${tag}`\n        const key = startBlock.key\n        let startOffset = 0\n        let endOffset = 0\n        switch (tag) {\n          case 'img':\n            html += ' alt=\"\" src=\"\"'\n            startOffset = endOffset = html.length - 1\n            break\n          case 'input':\n            html += ' type=\"text\"'\n            startOffset = html.length - 5\n            endOffset = html.length - 1\n            break\n          case 'a':\n            html += ' href=\"\"'\n            startOffset = endOffset = html.length - 1\n            break\n          case 'link':\n            html += ' rel=\"stylesheet\" href=\"\"'\n            startOffset = endOffset = html.length - 1\n            break\n        }\n        if (id) {\n          html += ` id=\"${id}\"`\n        }\n        if (className) {\n          html += ` class=\"${className}\"`\n        }\n        html += '>'\n        if (startOffset === 0 && endOffset === 0) {\n          startOffset = endOffset = html.length\n        }\n        if (!isVoid) {\n          html += `</${tag}>`\n        }\n        startBlock.text = preText + html + postText\n        this.cursor = {\n          start: { key, offset: startOffset + preText.length },\n          end: { key, offset: endOffset + preText.length }\n        }\n        return this.partialRender()\n      }\n    }\n\n    // Handle `tab` key in table cell.\n    let nextCell\n    if (start.key === end.key && startBlock.functionType === 'cellContent') {\n      nextCell = event.shiftKey\n        ? this.findPreviousCell(startBlock)\n        : this.findNextCell(startBlock)\n    } else if (endBlock.functionType === 'cellContent') {\n      nextCell = endBlock\n    }\n    if (nextCell) {\n      const { key } = nextCell\n\n      const offset = 0\n      this.cursor = {\n        start: { key, offset },\n        end: { key, offset }\n      }\n\n      const figure = this.closest(nextCell, 'figure')\n      return this.singleRender(figure)\n    }\n\n    if (this.isIndentableListItem()) {\n      return this.indentListItem()\n    }\n    return this.insertTab()\n  }\n}\n\nexport default tabCtrl\n","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/contentState/paragraphCtrl.js",["1124","1125","1126","1127"],"import selection from '../selection'\nimport { PARAGRAPH_TYPES, DEFAULT_TURNDOWN_CONFIG } from '../config'\nimport ExportMarkdown from '../utils/exportMarkdown'\n\n// get header level\n//  eg: h1 => 1\n//      h2 => 2\nconst getCurrentLevel = type => {\n  if (/\\d/.test(type)) {\n    return Number(/\\d/.exec(type)[0])\n  } else {\n    return 0\n  }\n}\n\nconst paragraphCtrl = ContentState => {\n  ContentState.prototype.selectionChange = function (cursor) {\n    const { start, end } = cursor || selection.getCursorRange()\n    if (!start || !end) {\n      // TODO: Throw an exception and try to fix this later (GH#848).\n      throw new Error('selectionChange: expected cursor but cursor is null.')\n    }\n    const cursorCoords = selection.getCursorCoords()\n    const startBlock = this.getBlock(start.key)\n    const endBlock = this.getBlock(end.key)\n    const startParents = this.getParents(startBlock)\n    const endParents = this.getParents(endBlock)\n    const affiliation = startParents\n      .filter(p => endParents.includes(p))\n      .filter(p => PARAGRAPH_TYPES.includes(p.type))\n\n    start.type = startBlock.type\n    start.block = startBlock\n    end.type = endBlock.type\n    end.block = endBlock\n\n    return {\n      start,\n      end,\n      affiliation,\n      cursorCoords\n    }\n  }\n\n  ContentState.prototype.getCommonParent = function () {\n    const { start, end, affiliation } = this.selectionChange()\n    const parent = affiliation.length ? affiliation[0] : null\n    const startBlock = this.getBlock(start.key)\n    const endBlock = this.getBlock(end.key)\n    const startParentKeys = this.getParents(startBlock).map(b => b.key)\n    const endParentKeys = this.getParents(endBlock).map(b => b.key)\n    const children = parent ? parent.children : this.blocks\n    let startIndex\n    let endIndex\n    for (const child of children) {\n      if (startParentKeys.includes(child.key)) {\n        startIndex = children.indexOf(child)\n      }\n      if (endParentKeys.includes(child.key)) {\n        endIndex = children.indexOf(child)\n      }\n    }\n    return { parent, startIndex, endIndex }\n  }\n\n  ContentState.prototype.handleFrontMatter = function () {\n    const firstBlock = this.blocks[0]\n    if (firstBlock.type === 'pre' && firstBlock.functionType === 'frontmatter') return\n\n    const { frontmatterType } = this.muya.options\n    let lang\n    let style\n    switch (frontmatterType) {\n      case '+':\n        lang = 'toml'\n        style = '+'\n        break\n      case ';':\n        lang = 'json'\n        style = ';'\n        break\n      case '{':\n        lang = 'json'\n        style = '{'\n        break\n      default:\n        lang = 'yaml'\n        style = '-'\n        break\n    }\n\n    const frontMatter = this.createBlock('pre', {\n      functionType: 'frontmatter',\n      lang,\n      style\n    })\n    const codeBlock = this.createBlock('code', {\n      lang\n    })\n    const emptyCodeContent = this.createBlock('span', {\n      functionType: 'codeContent',\n      lang\n    })\n\n    this.appendChild(codeBlock, emptyCodeContent)\n    this.appendChild(frontMatter, codeBlock)\n    this.insertBefore(frontMatter, firstBlock)\n    const { key } = emptyCodeContent\n    const offset = 0\n    this.cursor = {\n      start: { key, offset },\n      end: { key, offset }\n    }\n  }\n\n  // TODO: New created nestled list items missing \"listType\" key and value.\n\n  ContentState.prototype.handleListMenu = function (paraType, insertMode) {\n    const { start, end, affiliation } = this.selectionChange(this.cursor)\n    const { orderListDelimiter, bulletListMarker, preferLooseListItem } = this.muya.options\n    const [blockType, listType] = paraType.split('-')\n    const isListed = affiliation.slice(0, 3).filter(b => /ul|ol/.test(b.type))\n\n    if (isListed.length && !insertMode) {\n      const listBlock = isListed[0]\n      if (listType === listBlock.listType) {\n        const listItems = listBlock.children\n        listItems.forEach(listItem => {\n          listItem.children.forEach(itemParagraph => {\n            if (itemParagraph.type !== 'input') {\n              this.insertBefore(itemParagraph, listBlock)\n            }\n          })\n        })\n        this.removeBlock(listBlock)\n        return\n      }\n      // if the old list block is task list, remove checkbox\n      if (listBlock.listType === 'task') {\n        const listItems = listBlock.children\n        listItems.forEach(item => {\n          const inputBlock = item.children[0]\n          inputBlock && this.removeBlock(inputBlock)\n        })\n      }\n      const oldListType = listBlock.listType\n      listBlock.type = blockType\n      listBlock.listType = listType\n      listBlock.children.forEach(b => (b.listItemType = listType))\n\n      if (listType === 'order') {\n        listBlock.start = listBlock.start || 1\n        listBlock.children.forEach(b => (b.bulletMarkerOrDelimiter = orderListDelimiter))\n      }\n      if (\n        (listType === 'bullet' && oldListType === 'order') ||\n        (listType === 'task' && oldListType === 'order')\n      ) {\n        delete listBlock.start\n        listBlock.children.forEach(b => (b.bulletMarkerOrDelimiter = bulletListMarker))\n      }\n\n      // if the new block is task list, add checkbox\n      if (listType === 'task') {\n        const listItems = listBlock.children\n        listItems.forEach(item => {\n          const checkbox = this.createBlock('input')\n          checkbox.checked = false\n          this.insertBefore(checkbox, item.children[0])\n        })\n      }\n    } else {\n      if (start.key === end.key || (start.block.parent && start.block.parent === end.block.parent)) {\n        const block = this.getBlock(start.key)\n        const paragraph = this.getBlock(block.parent)\n        if (listType === 'task') {\n          // 1. first update the block to bullet list\n          const listItemParagraph = this.updateList(paragraph, 'bullet', undefined, block)\n          // 2. second update bullet list to task list\n          setTimeout(() => {\n            this.updateTaskListItem(listItemParagraph, listType)\n            this.partialRender()\n            this.muya.dispatchSelectionChange()\n            this.muya.dispatchSelectionFormats()\n            this.muya.dispatchChange()\n          })\n          return false\n        } else {\n          this.updateList(paragraph, listType, undefined, block)\n        }\n      } else {\n        const { parent, startIndex, endIndex } = this.getCommonParent()\n        const children = parent ? parent.children : this.blocks\n        const referBlock = children[endIndex]\n        const listWrapper = this.createBlock(listType === 'order' ? 'ol' : 'ul')\n        listWrapper.listType = listType\n        if (listType === 'order') listWrapper.start = 1\n\n        children.slice(startIndex, endIndex + 1).forEach(child => {\n          if (child !== referBlock) {\n            this.removeBlock(child, children)\n          } else {\n            this.insertAfter(listWrapper, child)\n            this.removeBlock(child, children)\n          }\n          const listItem = this.createBlock('li')\n          listItem.listItemType = listType\n          listItem.isLooseListItem = preferLooseListItem\n          this.appendChild(listWrapper, listItem)\n          if (listType === 'task') {\n            const checkbox = this.createBlock('input')\n            checkbox.checked = false\n            this.appendChild(listItem, checkbox)\n          }\n          this.appendChild(listItem, child)\n        })\n      }\n    }\n\n    return true\n  }\n\n  ContentState.prototype.handleLooseListItem = function () {\n    const { affiliation } = this.selectionChange(this.cursor)\n    let listContainer = []\n    if (affiliation.length >= 1 && /ul|ol/.test(affiliation[0].type)) {\n      listContainer = affiliation[0].children\n    } else if (affiliation.length >= 3 && affiliation[1].type === 'li') {\n      listContainer = affiliation[2].children\n    }\n    if (listContainer.length > 0) {\n      for (const block of listContainer) {\n        block.isLooseListItem = !block.isLooseListItem\n      }\n      this.partialRender()\n    }\n  }\n\n  ContentState.prototype.handleCodeBlockMenu = function () {\n    const { start, end, affiliation } = this.selectionChange(this.cursor)\n    const startBlock = this.getBlock(start.key)\n    const endBlock = this.getBlock(end.key)\n    const startParents = this.getParents(startBlock)\n    const endParents = this.getParents(endBlock)\n    const hasFencedCodeBlockParent = () => {\n      return [...startParents, ...endParents].some(b => b.type === 'pre' && /code/.test(b.functionType))\n    }\n    // change fenced code block to p paragraph\n    if (affiliation.length && affiliation[0].type === 'pre' && /code/.test(affiliation[0].functionType)) {\n      const codeBlock = affiliation[0]\n      const codeContent = codeBlock.children[1].children[0].text\n      const states = this.markdownToState(codeContent)\n\n      for (const state of states) {\n        this.insertBefore(state, codeBlock)\n      }\n\n      this.removeBlock(codeBlock)\n\n      const cursorBlock = this.firstInDescendant(states[0])\n      const { key, text } = cursorBlock\n      const offset = text.length\n      this.cursor = {\n        start: { key, offset },\n        end: { key, offset }\n      }\n    } else {\n      if (start.key === end.key) {\n        if (startBlock.type === 'span') {\n          const anchorBlock = this.getParent(startBlock)\n          const lang = ''\n          const preBlock = this.createBlock('pre', {\n            functionType: 'fencecode',\n            lang\n          })\n\n          const codeBlock = this.createBlock('code', {\n            lang\n          })\n\n          const inputBlock = this.createBlock('span', {\n            functionType: 'languageInput'\n          })\n\n          const codeContent = this.createBlock('span', {\n            text: startBlock.text,\n            lang,\n            functionType: 'codeContent'\n          })\n\n          this.appendChild(codeBlock, codeContent)\n          this.appendChild(preBlock, inputBlock)\n          this.appendChild(preBlock, codeBlock)\n          this.insertBefore(preBlock, anchorBlock)\n\n          this.removeBlock(anchorBlock)\n\n          const { key } = inputBlock\n          const offset = 0\n\n          this.cursor = {\n            start: { key, offset },\n            end: { key, offset }\n          }\n        } else {\n          this.cursor = {\n            start: this.cursor.start,\n            end: this.cursor.end\n          }\n        }\n      } else if (!hasFencedCodeBlockParent()) {\n        const { parent, startIndex, endIndex } = this.getCommonParent()\n        const children = parent ? parent.children : this.blocks\n        const referBlock = children[endIndex]\n        const lang = ''\n        const preBlock = this.createBlock('pre', {\n          functionType: 'fencecode',\n          lang\n        })\n        const codeBlock = this.createBlock('code', {\n          lang\n        })\n\n        const { isGitlabCompatibilityEnabled, listIndentation } = this\n        const markdown = new ExportMarkdown(\n          children.slice(startIndex, endIndex + 1),\n          listIndentation,\n          isGitlabCompatibilityEnabled\n        ).generate()\n        const codeContent = this.createBlock('span', {\n          text: markdown,\n          lang,\n          functionType: 'codeContent'\n        })\n        const inputBlock = this.createBlock('span', {\n          functionType: 'languageInput'\n        })\n        this.appendChild(codeBlock, codeContent)\n        this.appendChild(preBlock, inputBlock)\n        this.appendChild(preBlock, codeBlock)\n        this.insertAfter(preBlock, referBlock)\n        let i\n        const removeCache = []\n        for (i = startIndex; i <= endIndex; i++) {\n          const child = children[i]\n          removeCache.push(child)\n        }\n        removeCache.forEach(b => this.removeBlock(b))\n        const key = inputBlock.key\n        const offset = 0\n        this.cursor = {\n          start: { key, offset },\n          end: { key, offset }\n        }\n      }\n    }\n  }\n\n  ContentState.prototype.handleQuoteMenu = function (insertMode) {\n    const { start, end, affiliation } = this.selectionChange(this.cursor)\n    let startBlock = this.getBlock(start.key)\n    const isBlockQuote = affiliation.slice(0, 2).filter(b => /blockquote/.test(b.type))\n    // change blockquote to paragraph\n    if (isBlockQuote.length && !insertMode) {\n      const quoteBlock = isBlockQuote[0]\n      const children = quoteBlock.children\n      for (const child of children) {\n        this.insertBefore(child, quoteBlock)\n      }\n      this.removeBlock(quoteBlock)\n    // change paragraph to blockquote\n    } else {\n      if (start.key === end.key) {\n        if (startBlock.type === 'span') {\n          startBlock = this.getParent(startBlock)\n        }\n        const quoteBlock = this.createBlock('blockquote')\n        this.insertAfter(quoteBlock, startBlock)\n        this.removeBlock(startBlock)\n        this.appendChild(quoteBlock, startBlock)\n      } else {\n        const { parent, startIndex, endIndex } = this.getCommonParent()\n        const children = parent ? parent.children : this.blocks\n        const referBlock = children[endIndex]\n        const quoteBlock = this.createBlock('blockquote')\n\n        children.slice(startIndex, endIndex + 1).forEach(child => {\n          if (child !== referBlock) {\n            this.removeBlock(child, children)\n          } else {\n            this.insertAfter(quoteBlock, child)\n            this.removeBlock(child, children)\n          }\n          this.appendChild(quoteBlock, child)\n        })\n      }\n    }\n  }\n\n  ContentState.prototype.insertContainerBlock = function (functionType, block) {\n    const anchor = this.getAnchor(block)\n    if (!anchor) {\n      console.error('Can not find the anchor paragraph to insert paragraph')\n      return\n    }\n\n    const value = anchor.type === 'p'\n      ? anchor.children.map(child => child.text).join('\\n').trim()\n      : ''\n\n    const containerBlock = this.createContainerBlock(functionType, value)\n    this.insertAfter(containerBlock, anchor)\n    if (anchor.type === 'p') {\n      this.removeBlock(anchor)\n    }\n\n    const cursorBlock = containerBlock.children[0].children[0].children[0]\n    const { key } = cursorBlock\n    const offset = 0\n    this.cursor = {\n      start: { key, offset },\n      end: { key, offset }\n    }\n  }\n\n  ContentState.prototype.showTablePicker = function () {\n    const { eventCenter } = this.muya\n    const reference = this.getPositionReference()\n\n    const handler = (rows, columns) => {\n      this.createTable({ rows: rows + 1, columns: columns + 1 })\n    }\n    eventCenter.dispatch('muya-table-picker', { row: -1, column: -1 }, reference, handler.bind(this))\n  }\n\n  ContentState.prototype.insertHtmlBlock = function (block) {\n    if (block.type === 'span') {\n      block = this.getParent(block)\n    }\n    const preBlock = this.initHtmlBlock(block)\n    const cursorBlock = this.firstInDescendant(preBlock)\n    const { key, text } = cursorBlock\n    const match = /^[^\\n]+\\n[^\\n]*/.exec(text)\n    const offset = match && match[0] ? match[0].length : 0\n\n    this.cursor = {\n      start: { key, offset },\n      end: { key, offset }\n    }\n  }\n\n  ContentState.prototype.updateParagraph = function (paraType, insertMode = false) {\n    const { start, end } = this.cursor\n    const block = this.getBlock(start.key)\n    const { text, type } = block\n    let needDispatchChange = true\n\n    // Only allow valid transformations.\n    if (!this.isAllowedTransformation(block, paraType, start.key !== end.key)) {\n      return\n    }\n\n    // Convert back to paragraph.\n    if (paraType === 'reset-to-paragraph') {\n      const blockType = this.getTypeFromBlock(block)\n      if (!blockType) {\n        return\n      }\n\n      if (blockType === 'table') {\n        return\n      } else if (/heading|hr/.test(blockType)) {\n        paraType = 'paragraph'\n      } else {\n        paraType = blockType\n      }\n    }\n\n    switch (paraType) {\n      case 'front-matter': {\n        this.handleFrontMatter()\n        break\n      }\n      case 'ul-bullet':\n      case 'ul-task':\n      case 'ol-order': {\n        needDispatchChange = this.handleListMenu(paraType, insertMode)\n        break\n      }\n      case 'loose-list-item': {\n        this.handleLooseListItem()\n        break\n      }\n      case 'pre': {\n        this.handleCodeBlockMenu()\n        break\n      }\n      case 'blockquote': {\n        this.handleQuoteMenu(insertMode)\n        break\n      }\n      case 'mathblock': {\n        this.insertContainerBlock('multiplemath', block)\n        break\n      }\n      case 'table': {\n        this.showTablePicker()\n        break\n      }\n      case 'html': {\n        this.insertHtmlBlock(block)\n        break\n      }\n      case 'flowchart':\n      case 'sequence':\n      case 'mermaid':\n      case 'vega-lite':\n        this.insertContainerBlock(paraType, block)\n        break\n      case 'heading 1':\n      case 'heading 2':\n      case 'heading 3':\n      case 'heading 4':\n      case 'heading 5':\n      case 'heading 6':\n      case 'upgrade heading':\n      case 'degrade heading':\n      case 'paragraph': {\n        if (start.key !== end.key) {\n          return\n        }\n\n        const headingStyle = DEFAULT_TURNDOWN_CONFIG.headingStyle\n        const parent = this.getParent(block)\n        // \\u00A0 is &nbsp;\n        const [, hash, partText] = /(^ {0,3}#*[ \\u00A0]*)([\\s\\S]*)/.exec(text)\n        let newLevel = 0 // 1, 2, 3, 4, 5, 6\n        let newType = 'p'\n        let key\n\n        if (/\\d/.test(paraType)) {\n          newLevel = Number(paraType.split(/\\s/)[1])\n          newType = `h${newLevel}`\n        } else if (paraType === 'upgrade heading' || paraType === 'degrade heading') {\n          const currentLevel = getCurrentLevel(parent.type)\n          newLevel = currentLevel\n          if (paraType === 'upgrade heading' && currentLevel !== 1) {\n            if (currentLevel === 0) newLevel = 6\n            else newLevel = currentLevel - 1\n          } else if (paraType === 'degrade heading' && currentLevel !== 0) {\n            if (currentLevel === 6) newLevel = 0\n            else newLevel = currentLevel + 1\n          }\n          newType = newLevel === 0 ? 'p' : `h${newLevel}`\n        }\n\n        const startOffset = newLevel > 0\n          ? start.offset + newLevel - hash.length + 1\n          : start.offset - hash.length // no need to add `1`, because we didn't add `String.fromCharCode(160)` to text paragraph\n        const endOffset = newLevel > 0\n          ? end.offset + newLevel - hash.length + 1\n          : end.offset - hash.length\n        let newText = newLevel > 0\n          ? '#'.repeat(newLevel) + `${String.fromCharCode(160)}${partText}` // &nbsp; code: 160\n          : partText\n\n        // Remove <hr> content when converting to paragraph.\n        if (type === 'span' && block.functionType === 'thematicBreakLine') {\n          newText = ''\n        }\n\n        // No change\n        if (newType === 'p' && parent.type === newType) {\n          return\n        }\n        // No change\n        if (newType !== 'p' && parent.type === newType && parent.headingStyle === headingStyle) {\n          return\n        }\n\n        if (newType !== 'p') {\n          const header = this.createBlock(newType, {\n            headingStyle\n          })\n          const headerContent = this.createBlock('span', {\n            text: headingStyle === 'atx' ? newText.replace(/\\n/g, ' ') : newText,\n            functionType: headingStyle === 'atx' ? 'atxLine' : 'paragraphContent'\n          })\n          this.appendChild(header, headerContent)\n          key = headerContent.key\n\n          this.insertBefore(header, parent)\n          this.removeBlock(parent)\n        } else {\n          const pBlock = this.createBlockP(newText)\n          key = pBlock.children[0].key\n          this.insertAfter(pBlock, parent)\n          this.removeBlock(parent)\n        }\n\n        this.cursor = {\n          start: { key, offset: startOffset },\n          end: { key, offset: endOffset }\n        }\n        break\n      }\n      case 'hr': {\n        const pBlock = this.createBlockP()\n        const archor = block.type === 'span' ? this.getParent(block) : block\n        const hrBlock = this.createBlock('hr')\n        const thematicContent = this.createBlock('span', {\n          functionType: 'thematicBreakLine',\n          text: '---'\n        })\n        this.appendChild(hrBlock, thematicContent)\n        this.insertAfter(hrBlock, archor)\n        this.insertAfter(pBlock, hrBlock)\n        if (!text) {\n          if (block.type === 'span' && this.isOnlyChild(block)) {\n            this.removeBlock(archor)\n          } else {\n            this.removeBlock(block)\n          }\n        }\n        const { key } = pBlock.children[0]\n        const offset = 0\n        this.cursor = {\n          start: { key, offset },\n          end: { key, offset }\n        }\n        break\n      }\n    }\n    if (paraType === 'front-matter' || paraType === 'pre') {\n      this.render()\n    } else {\n      this.partialRender()\n    }\n\n    if (needDispatchChange) {\n      this.muya.dispatchSelectionChange()\n      this.muya.dispatchSelectionFormats()\n      this.muya.dispatchChange()\n    }\n  }\n\n  ContentState.prototype.insertParagraph = function (location, text = '', outMost = false) {\n    const { start, end } = this.cursor\n    // if cursor is not in one line or paragraph, can not insert paragraph\n    if (start.key !== end.key) return\n    const block = this.getBlock(start.key)\n    let anchor = null\n    if (outMost) {\n      anchor = this.findOutMostBlock(block)\n    } else {\n      anchor = this.getAnchor(block)\n    }\n\n    // You can not insert paragraph before frontmatter\n    if (!anchor || anchor && anchor.functionType === 'frontmatter' && location === 'before') {\n      return\n    }\n\n    const newBlock = this.createBlockP(text)\n    if (location === 'before') {\n      this.insertBefore(newBlock, anchor)\n    } else {\n      this.insertAfter(newBlock, anchor)\n    }\n    const { key } = newBlock.children[0]\n    const offset = text.length\n    this.cursor = {\n      start: { key, offset },\n      end: { key, offset }\n    }\n    this.partialRender()\n    this.muya.eventCenter.dispatch('stateChange')\n  }\n\n  ContentState.prototype.getPreBlock = function (block) {\n    const { children } = block\n    if (!children || !children.length) return null\n    for (const child of children) {\n      if (child.type === 'pre') {\n        return child\n      } else {\n        return this.getPreBlock(child)\n      }\n    }\n    return null\n  }\n\n  // make a dulication of the current block\n  ContentState.prototype.duplicate = function () {\n    const { start, end } = this.cursor\n    const startOutmostBlock = this.findOutMostBlock(this.getBlock(start.key))\n    const endOutmostBlock = this.findOutMostBlock(this.getBlock(end.key))\n    if (startOutmostBlock !== endOutmostBlock) {\n      // if the cursor is not in one paragraph, just return\n      return\n    }\n    // if copied block has pre block: html, multiplemath, vega-light, mermaid, flowchart, sequence...\n    const copiedBlock = this.copyBlock(startOutmostBlock)\n    this.insertAfter(copiedBlock, startOutmostBlock)\n\n    const cursorBlock = this.firstInDescendant(copiedBlock)\n    // set cursor at the end of the first descendant of the duplicated block.\n    const { key, text } = cursorBlock\n    const offset = text.length\n    this.cursor = {\n      start: { key, offset },\n      end: { key, offset }\n    }\n    this.partialRender()\n    return this.muya.eventCenter.dispatch('stateChange')\n  }\n\n  // delete current paragraph\n  ContentState.prototype.deleteParagraph = function (blockKey) {\n    let startOutmostBlock\n    if (blockKey) {\n      const block = this.getBlock(blockKey)\n      const firstEditableBlock = this.firstInDescendant(block)\n      startOutmostBlock = this.getAnchor(firstEditableBlock)\n    } else {\n      const { start, end } = this.cursor\n      startOutmostBlock = this.findOutMostBlock(this.getBlock(start.key))\n      const endOutmostBlock = this.findOutMostBlock(this.getBlock(end.key))\n      if (startOutmostBlock !== endOutmostBlock) {\n        // if the cursor is not in one paragraph, just return\n        return\n      }\n    }\n\n    const preBlock = this.getBlock(startOutmostBlock.preSibling)\n    const nextBlock = this.getBlock(startOutmostBlock.nextSibling)\n    let cursorBlock = null\n    if (nextBlock) {\n      cursorBlock = this.firstInDescendant(nextBlock)\n    } else if (preBlock) {\n      cursorBlock = this.lastInDescendant(preBlock)\n    } else {\n      const newBlock = this.createBlockP()\n      this.insertAfter(newBlock, startOutmostBlock)\n      cursorBlock = this.firstInDescendant(newBlock)\n    }\n    this.removeBlock(startOutmostBlock)\n    const { key, text } = cursorBlock\n    const offset = text.length\n    this.cursor = {\n      start: { key, offset },\n      end: { key, offset }\n    }\n    this.partialRender()\n    return this.muya.eventCenter.dispatch('stateChange')\n  }\n\n  ContentState.prototype.isSelectAll = function () {\n    const firstTextBlock = this.getFirstBlock()\n    const lastTextBlock = this.getLastBlock()\n    const { start, end } = this.cursor\n\n    return firstTextBlock.key === start.key &&\n      start.offset === 0 &&\n      lastTextBlock.key === end.key &&\n      end.offset === lastTextBlock.text.length &&\n      !this.muya.keyboard.isComposed\n  }\n\n  ContentState.prototype.selectAllContent = function () {\n    const firstTextBlock = this.getFirstBlock()\n    const lastTextBlock = this.getLastBlock()\n    this.cursor = {\n      start: {\n        key: firstTextBlock.key,\n        offset: 0\n      },\n      end: {\n        key: lastTextBlock.key,\n        offset: lastTextBlock.text.length\n      }\n    }\n\n    return this.render()\n  }\n\n  ContentState.prototype.selectAll = function () {\n    const mayBeCell = this.isSingleCellSelected()\n    const mayBeTable = this.isWholeTableSelected()\n\n    if (mayBeTable) {\n      this.selectedTableCells = null\n      return this.selectAllContent()\n    }\n\n    // Select whole table if already select one cell.\n    if (mayBeCell) {\n      const table = this.closest(mayBeCell, 'table')\n\n      if (table) {\n        return this.selectTable(table)\n      }\n    }\n    const { start, end } = this.cursor\n    const startBlock = this.getBlock(start.key)\n    const endBlock = this.getBlock(end.key)\n    // handle selectAll in table.\n    if (startBlock.functionType === 'cellContent' && endBlock.functionType === 'cellContent') {\n      if (start.key === end.key) {\n        const table = this.closest(startBlock, 'table')\n        const cellBlock = this.closest(startBlock, /th|td/)\n\n        this.selectedTableCells = {\n          tableId: table.key,\n          row: 1,\n          column: 1,\n          cells: [{\n            key: cellBlock.key,\n            text: cellBlock.children[0].text,\n            top: true,\n            right: true,\n            bottom: true,\n            left: true\n          }]\n        }\n\n        this.singleRender(table, false)\n        return this.muya.eventCenter.dispatch('muya-format-picker', { reference: null })\n      } else {\n        const startTable = this.closest(startBlock, 'table')\n        const endTable = this.closest(endBlock, 'table')\n        // Check whether both blocks are in the same table.\n        if (!startTable || !endTable) {\n          console.error('No table found or invalid type.')\n          return\n        } else if (startTable.key !== endTable.key) {\n          // Select entire document\n          return\n        }\n        return this.selectTable(startTable)\n      }\n    }\n    // Handler selectAll in code block. only select all the code block conent.\n    // `code block` here is Math, HTML, BLOCK CODE, Mermaid, vega-lite, flowchart, front-matter etc...\n    if (startBlock.type === 'span' && startBlock.functionType === 'codeContent') {\n      const { key } = startBlock\n      this.cursor = {\n        start: {\n          key,\n          offset: 0\n        },\n        end: {\n          key,\n          offset: startBlock.text.length\n        }\n      }\n\n      return this.partialRender()\n    }\n    // Handler language input, only select language info only...\n    if (startBlock.type === 'span' && startBlock.functionType === 'languageInput') {\n      this.cursor = {\n        start: {\n          key: startBlock.key,\n          offset: 0\n        },\n        end: {\n          key: startBlock.key,\n          offset: startBlock.text.length\n        }\n      }\n      return this.partialRender()\n    }\n\n    return this.selectAllContent()\n  }\n\n  // Test whether the paragraph transformation is valid.\n  ContentState.prototype.isAllowedTransformation = function (block, toType, isMultilineSelection) {\n    const fromType = this.getTypeFromBlock(block)\n    if (toType === 'front-matter') {\n      // Front matter block is added at the beginning.\n      return true\n    } else if (!fromType) {\n      return false\n    } else if (isMultilineSelection && /heading|table/.test(toType)) {\n      return false\n    } else if (fromType === toType || toType === 'reset-to-paragraph') {\n      // Convert back to paragraph.\n      return true\n    }\n\n    switch (fromType) {\n      case 'ul-bullet':\n      case 'ul-task':\n      case 'ol-order':\n      case 'blockquote':\n      case 'paragraph': {\n        // Only allow line and table with an empty paragraph.\n        if (/hr|table/.test(toType) && block.text) {\n          return false\n        }\n        return true\n      }\n      case 'heading 1':\n      case 'heading 2':\n      case 'heading 3':\n      case 'heading 4':\n      case 'heading 5':\n      case 'heading 6':\n        return /paragraph|heading/.test(toType)\n      default:\n        // Tables and all code blocks are not allowed.\n        return false\n    }\n  }\n\n  // Translate block type into internal name.\n  ContentState.prototype.getTypeFromBlock = function (block) {\n    const { type } = block\n\n    let internalType = ''\n    const headingMatch = type.match(/^h([1-6]{1})$/)\n    if (headingMatch && headingMatch[1]) {\n      internalType = `heading ${headingMatch[1]}`\n    }\n\n    switch (type) {\n      case 'span': {\n        if (block.functionType === 'atxLine') {\n          internalType = 'heading 1' // loose match\n        } else if (block.functionType === 'languageInput') {\n          internalType = 'pre'\n        } else if (block.functionType === 'codeContent') {\n          if (block.lang === 'markup') {\n            internalType = 'html'\n          } else if (block.lang === 'latex') {\n            internalType = 'mathblock'\n          }\n\n          // We cannot easy distinguish between diagram and code blocks.\n          const rootBlock = this.getAnchor(block)\n          if (rootBlock && rootBlock.functionType !== 'fencecode') {\n            // Block seems to be a diagram block.\n            internalType = rootBlock.functionType\n          } else {\n            internalType = 'pre'\n          }\n        } else if (block.functionType === 'cellContent') {\n          internalType = 'table'\n        } else if (block.functionType === 'thematicBreakLine') {\n          internalType = 'hr'\n        }\n\n        // List and quote content is also a problem because it's shown as paragraph.\n        const { affiliation } = this.selectionChange(this.cursor)\n        const listTypes = affiliation\n          .slice(0, 3) // the third entry should be the ul/ol\n          .filter(b => /ul|ol/.test(b.type))\n          .map(b => b.listType)\n\n        // Prefer list or blockquote over paragraph.\n        if (listTypes && listTypes.length === 1) {\n          const listType = listTypes[0]\n          if (listType === 'bullet') {\n            internalType = 'ul-bullet'\n          } else if (listType === 'task') {\n            internalType = 'ul-task'\n          } if (listType === 'order') {\n            internalType = 'ol-order'\n          }\n        } else if (affiliation.length === 2 && affiliation[1].type === 'blockquote') {\n          internalType = 'blockquote'\n        } else if (block.functionType === 'paragraphContent') {\n          internalType = 'paragraph'\n        }\n        break\n      }\n      case 'div': {\n        // Preview for math formulas or diagramms.\n        return ''\n      }\n      case 'figure': {\n        if (block.functionType === 'multiplemath') {\n          internalType = 'mathblock'\n        } else {\n          internalType = block.functionType\n        }\n        break\n      }\n      case 'pre': {\n        if (block.functionType === 'multiplemath') {\n          internalType = 'mathblock'\n        } else if (block.functionType === 'fencecode' || block.functionType === 'indentcode') {\n          internalType = 'pre'\n        } else if (block.functionType === 'frontmatter') {\n          internalType = 'front-matter'\n        } else {\n          internalType = block.functionType\n        }\n        break\n      }\n      case 'ul': {\n        if (block.listType === 'task') {\n          internalType = 'ul-task'\n        } else {\n          internalType = 'ul-bullet'\n        }\n        break\n      }\n      case 'ol': {\n        internalType = 'ol-order'\n        break\n      }\n      case 'li': {\n        if (block.listItemType === 'order') {\n          internalType = 'ol-order'\n        } else if (block.listItemType === 'bullet') {\n          internalType = 'ul-bullet'\n        } else if (block.listItemType === 'task') {\n          internalType = 'ul-task'\n        }\n        break\n      }\n      case 'table':\n      case 'th':\n      case 'td': {\n        internalType = 'table'\n        break\n      }\n    }\n    return internalType\n  }\n}\n\nexport default paragraphCtrl\n","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/contentState/copyCutCtrl.js",["1128","1129"],"import selection from '../selection'\nimport { CLASS_OR_ID } from '../config'\nimport { escapeHtml } from '../utils'\nimport { getSanitizeHtml } from '../utils/exportHtml'\nimport ExportMarkdown from '../utils/exportMarkdown'\nimport marked from '../parser/marked'\n\nconst copyCutCtrl = ContentState => {\n  ContentState.prototype.docCutHandler = function (event) {\n    const { selectedTableCells } = this\n    if (selectedTableCells) {\n      event.preventDefault()\n      return this.deleteSelectedTableCells(true)\n    }\n  }\n\n  ContentState.prototype.cutHandler = function () {\n    if (this.selectedTableCells) {\n      return\n    }\n    const { selectedImage } = this\n    if (selectedImage) {\n      const { key, token } = selectedImage\n      this.deleteImage({\n        key,\n        token\n      })\n      return\n    }\n    const { start, end } = selection.getCursorRange()\n    if (!start || !end) {\n      return\n    }\n    const startBlock = this.getBlock(start.key)\n    const endBlock = this.getBlock(end.key)\n    startBlock.text = startBlock.text.substring(0, start.offset) + endBlock.text.substring(end.offset)\n    if (start.key !== end.key) {\n      this.removeBlocks(startBlock, endBlock)\n    }\n    this.cursor = {\n      start,\n      end: start\n    }\n    this.checkInlineUpdate(startBlock)\n    this.partialRender()\n  }\n\n  ContentState.prototype.getClipBoradData = function () {\n    const { start, end } = selection.getCursorRange()\n    if (!start || !end) {\n      return { html: '', text: '' }\n    }\n    if (start.key === end.key) {\n      const startBlock = this.getBlock(start.key)\n      const { type, text, functionType } = startBlock\n      // Fix issue #942\n      if (type === 'span' && functionType === 'codeContent') {\n        const selectedText = text.substring(start.offset, end.offset)\n        return {\n          html: marked(selectedText, this.muya.options),\n          text: selectedText\n        }\n      }\n    }\n    const html = selection.getSelectionHtml()\n    const wrapper = document.createElement('div')\n    wrapper.innerHTML = html\n    const removedElements = wrapper.querySelectorAll(\n      `.${CLASS_OR_ID.AG_TOOL_BAR},\n      .${CLASS_OR_ID.AG_MATH_RENDER},\n      .${CLASS_OR_ID.AG_RUBY_RENDER},\n      .${CLASS_OR_ID.AG_HTML_PREVIEW},\n      .${CLASS_OR_ID.AG_MATH_PREVIEW},\n      .${CLASS_OR_ID.AG_COPY_REMOVE},\n      .${CLASS_OR_ID.AG_LANGUAGE_INPUT},\n      .${CLASS_OR_ID.AG_HTML_TAG} br,\n      .${CLASS_OR_ID.AG_FRONT_ICON}`\n    )\n\n    for (const e of removedElements) {\n      e.remove()\n    }\n\n    // Fix #1678 copy task list, and the first list item is not task list item.\n    const taskListItems = wrapper.querySelectorAll('li.ag-task-list-item')\n    for (const item of taskListItems) {\n      const firstChild = item.firstElementChild\n      if (firstChild && firstChild.nodeName !== 'INPUT') {\n        const originItem = document.querySelector(`#${item.id}`)\n        let checked = false\n        if (originItem && originItem.firstElementChild && originItem.firstElementChild.nodeName === 'INPUT') {\n          checked = originItem.firstElementChild.checked\n        }\n\n        const input = document.createElement('input')\n        input.setAttribute('type', 'checkbox')\n        if (checked) {\n          input.setAttribute('checked', true)\n        }\n\n        item.insertBefore(input, firstChild)\n      }\n    }\n\n    const images = wrapper.querySelectorAll('span.ag-inline-image img')\n    for (const image of images) {\n      const src = image.getAttribute('src')\n      let originSrc = null\n      for (const [sSrc, tSrc] of this.stateRender.urlMap.entries()) {\n        if (tSrc === src) {\n          originSrc = sSrc\n          break\n        }\n      }\n\n      if (originSrc) {\n        image.setAttribute('src', originSrc)\n      }\n    }\n\n    const hrs = wrapper.querySelectorAll('[data-role=hr]')\n    for (const hr of hrs) {\n      hr.replaceWith(document.createElement('hr'))\n    }\n\n    const headers = wrapper.querySelectorAll('[data-head]')\n    for (const header of headers) {\n      const p = document.createElement('p')\n      p.textContent = header.textContent\n      header.replaceWith(p)\n    }\n\n    // replace inline rule element: code, a, strong, em, del, auto_link to span element\n    // in order to escape turndown translation\n\n    const inlineRuleElements = wrapper.querySelectorAll(\n      `a.${CLASS_OR_ID.AG_INLINE_RULE},\n      code.${CLASS_OR_ID.AG_INLINE_RULE},\n      strong.${CLASS_OR_ID.AG_INLINE_RULE},\n      em.${CLASS_OR_ID.AG_INLINE_RULE},\n      del.${CLASS_OR_ID.AG_INLINE_RULE}`\n    )\n    for (const e of inlineRuleElements) {\n      const span = document.createElement('span')\n      span.textContent = e.textContent\n      e.replaceWith(span)\n    }\n\n    const aLinks = wrapper.querySelectorAll(`.${CLASS_OR_ID.AG_A_LINK}`)\n    for (const l of aLinks) {\n      const span = document.createElement('span')\n      span.innerHTML = l.innerHTML\n      l.replaceWith(span)\n    }\n\n    const codefense = wrapper.querySelectorAll('pre[data-role$=\\'code\\']')\n    for (const cf of codefense) {\n      const id = cf.id\n      const block = this.getBlock(id)\n      const language = block.lang || ''\n      const codeContent = cf.querySelector('.ag-code-content')\n      const value = escapeHtml(codeContent.textContent)\n      cf.innerHTML = `<code class=\"language-${language}\">${value}</code>`\n    }\n\n    const tightListItem = wrapper.querySelectorAll('.ag-tight-list-item')\n    for (const li of tightListItem) {\n      for (const item of li.childNodes) {\n        if (item.tagName === 'P' && item.childElementCount === 1 && item.classList.contains('ag-paragraph')) {\n          li.replaceChild(item.firstElementChild, item)\n        }\n      }\n    }\n\n    const htmlBlock = wrapper.querySelectorAll('figure[data-role=\\'HTML\\']')\n    for (const hb of htmlBlock) {\n      const codeContent = hb.querySelector('.ag-code-content')\n      const pre = document.createElement('pre')\n      pre.textContent = codeContent.textContent\n      hb.replaceWith(pre)\n    }\n\n    // Just work for turndown, turndown will add `leading` and `traling` space in line-break.\n    const lineBreaks = wrapper.querySelectorAll('span.ag-soft-line-break, span.ag-hard-line-break')\n    for (const b of lineBreaks) {\n      b.innerHTML = ''\n    }\n\n    const mathBlock = wrapper.querySelectorAll('figure.ag-container-block')\n    for (const mb of mathBlock) {\n      const preElement = mb.querySelector('pre[data-role]')\n      const functionType = preElement.getAttribute('data-role')\n      const codeContent = mb.querySelector('.ag-code-content')\n      const value = codeContent.textContent\n      let pre\n      switch (functionType) {\n        case 'multiplemath':\n          pre = document.createElement('pre')\n          pre.classList.add('multiple-math')\n          pre.textContent = value\n          mb.replaceWith(pre)\n          break\n        case 'mermaid':\n        case 'flowchart':\n        case 'sequence':\n        case 'vega-lite':\n          pre = document.createElement('pre')\n          pre.innerHTML = `<code class=\"language-${functionType}\">${value}</code>`\n          mb.replaceWith(pre)\n          break\n      }\n    }\n\n    let htmlData = wrapper.innerHTML\n    const textData = this.htmlToMarkdown(htmlData)\n    htmlData = marked(textData)\n\n    return { html: htmlData, text: textData }\n  }\n\n  ContentState.prototype.docCopyHandler = function (event) {\n    const { selectedTableCells } = this\n    if (selectedTableCells) {\n      event.preventDefault()\n      const { row, column, cells } = selectedTableCells\n      const tableContents = []\n      let i\n      let j\n      for (i = 0; i < row; i++) {\n        const rowWrapper = []\n        for (j = 0; j < column; j++) {\n          const cell = cells[i * column + j]\n\n          rowWrapper.push({\n            text: cell.text,\n            align: cell.align\n          })\n        }\n        tableContents.push(rowWrapper)\n      }\n\n      if (row === 1 && column === 1) {\n        // Copy cells text if only one is selected\n        event.clipboardData.setData('text/html', '')\n        event.clipboardData.setData('text/plain', tableContents[0][0].text)\n      } else {\n        // Copy as markdown table\n        const figureBlock = this.createBlock('figure', {\n          functionType: 'table'\n        })\n        const table = this.createTableInFigure({ rows: row, columns: column }, tableContents)\n        this.appendChild(figureBlock, table)\n        const { isGitlabCompatibilityEnabled, listIndentation } = this\n        const markdown = new ExportMarkdown([figureBlock], listIndentation, isGitlabCompatibilityEnabled).generate()\n\n        event.clipboardData.setData('text/html', '')\n        event.clipboardData.setData('text/plain', markdown)\n      }\n    }\n  }\n\n  ContentState.prototype.copyHandler = function (event, type, copyInfo = null) {\n    if (this.selectedTableCells) {\n      // Hand over to docCopyHandler\n      return\n    }\n    event.preventDefault()\n    const { selectedImage } = this\n    if (selectedImage) {\n      const { token } = selectedImage\n      event.clipboardData.setData('text/html', token.raw)\n      event.clipboardData.setData('text/plain', token.raw)\n      return\n    }\n\n    const { html, text } = this.getClipBoradData()\n    switch (type) {\n      case 'normal': {\n        event.clipboardData.setData('text/html', html)\n        event.clipboardData.setData('text/plain', text)\n        break\n      }\n      case 'copyAsMarkdown': {\n        event.clipboardData.setData('text/html', '')\n        event.clipboardData.setData('text/plain', text)\n        break\n      }\n      case 'copyAsHtml': {\n        event.clipboardData.setData('text/html', '')\n        event.clipboardData.setData('text/plain', getSanitizeHtml(text, {\n          superSubScript: this.muya.options.superSubScript,\n          footnote: this.muya.options.footnote,\n          isGitlabCompatibilityEnabled: this.muya.options.isGitlabCompatibilityEnabled\n        }))\n        break\n      }\n\n      case 'copyBlock': {\n        const block = typeof copyInfo === 'string' ? this.getBlock(copyInfo) : copyInfo\n        if (!block) return\n        const anchor = this.getAnchor(block)\n        const { isGitlabCompatibilityEnabled, listIndentation } = this\n        const markdown = new ExportMarkdown([anchor], listIndentation, isGitlabCompatibilityEnabled).generate()\n        event.clipboardData.setData('text/html', '')\n        event.clipboardData.setData('text/plain', markdown)\n        break\n      }\n\n      case 'copyCodeContent': {\n        const codeContent = copyInfo\n        if (typeof codeContent !== 'string') {\n          return\n        }\n        event.clipboardData.setData('text/html', '')\n        event.clipboardData.setData('text/plain', codeContent)\n      }\n    }\n  }\n}\n\nexport default copyCutCtrl\n","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/contentState/pasteCtrl.js",["1130"],"\nimport { PARAGRAPH_TYPES, PREVIEW_DOMPURIFY_CONFIG, HAS_TEXT_BLOCK_REG, IMAGE_EXT_REG, URL_REG } from '../config'\nimport { sanitize, getUniqueId, getImageInfo as getImageSrc, getPageTitle } from '../utils'\nimport { getImageInfo } from '../utils/getImageInfo'\n\nconst LIST_REG = /ul|ol/\nconst LINE_BREAKS_REG = /\\n/\n\nconst pasteCtrl = ContentState => {\n  // check paste type: `MERGE` or `NEWLINE`\n  ContentState.prototype.checkPasteType = function (start, fragment) {\n    const fragmentType = fragment.type\n    const parent = this.getParent(start)\n\n    if (fragmentType === 'p') {\n      return 'MERGE'\n    } else if (/^h\\d/.test(fragmentType)) {\n      if (start.text) {\n        return 'MERGE'\n      } else {\n        return 'NEWLINE'\n      }\n    } else if (LIST_REG.test(fragmentType)) {\n      const listItem = this.getParent(parent)\n      const list = listItem && listItem.type === 'li' ? this.getParent(listItem) : null\n      if (list) {\n        if (\n          list.listType === fragment.listType &&\n          listItem.bulletMarkerOrDelimiter === fragment.children[0].bulletMarkerOrDelimiter\n        ) {\n          return 'MERGE'\n        } else {\n          return 'NEWLINE'\n        }\n      } else {\n        return 'NEWLINE'\n      }\n    } else {\n      return 'NEWLINE'\n    }\n  }\n\n  // Try to identify the data type.\n  ContentState.prototype.checkCopyType = function (html, text) {\n    let type = 'normal'\n    if (!html && text) {\n      type = 'copyAsMarkdown'\n      const match = /^<([a-zA-Z\\d-]+)(?=\\s|>).*?>[\\s\\S]+?<\\/([a-zA-Z\\d-]+)>$/.exec(text.trim())\n      if (match && match[1]) {\n        const tag = match[1]\n        if (tag === 'table' && match.length === 3 && match[2] === 'table') {\n          // Try to import a single table\n          const tmp = document.createElement('table')\n          tmp.innerHTML = text\n          if (tmp.childElementCount === 1) {\n            return 'htmlToMd'\n          }\n        }\n\n        // TODO: We could try to import HTML elements such as headings, text and lists to markdown for better UX.\n        type = PARAGRAPH_TYPES.find(type => type === tag) ? 'copyAsHtml' : type\n      }\n    }\n    return type\n  }\n\n  ContentState.prototype.standardizeHTML = async function (html) {\n    // Only extract the `body.innerHTML` when the `html` is a full HTML Document.\n    if (/<body>[\\s\\S]*<\\/body>/.test(html)) {\n      const match = /<body>([\\s\\S]*)<\\/body>/.exec(html)\n      if (match && typeof match[1] === 'string') {\n        html = match[1]\n      }\n    }\n\n    // Prevent XSS and sanitize HTML.\n    const { disableHtml } = this.muya.options\n    const sanitizedHtml = sanitize(html, PREVIEW_DOMPURIFY_CONFIG, disableHtml)\n    const tempWrapper = document.createElement('div')\n    tempWrapper.innerHTML = sanitizedHtml\n\n    // Special process for turndown.js, needed for Number app on macOS.\n    const tables = Array.from(tempWrapper.querySelectorAll('table'))\n    for (const table of tables) {\n      const row = table.querySelector('tr')\n      if (row.firstElementChild.tagName !== 'TH') {\n        [...row.children].forEach(cell => {\n          const th = document.createElement('th')\n          th.innerHTML = cell.innerHTML\n          cell.replaceWith(th)\n        })\n      }\n      const paragraphs = Array.from(table.querySelectorAll('p'))\n      for (const p of paragraphs) {\n        const span = document.createElement('span')\n        span.innerHTML = p.innerHTML\n        p.replaceWith(span)\n      }\n\n      const tds = table.querySelectorAll('td')\n      for (const td of tds) {\n        const rawHtml = td.innerHTML\n        if (/<br>/.test(rawHtml)) {\n          td.innerHTML = rawHtml.replace(/<br>/g, '&lt;br&gt;')\n        }\n      }\n    }\n\n    // Prevent it parse into a link if copy a url.\n    const links = Array.from(tempWrapper.querySelectorAll('a'))\n    for (const link of links) {\n      const href = link.getAttribute('href')\n      const text = link.textContent\n\n      if (href === text) {\n        const title = await getPageTitle(href)\n        if (title) {\n          link.textContent = title\n        } else {\n          const span = document.createElement('span')\n          span.innerHTML = text\n          link.replaceWith(span)\n        }\n      }\n    }\n    return tempWrapper.innerHTML\n  }\n\n  ContentState.prototype.pasteImage = async function (event) {\n    // Try to guess the clipboard file path.\n    const imagePath = this.muya.options.clipboardFilePath()\n    if (imagePath && typeof imagePath === 'string' && IMAGE_EXT_REG.test(imagePath)) {\n      const id = `loading-${getUniqueId()}`\n      if (this.selectedImage) {\n        this.replaceImage(this.selectedImage, {\n          alt: id,\n          src: imagePath\n        })\n      } else {\n        this.insertImage({\n          alt: id,\n          src: imagePath\n        })\n      }\n      const nSrc = await this.muya.options.imageAction(imagePath, id)\n      const { src } = getImageSrc(imagePath)\n      if (src) {\n        this.stateRender.urlMap.set(nSrc, src)\n      }\n\n      const imageWrapper = this.muya.container.querySelector(`span[data-id=${id}]`)\n\n      if (imageWrapper) {\n        const imageInfo = getImageInfo(imageWrapper)\n        this.replaceImage(imageInfo, {\n          src: nSrc\n        })\n      }\n      return imagePath\n    }\n\n    const items = event.clipboardData && event.clipboardData.items\n    let file = null\n    if (items && items.length) {\n      for (let i = 0; i < items.length; i++) {\n        if (items[i].type.indexOf('image') !== -1) {\n          file = items[i].getAsFile()\n          break\n        }\n      }\n    }\n\n    // handle paste to create inline image\n    if (file) {\n      const id = `loading-${getUniqueId()}`\n      if (this.selectedImage) {\n        this.replaceImage(this.selectedImage, {\n          alt: id,\n          src: ''\n        })\n      } else {\n        this.insertImage({\n          alt: id,\n          src: ''\n        })\n      }\n\n      const reader = new FileReader()\n      reader.onload = event => {\n        const base64 = event.target.result\n        const imageWrapper = this.muya.container.querySelector(`span[data-id=${id}]`)\n        const imageContainer = this.muya.container.querySelector(`span[data-id=${id}] .ag-image-container`)\n        this.stateRender.urlMap.set(id, base64)\n        if (imageContainer) {\n          imageWrapper.classList.remove('ag-empty-image')\n          imageWrapper.classList.add('ag-image-success')\n          const image = document.createElement('img')\n          image.src = base64\n          imageContainer.appendChild(image)\n        }\n      }\n      reader.readAsDataURL(file)\n\n      const nSrc = await this.muya.options.imageAction(file, id)\n      const base64 = this.stateRender.urlMap.get(id)\n      if (base64) {\n        this.stateRender.urlMap.set(nSrc, base64)\n        this.stateRender.urlMap.delete(id)\n      }\n      const imageWrapper = this.muya.container.querySelector(`span[data-id=${id}]`)\n\n      if (imageWrapper) {\n        const imageInfo = getImageInfo(imageWrapper)\n        this.replaceImage(imageInfo, {\n          src: nSrc\n        })\n      }\n      return file\n    }\n    return null\n  }\n\n  // Handle global events.\n  ContentState.prototype.docPasteHandler = async function (event) {\n    // TODO: Pasting into CodeMirror will not work for special data like images\n    // or tables (HTML) because it's not handled.\n\n    const file = await this.pasteImage(event)\n    if (file) {\n      return event.preventDefault()\n    }\n\n    if (this.selectedTableCells) {\n      const { start } = this.cursor\n      const startBlock = this.getBlock(start.key)\n      const { selectedTableCells: stc } = this\n\n      // Exactly one table cell is selected. Replace the cells text via default handler.\n      if (startBlock && startBlock.functionType === 'cellContent' && stc.row === 1 && stc.column === 1) {\n        this.pasteHandler(event)\n        return event.preventDefault()\n      }\n    }\n  }\n\n  // Handle `normal` and `pasteAsPlainText` paste for preview mode.\n  ContentState.prototype.pasteHandler = async function (event, type = 'normal', rawText, rawHtml) {\n    event.preventDefault()\n    event.stopPropagation()\n\n    const text = rawText || event.clipboardData.getData('text/plain')\n    let html = rawHtml || event.clipboardData.getData('text/html')\n\n    // Support pasted URLs from Firefox.\n    if (URL_REG.test(text) && !/\\s/.test(text) && !html) {\n      html = `<a href=\"${text}\">${text}</a>`\n    }\n\n    // Remove crap from HTML such as meta data and styles.\n    html = await this.standardizeHTML(html)\n\n    let copyType = this.checkCopyType(html, text)\n    const { start, end } = this.cursor\n    const startBlock = this.getBlock(start.key)\n    const endBlock = this.getBlock(end.key)\n    const parent = this.getParent(startBlock)\n\n    if (copyType === 'htmlToMd') {\n      html = text\n      copyType = 'normal'\n    }\n\n    if (start.key !== end.key) {\n      this.cutHandler()\n      return this.pasteHandler(event, type, rawText, rawHtml)\n    }\n\n    // NOTE: We should parse HTML if we can and use it instead the image (see GH#1271).\n    if (!html) {\n      const file = await this.pasteImage(event)\n      if (file) {\n        return\n      }\n    }\n\n    const appendHtml = (text) => {\n      startBlock.text = startBlock.text.substring(0, start.offset) + text + startBlock.text.substring(start.offset)\n      const { key } = start\n      const offset = start.offset + text.length\n      this.cursor = {\n        start: { key, offset },\n        end: { key, offset }\n      }\n    }\n\n    // Prepare paste\n    if (startBlock.type === 'span' && startBlock.functionType === 'languageInput') {\n      // Extract the first line from the language identifier (GH#553)\n      let language = text.trim().match(/^.*$/m)[0] || ''\n      const oldLanguageLength = startBlock.text.length\n      let offset = 0\n      if (start.offset !== 0 || end.offset !== oldLanguageLength) {\n        const prePartText = startBlock.text.substring(0, start.offset)\n        const postPartText = startBlock.text.substring(end.offset)\n\n        // Expect that the language doesn't contain new lines\n        language = prePartText + language + postPartText\n        offset = prePartText.length + language.length\n      } else {\n        offset = language.length\n      }\n\n      startBlock.text = language\n\n      const key = startBlock.key\n      this.cursor = {\n        start: { key, offset },\n        end: { key, offset }\n      }\n\n      // Hide code picker float box\n      const { eventCenter } = this.muya\n      eventCenter.dispatch('muya-code-picker', { reference: null })\n\n      // Update code block language and render\n      this.updateCodeLanguage(startBlock, language)\n      return\n    }\n\n    if (startBlock.type === 'span' && startBlock.functionType === 'codeContent') {\n      const blockText = startBlock.text\n      const prePartText = blockText.substring(0, start.offset)\n      const postPartText = blockText.substring(end.offset)\n      startBlock.text = prePartText + text + postPartText\n      const { key } = startBlock\n      const offset = start.offset + text.length\n      this.cursor = {\n        start: { key, offset },\n        end: { key, offset }\n      }\n\n      return this.partialRender()\n    }\n\n    if (startBlock.functionType === 'cellContent') {\n      let isOneCellSelected = false\n      if (this.selectedTableCells) {\n        const { selectedTableCells: stc } = this\n        // Replace cells text when one cell is selected.\n        if (stc.row === 1 && stc.column === 1) {\n          isOneCellSelected = true\n        } else {\n          // Cancel event, multiple cells are selected.\n          return this.partialRender()\n        }\n      }\n\n      const { key } = startBlock\n      const pendingText = text.trim().replace(/\\n/g, '<br/>')\n      let offset = pendingText.length\n      if (isOneCellSelected) {\n        // Replace text and deselect cell.\n        startBlock.text = pendingText\n        this.selectedTableCells = null\n      } else {\n        offset += start.offset\n        startBlock.text = startBlock.text.substring(0, start.offset) + pendingText + startBlock.text.substring(end.offset)\n      }\n\n      this.cursor = {\n        start: { key, offset },\n        end: { key, offset }\n      }\n      return this.partialRender()\n    }\n\n    // Handle paste event and transform data into internal block structure.\n    if (copyType === 'copyAsHtml') {\n      switch (type) {\n        case 'normal': {\n          const htmlBlock = this.createBlockP(text.trim())\n          this.insertAfter(htmlBlock, parent)\n          this.removeBlock(parent)\n          // handler heading\n          this.insertHtmlBlock(htmlBlock)\n          break\n        }\n        case 'pasteAsPlainText': {\n          const lines = text.trim().split(LINE_BREAKS_REG)\n          let htmlBlock = null\n\n          if (!startBlock.text || lines.length > 1) {\n            htmlBlock = this.createBlockP((startBlock.text ? lines.slice(1) : lines).join('\\n'))\n          }\n          if (htmlBlock) {\n            this.insertAfter(htmlBlock, parent)\n            this.insertHtmlBlock(htmlBlock)\n          }\n          if (startBlock.text) {\n            appendHtml(lines[0])\n          } else {\n            this.removeBlock(parent)\n          }\n          break\n        }\n      }\n      return this.partialRender()\n    }\n\n    const stateFragments = type === 'pasteAsPlainText' || copyType === 'copyAsMarkdown'\n      ? this.markdownToState(text)\n      : this.html2State(html)\n\n    if (stateFragments.length <= 0) {\n      return\n    }\n\n    // Step 1: if select content, cut the content, and chop the block text into two part by the cursor.\n    const cacheText = endBlock.text.substring(end.offset)\n    startBlock.text = startBlock.text.substring(0, start.offset)\n\n    // Step 2: when insert the fragments, check begin a new block, or insert into pre block.\n    const firstFragment = stateFragments[0]\n    const tailFragments = stateFragments.slice(1)\n    const pasteType = this.checkPasteType(startBlock, firstFragment)\n\n    const getLastBlock = blocks => {\n      const len = blocks.length\n      const lastBlock = blocks[len - 1]\n\n      if (lastBlock.children.length === 0 && HAS_TEXT_BLOCK_REG.test(lastBlock.type)) {\n        return lastBlock\n      } else {\n        if (lastBlock.editable === false) {\n          return getLastBlock(blocks[len - 2].children)\n        } else {\n          return getLastBlock(lastBlock.children)\n        }\n      }\n    }\n\n    const lastBlock = getLastBlock(stateFragments)\n    let key = lastBlock.key\n    let offset = lastBlock.text.length\n    lastBlock.text += cacheText\n\n    switch (pasteType) {\n      case 'MERGE': {\n        if (LIST_REG.test(firstFragment.type)) {\n          const listItems = firstFragment.children\n          const firstListItem = listItems[0]\n          const liChildren = firstListItem.children\n          const originListItem = this.getParent(parent)\n          const originList = this.getParent(originListItem)\n          const targetListType = firstFragment.children[0].isLooseListItem\n          const originListType = originList.children[0].isLooseListItem\n          // No matter copy loose list to tight list or vice versa, the result is one loose list.\n          if (targetListType !== originListType) {\n            if (!targetListType) {\n              firstFragment.children.forEach(item => (item.isLooseListItem = true))\n            } else {\n              originList.children.forEach(item => (item.isLooseListItem = true))\n            }\n          }\n\n          if (liChildren[0].type === 'p') {\n            // TODO @JOCS\n            startBlock.text += liChildren[0].children[0].text\n            const tail = liChildren.slice(1)\n            if (tail.length) {\n              tail.forEach(t => {\n                this.appendChild(originListItem, t)\n              })\n            }\n            const firstFragmentTail = listItems.slice(1)\n            if (firstFragmentTail.length) {\n              firstFragmentTail.forEach(t => {\n                this.appendChild(originList, t)\n              })\n            }\n          } else {\n            listItems.forEach(c => {\n              this.appendChild(originList, c)\n            })\n          }\n          let target = originList\n          tailFragments.forEach(block => {\n            this.insertAfter(block, target)\n            target = block\n          })\n        } else if (firstFragment.type === 'p' || /^h\\d/.test(firstFragment.type)) {\n          const text = firstFragment.children[0].text\n          const lines = text.split('\\n')\n          let target = parent\n          if (parent.headingStyle === 'atx') {\n            startBlock.text += lines[0]\n            if (lines.length > 1) {\n              const pBlock = this.createBlockP(lines.slice(1).join('\\n'))\n              this.insertAfter(parent, pBlock)\n              target = pBlock\n            }\n          } else {\n            startBlock.text += text\n          }\n\n          tailFragments.forEach(block => {\n            this.insertAfter(block, target)\n            target = block\n          })\n        }\n        break\n      }\n      case 'NEWLINE': {\n        let target = parent\n        stateFragments.forEach(block => {\n          this.insertAfter(block, target)\n          target = block\n        })\n        if (startBlock.text.length === 0) {\n          this.removeBlock(parent)\n        }\n        break\n      }\n      default: {\n        throw new Error('unknown paste type')\n      }\n    }\n\n    // Step 3: set cursor and render\n    let cursorBlock = this.getBlock(key)\n    if (!cursorBlock) {\n      key = startBlock.key\n      offset = startBlock.text.length - cacheText.length\n      cursorBlock = startBlock\n    }\n\n    this.cursor = {\n      start: {\n        key, offset\n      },\n      end: {\n        key, offset\n      }\n    }\n    this.checkInlineUpdate(cursorBlock)\n    this.partialRender()\n    this.muya.dispatchSelectionChange()\n    this.muya.dispatchSelectionFormats()\n    return this.muya.dispatchChange()\n  }\n}\n\nexport default pasteCtrl\n","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/contentState/arrowCtrl.js",["1131"],"import { EVENT_KEYS, CLASS_OR_ID } from '../config'\nimport { findNearestParagraph } from '../selection/dom'\nimport selection from '../selection'\n\n// If the next block is header, put cursor after the `#{1,6} *`\nconst adjustOffset = (offset, block, event) => {\n  if (/^span$/.test(block.type) && block.functionType === 'atxLine' && event.key === EVENT_KEYS.ArrowDown) {\n    const match = /^\\s{0,3}(?:#{1,6})(?:\\s{1,}|$)/.exec(block.text)\n    if (match) {\n      return match[0].length\n    }\n  }\n  return offset\n}\n\nconst arrowCtrl = ContentState => {\n  ContentState.prototype.findNextRowCell = function (cell) {\n    if (cell.functionType !== 'cellContent') {\n      throw new Error(`block with type ${cell && cell.type} is not a table cell`)\n    }\n    const thOrTd = this.getParent(cell)\n    const row = this.closest(cell, 'tr')\n    const rowContainer = this.closest(row, /thead|tbody/) // thead or tbody\n    const column = row.children.indexOf(thOrTd)\n    if (rowContainer.type === 'thead') {\n      const tbody = this.getNextSibling(rowContainer)\n      if (tbody && tbody.children.length) {\n        return tbody.children[0].children[column].children[0]\n      }\n    } else if (rowContainer.type === 'tbody') {\n      const nextRow = this.getNextSibling(row)\n      if (nextRow) {\n        return nextRow.children[column].children[0]\n      }\n    }\n    return null\n  }\n\n  ContentState.prototype.findPrevRowCell = function (cell) {\n    if (cell.functionType !== 'cellContent') {\n      throw new Error(`block with type ${cell && cell.type} is not a table cell`)\n    }\n    const thOrTd = this.getParent(cell)\n    const row = this.closest(cell, 'tr')\n    const rowContainer = this.getParent(row) // thead or tbody\n    const rowIndex = rowContainer.children.indexOf(row)\n    const column = row.children.indexOf(thOrTd)\n    if (rowContainer.type === 'tbody') {\n      if (rowIndex === 0 && rowContainer.preSibling) {\n        const thead = this.getPreSibling(rowContainer)\n        return thead.children[0].children[column].children[0]\n      } else if (rowIndex > 0) {\n        return this.getPreSibling(row).children[column].children[0]\n      }\n      return null\n    }\n    return null\n  }\n\n  ContentState.prototype.docArrowHandler = function (event) {\n    const { selectedImage } = this\n    if (selectedImage) {\n      const { key, token } = selectedImage\n      const { start, end } = token.range\n      event.preventDefault()\n      event.stopPropagation()\n      const block = this.getBlock(key)\n      switch (event.key) {\n        case EVENT_KEYS.ArrowUp:\n        case EVENT_KEYS.ArrowLeft: {\n          this.cursor = {\n            start: { key, offset: start },\n            end: { key, offset: start }\n          }\n          break\n        }\n        case EVENT_KEYS.ArrowDown:\n        case EVENT_KEYS.ArrowRight: {\n          this.cursor = {\n            start: { key, offset: end },\n            end: { key, offset: end }\n          }\n          break\n        }\n      }\n      this.muya.keyboard.hideAllFloatTools()\n      return this.singleRender(block)\n    }\n  }\n\n  ContentState.prototype.arrowHandler = function (event) {\n    const node = selection.getSelectionStart()\n    const paragraph = findNearestParagraph(node)\n    const id = paragraph.id\n    const block = this.getBlock(id)\n    const preBlock = this.findPreBlockInLocation(block)\n    const nextBlock = this.findNextBlockInLocation(block)\n    const { start, end } = selection.getCursorRange()\n    const { topOffset, bottomOffset } = selection.getCursorYOffset(paragraph)\n    if (!start || !end) {\n      return\n    }\n\n    // fix #101\n    if (event.key === EVENT_KEYS.ArrowRight && node && node.classList && node.classList.contains(CLASS_OR_ID.AG_MATH_TEXT)) {\n      const { right } = selection.getCaretOffsets(node)\n      if (right === 0 && start.key === end.key && start.offset === end.offset) {\n        // It's not recommended to use such lower API, but it's work well.\n        return selection.select(node.parentNode.nextElementSibling, 0)\n      }\n    }\n\n    // Just do nothing if the cursor is not collapsed or `shiftKey` pressed\n    if (\n      (start.key === end.key && start.offset !== end.offset) ||\n      start.key !== end.key || event.shiftKey\n    ) {\n      return\n    }\n\n    if (\n      (event.key === EVENT_KEYS.ArrowUp && topOffset > 0) ||\n      (event.key === EVENT_KEYS.ArrowDown && bottomOffset > 0)\n    ) {\n      if (!/pre/.test(block.type) || block.functionType !== 'cellContent') {\n        return\n      }\n    }\n\n    if (block.functionType === 'cellContent') {\n      let activeBlock\n      const cellInNextRow = this.findNextRowCell(block)\n      const cellInPrevRow = this.findPrevRowCell(block)\n\n      if (event.key === EVENT_KEYS.ArrowUp) {\n        if (cellInPrevRow) {\n          activeBlock = cellInPrevRow\n        } else {\n          activeBlock = this.findPreBlockInLocation(this.getTableBlock())\n        }\n      }\n\n      if (event.key === EVENT_KEYS.ArrowDown) {\n        if (cellInNextRow) {\n          activeBlock = cellInNextRow\n        } else {\n          activeBlock = this.findNextBlockInLocation(this.getTableBlock())\n        }\n      }\n\n      if (activeBlock) {\n        event.preventDefault()\n        event.stopPropagation()\n        let offset = activeBlock.type === 'p'\n          ? 0\n          : (event.key === EVENT_KEYS.ArrowUp\n            ? activeBlock.text.length\n            : 0)\n\n        offset = adjustOffset(offset, activeBlock, event)\n\n        const key = activeBlock.type === 'p'\n          ? activeBlock.children[0].key\n          : activeBlock.key\n\n        this.cursor = {\n          start: {\n            key,\n            offset\n          },\n          end: {\n            key,\n            offset\n          }\n        }\n\n        return this.partialRender()\n      }\n    }\n\n    if (\n      (event.key === EVENT_KEYS.ArrowUp) ||\n      (event.key === EVENT_KEYS.ArrowLeft && start.offset === 0)\n    ) {\n      event.preventDefault()\n      event.stopPropagation()\n      if (!preBlock) return\n      const key = preBlock.key\n      const offset = preBlock.text.length\n      this.cursor = {\n        start: { key, offset },\n        end: { key, offset }\n      }\n\n      return this.partialRender()\n    } else if (\n      (event.key === EVENT_KEYS.ArrowDown) ||\n      (event.key === EVENT_KEYS.ArrowRight && start.offset === block.text.length)\n    ) {\n      event.preventDefault()\n      event.stopPropagation()\n      let key\n      let newBlock\n      if (nextBlock) {\n        key = nextBlock.key\n      } else {\n        newBlock = this.createBlockP()\n        const lastBlock = this.blocks[this.blocks.length - 1]\n        this.insertAfter(newBlock, lastBlock)\n        key = newBlock.children[0].key\n      }\n      const offset = adjustOffset(0, nextBlock || newBlock, event)\n      this.cursor = {\n        start: { key, offset },\n        end: { key, offset }\n      }\n\n      return this.partialRender()\n    }\n  }\n}\n\nexport default arrowCtrl\n","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/contentState/core.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/contentState/history.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/contentState/tableDragBarCtrl.js",["1132","1133"],"const calculateAspects = (tableId, barType) => {\n  const table = document.querySelector(`#${tableId}`)\n  if (barType === 'bottom') {\n    const firstRow = table.querySelector('tr')\n    return Array.from(firstRow.children).map(cell => cell.clientWidth)\n  } else {\n    return Array.from(table.querySelectorAll('tr')).map(row => row.clientHeight)\n  }\n}\n\nexport const getAllTableCells = tableId => {\n  const table = document.querySelector(`#${tableId}`)\n  const rows = table.querySelectorAll('tr')\n  const cells = []\n  for (const row of Array.from(rows)) {\n    cells.push(Array.from(row.children))\n  }\n\n  return cells\n}\n\nexport const getIndex = (barType, cell) => {\n  if (cell.tagName === 'SPAN') {\n    cell = cell.parentNode\n  }\n  const row = cell.parentNode\n  if (barType === 'bottom') {\n    return Array.from(row.children).indexOf(cell)\n  } else {\n    const rowContainer = row.parentNode\n    if (rowContainer.tagName === 'THEAD') {\n      return 0\n    } else {\n      return Array.from(rowContainer.children).indexOf(row) + 1\n    }\n  }\n}\n\nconst getDragCells = (tableId, barType, index) => {\n  const table = document.querySelector(`#${tableId}`)\n  const dragCells = []\n  if (barType === 'left') {\n    if (index === 0) {\n      dragCells.push(...table.querySelectorAll('th'))\n    } else {\n      const row = table.querySelector('tbody').children[index - 1]\n      dragCells.push(...row.children)\n    }\n  } else {\n    const rows = Array.from(table.querySelectorAll('tr'))\n    const len = rows.length\n    let i\n    for (i = 0; i < len; i++) {\n      dragCells.push(rows[i].children[index])\n    }\n  }\n  return dragCells\n}\n\nconst tableDragBarCtrl = ContentState => {\n  ContentState.prototype.handleMouseDown = function (event) {\n    event.preventDefault()\n    const { eventCenter } = this.muya\n    const { clientX, clientY, target } = event\n    const tableId = target.closest('table').id\n    const barType = target.classList.contains('left') ? 'left' : 'bottom'\n    const index = getIndex(barType, target)\n    const aspects = calculateAspects(tableId, barType)\n    this.dragInfo = {\n      tableId,\n      clientX,\n      clientY,\n      barType,\n      index,\n      curIndex: index,\n      dragCells: getDragCells(tableId, barType, index),\n      cells: getAllTableCells(tableId),\n      aspects,\n      offset: 0\n    }\n\n    for (const row of this.dragInfo.cells) {\n      for (const cell of row) {\n        if (!this.dragInfo.dragCells.includes(cell)) {\n          cell.classList.add('ag-cell-transform')\n        }\n      }\n    }\n\n    const mouseMoveId = eventCenter.attachDOMEvent(document, 'mousemove', this.handleMouseMove.bind(this))\n    const mouseUpId = eventCenter.attachDOMEvent(document, 'mouseup', this.handleMouseUp.bind(this))\n    this.dragEventIds.push(mouseMoveId, mouseUpId)\n  }\n\n  ContentState.prototype.handleMouseMove = function (event) {\n    if (!this.dragInfo) {\n      return\n    }\n    const { barType } = this.dragInfo\n    const attrName = barType === 'bottom' ? 'clientX' : 'clientY'\n    const offset = this.dragInfo.offset = event[attrName] - this.dragInfo[attrName]\n    if (Math.abs(offset) < 5) {\n      return\n    }\n    this.isDragTableBar = true\n    this.hideUnnecessaryBar()\n    this.calculateCurIndex()\n    this.setDragTargetStyle()\n    this.setSwitchStyle()\n  }\n\n  ContentState.prototype.handleMouseUp = function (event) {\n    const { eventCenter } = this.muya\n    for (const id of this.dragEventIds) {\n      eventCenter.detachDOMEvent(id)\n    }\n    this.dragEventIds = []\n    if (!this.isDragTableBar) {\n      return\n    }\n\n    this.setDropTargetStyle()\n\n    // The drop animation need 300ms.\n    setTimeout(() => {\n      this.switchTableData()\n      this.resetDragTableBar()\n    }, 300)\n  }\n\n  ContentState.prototype.hideUnnecessaryBar = function () {\n    const { barType } = this.dragInfo\n    const hideClassName = barType === 'bottom' ? 'left' : 'bottom'\n    const needHideBar = document.querySelector(`.ag-drag-handler.${hideClassName}`)\n    if (needHideBar) {\n      needHideBar.style.display = 'none'\n    }\n  }\n\n  ContentState.prototype.calculateCurIndex = function () {\n    let { offset, aspects, index } = this.dragInfo\n    let curIndex = index\n    const len = aspects.length\n    let i\n    if (offset > 0) {\n      for (i = index; i < len; i++) {\n        const aspect = aspects[i]\n        if (i === index) {\n          offset -= Math.floor(aspect / 2)\n        } else {\n          offset -= aspect\n        }\n        if (offset < 0) {\n          break\n        } else {\n          curIndex++\n        }\n      }\n    } else if (offset < 0) {\n      for (i = index; i >= 0; i--) {\n        const aspect = aspects[i]\n        if (i === index) {\n          offset += Math.floor(aspect / 2)\n        } else {\n          offset += aspect\n        }\n        if (offset > 0) {\n          break\n        } else {\n          curIndex--\n        }\n      }\n    }\n\n    this.dragInfo.curIndex = Math.max(0, Math.min(curIndex, len - 1))\n  }\n\n  ContentState.prototype.setDragTargetStyle = function () {\n    const { offset, barType, dragCells } = this.dragInfo\n\n    for (const cell of dragCells) {\n      if (!cell.classList.contains('ag-drag-cell')) {\n        cell.classList.add('ag-drag-cell')\n        cell.classList.add(`ag-drag-${barType}`)\n      }\n      const valueName = barType === 'bottom' ? 'translateX' : 'translateY'\n      cell.style.transform = `${valueName}(${offset}px)`\n    }\n  }\n\n  ContentState.prototype.setSwitchStyle = function () {\n    const { index, offset, curIndex, barType, aspects, cells } = this.dragInfo\n    const aspect = aspects[index]\n    const len = aspects.length\n\n    let i\n    if (offset > 0) {\n      if (barType === 'bottom') {\n        for (const row of cells) {\n          for (i = 0; i < len; i++) {\n            const cell = row[i]\n            if (i > index && i <= curIndex) {\n              cell.style.transform = `translateX(${-aspect}px)`\n            } else if (i !== index) {\n              cell.style.transform = 'translateX(0px)'\n            }\n          }\n        }\n      } else {\n        for (i = 0; i < len; i++) {\n          const row = cells[i]\n          for (const cell of row) {\n            if (i > index && i <= curIndex) {\n              cell.style.transform = `translateY(${-aspect}px)`\n            } else if (i !== index) {\n              cell.style.transform = 'translateY(0px)'\n            }\n          }\n        }\n      }\n    } else {\n      if (barType === 'bottom') {\n        for (const row of cells) {\n          for (i = 0; i < len; i++) {\n            const cell = row[i]\n            if (i >= curIndex && i < index) {\n              cell.style.transform = `translateX(${aspect}px)`\n            } else if (i !== index) {\n              cell.style.transform = 'translateX(0px)'\n            }\n          }\n        }\n      } else {\n        for (i = 0; i < len; i++) {\n          const row = cells[i]\n          for (const cell of row) {\n            if (i >= curIndex && i < index) {\n              cell.style.transform = `translateY(${aspect}px)`\n            } else if (i !== index) {\n              cell.style.transform = 'translateY(0px)'\n            }\n          }\n        }\n      }\n    }\n  }\n\n  ContentState.prototype.setDropTargetStyle = function () {\n    const { dragCells, barType, curIndex, index, aspects, offset } = this.dragInfo\n    let move = 0\n    let i\n    if (offset > 0) {\n      for (i = index + 1; i <= curIndex; i++) {\n        move += aspects[i]\n      }\n    } else {\n      for (i = curIndex; i < index; i++) {\n        move -= aspects[i]\n      }\n    }\n    for (const cell of dragCells) {\n      cell.classList.remove('ag-drag-cell')\n      cell.classList.remove(`ag-drag-${barType}`)\n      cell.classList.add('ag-cell-transform')\n      const valueName = barType === 'bottom' ? 'translateX' : 'translateY'\n      cell.style.transform = `${valueName}(${move}px)`\n    }\n  }\n\n  ContentState.prototype.switchTableData = function () {\n    const { barType, index, curIndex, tableId, offset } = this.dragInfo\n    const table = this.getBlock(tableId)\n    const tHead = table.children[0]\n    const tBody = table.children[1]\n    const rows = [tHead.children[0], ...(tBody ? tBody.children : [])]\n    let i\n\n    if (index !== curIndex) {\n      // Cursor in the same cell.\n      const { start, end } = this.cursor\n      let key = null\n      if (barType === 'bottom') {\n        for (const row of rows) {\n          const isCursorCell = row.children[index].children[0].key === start.key\n          const { text } = row.children[index].children[0]\n          const { align } = row.children[index]\n          if (offset > 0) {\n            for (i = index; i < curIndex; i++) {\n              row.children[i].children[0].text = row.children[i + 1].children[0].text\n              row.children[i].align = row.children[i + 1].align\n            }\n            row.children[curIndex].children[0].text = text\n            row.children[curIndex].align = align\n          } else {\n            for (i = index; i > curIndex; i--) {\n              row.children[i].children[0].text = row.children[i - 1].children[0].text\n              row.children[i].align = row.children[i - 1].align\n            }\n            row.children[curIndex].children[0].text = text\n            row.children[curIndex].align = align\n          }\n          if (isCursorCell) {\n            key = row.children[curIndex].children[0].key\n          }\n        }\n      } else {\n        let column = null\n        const temp = rows[index].children.map((cell, i) => {\n          if (cell.children[0].key === start.key) {\n            column = i\n          }\n          return cell.children[0].text\n        })\n        if (offset > 0) {\n          for (i = index; i < curIndex; i++) {\n            rows[i].children.forEach((cell, ii) => {\n              cell.children[0].text = rows[i + 1].children[ii].children[0].text\n            })\n          }\n          rows[curIndex].children.forEach((cell, i) => {\n            if (i === column) {\n              key = cell.children[0].key\n            }\n            cell.children[0].text = temp[i]\n          })\n        } else {\n          for (i = index; i > curIndex; i--) {\n            rows[i].children.forEach((cell, ii) => {\n              cell.children[0].text = rows[i - 1].children[ii].children[0].text\n            })\n          }\n          rows[curIndex].children.forEach((cell, i) => {\n            if (i === column) {\n              key = cell.children[0].key\n            }\n            cell.children[0].text = temp[i]\n          })\n        }\n      }\n      if (key) {\n        this.cursor = {\n          start: {\n            key,\n            offset: start.offset\n          },\n          end: {\n            key,\n            offset: end.offset\n          }\n        }\n        return this.singleRender(table)\n      } else {\n        return this.partialRender()\n      }\n    }\n  }\n\n  ContentState.prototype.resetDragTableBar = function () {\n    this.dragInfo = null\n    this.isDragTableBar = false\n  }\n}\n\nexport default tableDragBarCtrl\n","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/contentState/tableBlockCtrl.js",["1134","1135"],"import { isLengthEven, getParagraphReference } from '../utils'\n\nconst TABLE_BLOCK_REG = /^\\|.*?(\\\\*)\\|.*?(\\\\*)\\|/\n\nconst tableBlockCtrl = ContentState => {\n  ContentState.prototype.createTableInFigure = function ({ rows, columns }, tableContents = []) {\n    const table = this.createBlock('table', {\n      row: rows - 1, // zero base\n      column: columns - 1\n    })\n    const tHead = this.createBlock('thead')\n    const tBody = this.createBlock('tbody')\n\n    let i\n    let j\n    for (i = 0; i < rows; i++) {\n      const rowBlock = this.createBlock('tr')\n      i === 0 ? this.appendChild(tHead, rowBlock) : this.appendChild(tBody, rowBlock)\n      const rowContents = tableContents[i]\n      for (j = 0; j < columns; j++) {\n        const cell = this.createBlock(i === 0 ? 'th' : 'td', {\n          align: rowContents ? rowContents[j].align : '',\n          column: j\n        })\n        const cellContent = this.createBlock('span', {\n          text: rowContents ? rowContents[j].text : '',\n          functionType: 'cellContent'\n        })\n\n        this.appendChild(cell, cellContent)\n        this.appendChild(rowBlock, cell)\n      }\n    }\n\n    this.appendChild(table, tHead)\n    if (tBody.children.length) {\n      this.appendChild(table, tBody)\n    }\n\n    return table\n  }\n\n  ContentState.prototype.createFigure = function ({ rows, columns }) {\n    const { end } = this.cursor\n    const table = this.createTableInFigure({ rows, columns })\n    const figureBlock = this.createBlock('figure', {\n      functionType: 'table'\n    })\n    const endBlock = this.getBlock(end.key)\n    const anchor = this.getAnchor(endBlock)\n\n    if (!anchor) {\n      return\n    }\n\n    this.insertAfter(figureBlock, anchor)\n    if (/p|h\\d/.test(anchor.type) && !endBlock.text) {\n      this.removeBlock(anchor)\n    }\n    this.appendChild(figureBlock, table)\n    const { key } = this.firstInDescendant(table) // fist cell key in thead\n    const offset = 0\n    this.cursor = {\n      start: { key, offset },\n      end: { key, offset }\n    }\n    this.partialRender()\n  }\n\n  ContentState.prototype.createTable = function (tableChecker) {\n    this.createFigure(tableChecker)\n\n    this.muya.dispatchSelectionChange()\n    this.muya.dispatchSelectionFormats()\n    this.muya.dispatchChange()\n  }\n\n  ContentState.prototype.initTable = function (block) {\n    const { text } = block.children[0]\n    const rowHeader = []\n    const len = text.length\n    let i\n    for (i = 0; i < len; i++) {\n      const char = text[i]\n      if (/^[^|]$/.test(char)) {\n        rowHeader[rowHeader.length - 1] += char\n      }\n      if (/\\\\/.test(char)) {\n        rowHeader[rowHeader.length - 1] += text[++i]\n      }\n      if (/\\|/.test(char) && i !== len - 1) {\n        rowHeader.push('')\n      }\n    }\n\n    const columns = rowHeader.length\n    const rows = 2\n\n    const table = this.createTableInFigure({ rows, columns }, [rowHeader.map(text => ({ text, align: '' }))])\n\n    block.type = 'figure'\n    block.text = ''\n    block.children = []\n    block.functionType = 'table'\n    this.appendChild(block, table)\n\n    return this.firstInDescendant(table.children[1]) // first cell content in tbody\n  }\n\n  ContentState.prototype.tableToolBarClick = function (type) {\n    const { start: { key } } = this.cursor\n    const block = this.getBlock(key)\n    const parentBlock = this.getParent(block)\n    if (block.functionType !== 'cellContent') {\n      throw new Error('table is not active')\n    }\n    const { column, align } = parentBlock\n    const table = this.closest(block, 'table')\n    const figure = this.getBlock(table.parent)\n\n    switch (type) {\n      case 'left':\n      case 'center':\n      case 'right': {\n        const newAlign = align === type ? '' : type\n        table.children.forEach(rowContainer => {\n          rowContainer.children.forEach(row => {\n            row.children[column].align = newAlign\n          })\n        })\n        this.muya.eventCenter.dispatch('stateChange')\n        this.partialRender()\n        break\n      }\n      case 'delete': {\n        const newLine = this.createBlock('span')\n        figure.children = []\n        this.appendChild(figure, newLine)\n        figure.type = 'p'\n        figure.text = ''\n        const key = newLine.key\n        const offset = 0\n        this.cursor = {\n          start: { key, offset },\n          end: { key, offset }\n        }\n        this.muya.eventCenter.dispatch('stateChange')\n        this.partialRender()\n        break\n      }\n      case 'table': {\n        const { eventCenter } = this.muya\n        const figureKey = figure.key\n        const tableEle = document.querySelector(`#${figureKey} [data-label=table]`)\n        const { row = 1, column = 1 } = table // zero base\n\n        const handler = (row, column) => {\n          const { row: oldRow, column: oldColumn } = table\n          let tBody = table.children[1]\n          const tHead = table.children[0]\n          const headerRow = tHead.children[0]\n          const bodyRows = tBody ? tBody.children : []\n          let i\n          if (column > oldColumn) {\n            for (i = oldColumn + 1; i <= column; i++) {\n              const th = this.createBlock('th', {\n                column: i,\n                align: ''\n              })\n              const thContent = this.createBlock('span', {\n                functionType: 'cellContent'\n              })\n              this.appendChild(th, thContent)\n              this.appendChild(headerRow, th)\n              bodyRows.forEach(bodyRow => {\n                const td = this.createBlock('td', {\n                  column: i,\n                  align: ''\n                })\n\n                const tdContent = this.createBlock('span', {\n                  functionType: 'cellContent'\n                })\n                this.appendChild(td, tdContent)\n                this.appendChild(bodyRow, td)\n              })\n            }\n          } else if (column < oldColumn) {\n            const rows = [headerRow, ...bodyRows]\n            rows.forEach(row => {\n              while (row.children.length > column + 1) {\n                const lastChild = row.children[row.children.length - 1]\n                this.removeBlock(lastChild)\n              }\n            })\n          }\n\n          if (row < oldRow) {\n            while (tBody.children.length > row) {\n              const lastRow = tBody.children[tBody.children.length - 1]\n              this.removeBlock(lastRow)\n            }\n            if (tBody.children.length === 0) {\n              this.removeBlock(tBody)\n            }\n          } else if (row > oldRow) {\n            if (!tBody) {\n              tBody = this.createBlock('tbody')\n              this.appendChild(table, tBody)\n            }\n            const oneHeaderRow = tHead.children[0]\n            for (i = oldRow + 1; i <= row; i++) {\n              const bodyRow = this.createRow(oneHeaderRow, false)\n\n              this.appendChild(tBody, bodyRow)\n            }\n          }\n\n          Object.assign(table, { row, column })\n\n          const cursorBlock = this.firstInDescendant(headerRow)\n          const key = cursorBlock.key\n          const offset = cursorBlock.text.length\n          this.cursor = {\n            start: { key, offset },\n            end: { key, offset }\n          }\n          this.muya.eventCenter.dispatch('stateChange')\n          this.partialRender()\n        }\n\n        const reference = getParagraphReference(tableEle, tableEle.id)\n        eventCenter.dispatch('muya-table-picker', { row, column }, reference, handler.bind(this))\n      }\n    }\n  }\n\n  // insert/remove row/column\n  ContentState.prototype.editTable = function ({ location, action, target }, cellContentKey) {\n    let block\n    let start\n    let end\n    if (cellContentKey) {\n      block = this.getBlock(cellContentKey)\n    } else {\n      ({ start, end } = this.cursor)\n      if (start.key !== end.key) {\n        throw new Error('Cursor is not in one block, can not editTable')\n      }\n\n      block = this.getBlock(start.key)\n    }\n\n    if (block.functionType !== 'cellContent') {\n      throw new Error('Cursor is not in table block, so you can not insert/edit row/column')\n    }\n\n    const cellBlock = this.getParent(block)\n    const currentRow = this.getParent(cellBlock)\n    const table = this.closest(block, 'table')\n    const thead = table.children[0]\n    const tbody = table.children[1]\n    const columnIndex = currentRow.children.indexOf(cellBlock)\n    // const rowIndex = rowContainer.type === 'thead' ? 0 : tbody.children.indexOf(currentRow) + 1\n\n    let cursorBlock\n\n    if (target === 'row') {\n      if (action === 'insert') {\n        const newRow = (location === 'previous' && cellBlock.type === 'th')\n          ? this.createRow(currentRow, true)\n          : this.createRow(currentRow, false)\n        if (location === 'previous') {\n          this.insertBefore(newRow, currentRow)\n          if (cellBlock.type === 'th') {\n            this.removeBlock(currentRow)\n            currentRow.children.forEach(cell => (cell.type = 'td'))\n            const firstRow = tbody.children[0]\n            this.insertBefore(currentRow, firstRow)\n          }\n        } else {\n          if (cellBlock.type === 'th') {\n            const firstRow = tbody.children[0]\n            this.insertBefore(newRow, firstRow)\n          } else {\n            this.insertAfter(newRow, currentRow)\n          }\n        }\n        cursorBlock = newRow.children[columnIndex].children[0]\n        // handle remove row\n      } else {\n        if (location === 'previous') {\n          if (cellBlock.type === 'th') return\n          if (!currentRow.preSibling) {\n            const headRow = thead.children[0]\n            if (!currentRow.nextSibling) return\n            this.removeBlock(headRow)\n            this.removeBlock(currentRow)\n            currentRow.children.forEach(cell => (cell.type = 'th'))\n            this.appendChild(thead, currentRow)\n          } else {\n            const preRow = this.getPreSibling(currentRow)\n            this.removeBlock(preRow)\n          }\n        } else if (location === 'current') {\n          if (cellBlock.type === 'th' && tbody.children.length >= 2) {\n            const firstRow = tbody.children[0]\n            this.removeBlock(currentRow)\n            this.removeBlock(firstRow)\n            this.appendChild(thead, firstRow)\n            firstRow.children.forEach(cell => (cell.type = 'th'))\n            cursorBlock = firstRow.children[columnIndex].children[0]\n          }\n          if (cellBlock.type === 'td' && (currentRow.preSibling || currentRow.nextSibling)) {\n            cursorBlock = (this.getNextSibling(currentRow) || this.getPreSibling(currentRow)).children[columnIndex].children[0]\n            this.removeBlock(currentRow)\n          }\n        } else {\n          if (cellBlock.type === 'th') {\n            if (tbody.children.length >= 2) {\n              const firstRow = tbody.children[0]\n              this.removeBlock(firstRow)\n            } else {\n              return\n            }\n          } else {\n            const nextRow = this.getNextSibling(currentRow)\n            if (nextRow) {\n              this.removeBlock(nextRow)\n            }\n          }\n        }\n      }\n    } else if (target === 'column') {\n      if (action === 'insert') {\n        [...thead.children, ...tbody.children].forEach(tableRow => {\n          const targetCell = tableRow.children[columnIndex]\n          const cell = this.createBlock(targetCell.type, {\n            align: ''\n          })\n          const cellContent = this.createBlock('span', {\n            functionType: 'cellContent'\n          })\n          this.appendChild(cell, cellContent)\n          if (location === 'left') {\n            this.insertBefore(cell, targetCell)\n          } else {\n            this.insertAfter(cell, targetCell)\n          }\n          tableRow.children.forEach((cell, i) => {\n            cell.column = i\n          })\n        })\n        cursorBlock = location === 'left' ? this.getPreSibling(cellBlock).children[0] : this.getNextSibling(cellBlock).children[0]\n        // handle remove column\n      } else {\n        if (currentRow.children.length <= 2) return\n        [...thead.children, ...tbody.children].forEach(tableRow => {\n          const targetCell = tableRow.children[columnIndex]\n          const removeCell = location === 'left'\n            ? this.getPreSibling(targetCell)\n            : (location === 'current' ? targetCell : this.getNextSibling(targetCell))\n          if (removeCell === cellBlock) {\n            cursorBlock = this.findNextBlockInLocation(block)\n          }\n\n          if (removeCell) this.removeBlock(removeCell)\n          tableRow.children.forEach((cell, i) => {\n            cell.column = i\n          })\n        })\n      }\n    }\n\n    const newColum = thead.children[0].children.length - 1\n    const newRow = thead.children.length + tbody.children.length - 1\n    Object.assign(table, { row: newRow, column: newColum })\n\n    if (cursorBlock) {\n      const { key } = cursorBlock\n      const offset = 0\n      this.cursor = { start: { key, offset }, end: { key, offset } }\n    } else {\n      this.cursor = { start, end }\n    }\n\n    this.partialRender()\n    this.muya.eventCenter.dispatch('stateChange')\n  }\n\n  ContentState.prototype.getTableBlock = function () {\n    const { start, end } = this.cursor\n    const startBlock = this.getBlock(start.key)\n    const endBlock = this.getBlock(end.key)\n    const startParents = this.getParents(startBlock)\n    const endParents = this.getParents(endBlock)\n    const affiliation = startParents\n      .filter(p => endParents.includes(p))\n\n    if (affiliation.length) {\n      const figure = affiliation.find(p => p.type === 'figure')\n      return figure\n    }\n  }\n\n  ContentState.prototype.tableBlockUpdate = function (block) {\n    const { type } = block\n    if (type !== 'p') return false\n    const { text } = block.children[0]\n    const match = TABLE_BLOCK_REG.exec(text)\n    return (match && isLengthEven(match[1]) && isLengthEven(match[2])) ? this.initTable(block) : false\n  }\n}\n\nexport default tableBlockCtrl\n","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/contentState/tableSelectCellsCtrl.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/contentState/codeBlockCtrl.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/contentState/deleteCtrl.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/contentState/updateCtrl.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/contentState/backspaceCtrl.js",["1136","1137","1138","1139","1140","1141","1142","1143"],"import selection from '../selection'\nimport { findNearestParagraph, findOutMostParagraph } from '../selection/dom'\nimport { tokenizer, generator } from '../parser/'\nimport { getImageInfo } from '../utils/getImageInfo'\n\nconst backspaceCtrl = ContentState => {\n  ContentState.prototype.checkBackspaceCase = function () {\n    const node = selection.getSelectionStart()\n    const paragraph = findNearestParagraph(node)\n    const outMostParagraph = findOutMostParagraph(node)\n    let block = this.getBlock(paragraph.id)\n    if (block.type === 'span' && block.preSibling) {\n      return false\n    }\n    if (block.type === 'span') {\n      block = this.getParent(block)\n    }\n    const preBlock = this.getPreSibling(block)\n    const outBlock = this.findOutMostBlock(block)\n    const parent = this.getParent(block)\n\n    const { left: outLeft } = selection.getCaretOffsets(outMostParagraph)\n    const { left: inLeft } = selection.getCaretOffsets(paragraph)\n\n    if (\n      (parent && parent.type === 'li' && inLeft === 0 && this.isFirstChild(block)) ||\n      (parent && parent.type === 'li' && inLeft === 0 && parent.listItemType === 'task' && preBlock.type === 'input') // handle task item\n    ) {\n      if (this.isOnlyChild(parent)) {\n        /**\n         * <ul>\n         *   <li>\n         *     <p>|text</p>\n         *     <p>maybe has other paragraph</p>\n         *   </li>\n         * <ul>\n         * ===>\n         * <p>|text</p>\n         * <p>maybe has other paragraph</p>\n         */\n        return { type: 'LI', info: 'REPLACEMENT' }\n      } else if (this.isFirstChild(parent)) {\n        /**\n         * <ul>\n         *   <li>\n         *     <p>|text</p>\n         *     <p>maybe has other paragraph</p>\n         *   </li>\n         *   <li>\n         *     <p>other list item</p>\n         *   </li>\n         * <ul>\n         * ===>\n         * <p>|text</p>\n         * <p>maybe has other paragraph</p>\n         * <ul>\n         *   <li>\n         *     <p>other list item</p>\n         *   </li>\n         * <ul>\n         */\n        return { type: 'LI', info: 'REMOVE_INSERT_BEFORE' }\n      } else {\n        /**\n         * <ul>\n         *   <li>\n         *     <p>other list item</p>\n         *   </li>\n         *   <li>\n         *     <p>|text</p>\n         *     <p>maybe has other paragraph</p>\n         *   </li>\n         *   <li>\n         *     <p>other list item</p>\n         *   </li>\n         * <ul>\n         * ===>\n         * <ul>\n         *   <li>\n         *     <p>other list item</p>\n         *     <p>|text</p>\n         *     <p>maybe has other paragraph</p>\n         *   </li>\n         *   <li>\n         *     <p>other list item</p>\n         *   </li>\n         * <ul>\n         */\n        return { type: 'LI', info: 'INSERT_PRE_LIST_ITEM' }\n      }\n    }\n    if (parent && parent.type === 'blockquote' && inLeft === 0) {\n      if (this.isOnlyChild(block)) {\n        return { type: 'BLOCKQUOTE', info: 'REPLACEMENT' }\n      } else if (this.isFirstChild(block)) {\n        return { type: 'BLOCKQUOTE', info: 'INSERT_BEFORE' }\n      }\n    }\n    if (!outBlock.preSibling && outLeft === 0) {\n      return { type: 'STOP' }\n    }\n  }\n\n  ContentState.prototype.docBackspaceHandler = function (event) {\n    // handle delete selected image\n    if (this.selectedImage) {\n      event.preventDefault()\n      return this.deleteImage(this.selectedImage)\n    }\n    if (this.selectedTableCells) {\n      event.preventDefault()\n      return this.deleteSelectedTableCells()\n    }\n  }\n\n  ContentState.prototype.backspaceHandler = function (event) {\n    const { start, end } = selection.getCursorRange()\n\n    if (!start || !end) {\n      return\n    }\n\n    // handle delete selected image\n    if (this.selectedImage) {\n      event.preventDefault()\n      return this.deleteImage(this.selectedImage)\n    }\n\n    // Handle select all content.\n    if (this.isSelectAll()) {\n      event.preventDefault()\n      this.blocks = [this.createBlockP()]\n      this.init()\n\n      this.render()\n\n      this.muya.dispatchSelectionChange()\n      this.muya.dispatchSelectionFormats()\n      return this.muya.dispatchChange()\n    }\n\n    const startBlock = this.getBlock(start.key)\n    const endBlock = this.getBlock(end.key)\n    const maybeLastRow = this.getParent(endBlock)\n    const startOutmostBlock = this.findOutMostBlock(startBlock)\n    const endOutmostBlock = this.findOutMostBlock(endBlock)\n    // Just for fix delete the last `#` or all the atx heading cause error @fixme\n    if (\n      start.key === end.key &&\n      startBlock.type === 'span' &&\n      startBlock.functionType === 'atxLine'\n    ) {\n      if (\n        start.offset === 0 && end.offset === startBlock.text.length ||\n        start.offset === end.offset && start.offset === 1 && startBlock.text === '#'\n      ) {\n        event.preventDefault()\n        startBlock.text = ''\n        this.cursor = {\n          start: { key: start.key, offset: 0 },\n          end: { key: end.key, offset: 0 }\n        }\n        this.updateToParagraph(this.getParent(startBlock), startBlock)\n        return this.partialRender()\n      }\n    }\n    // fix: #897\n    const { text } = startBlock\n    const tokens = tokenizer(text, {\n      options: this.muya.options\n    })\n    let needRender = false\n    let preToken = null\n    for (const token of tokens) {\n      // handle delete the second $ in inline_math.\n      if (\n        token.range.end === start.offset &&\n        token.type === 'inline_math'\n      ) {\n        needRender = true\n        token.raw = token.raw.substr(0, token.raw.length - 1)\n        break\n      }\n      // handle pre token is a <ruby> html tag, need preventdefault.\n      if (\n        token.range.start + 1 === start.offset &&\n        preToken &&\n        preToken.type === 'html_tag' &&\n        preToken.tag === 'ruby'\n      ) {\n        needRender = true\n        token.raw = token.raw.substr(1)\n        break\n      }\n      preToken = token\n    }\n    if (needRender) {\n      startBlock.text = generator(tokens)\n      event.preventDefault()\n      start.offset--\n      end.offset--\n      this.cursor = {\n        start,\n        end\n      }\n      return this.partialRender()\n    }\n\n    // fix bug when the first block is table, these two ways will cause bugs.\n    // 1. one paragraph bollow table, selectAll, press backspace.\n    // 2. select table from the first cell to the last cell, press backsapce.\n    const maybeCell = this.getParent(startBlock)\n    if (/th/.test(maybeCell.type) && start.offset === 0 && !maybeCell.preSibling) {\n      if (\n        end.offset === endBlock.text.length &&\n        startOutmostBlock === endOutmostBlock &&\n        !endBlock.nextSibling && !maybeLastRow.nextSibling ||\n        startOutmostBlock !== endOutmostBlock\n      ) {\n        event.preventDefault()\n        // need remove the figure block.\n        const figureBlock = this.getBlock(this.closest(startBlock, 'figure'))\n        // if table is the only block, need create a p block.\n        const p = this.createBlockP(endBlock.text.substring(end.offset))\n        this.insertBefore(p, figureBlock)\n        const cursorBlock = p.children[0]\n        if (startOutmostBlock !== endOutmostBlock) {\n          this.removeBlocks(figureBlock, endBlock)\n        }\n\n        this.removeBlock(figureBlock)\n        const { key } = cursorBlock\n        const offset = 0\n        this.cursor = {\n          start: { key, offset },\n          end: { key, offset }\n        }\n        return this.render()\n      }\n    }\n\n    // Fixed #1456 existed bugs `Select one cell and press backspace will cause bug`\n    if (startBlock.functionType === 'cellContent' && this.cursor.start.offset === 0 && this.cursor.end.offset !== 0 && this.cursor.end.offset === startBlock.text.length) {\n      event.preventDefault()\n      event.stopPropagation()\n      startBlock.text = ''\n      const { key } = startBlock\n      const offset = 0\n      this.cursor = {\n        start: { key, offset },\n        end: { key, offset }\n      }\n\n      return this.singleRender(startBlock)\n    }\n\n    // If select multiple paragraph or multiple characters in one paragraph, just let\n    // inputCtrl to handle this case.\n    if (start.key !== end.key || start.offset !== end.offset) {\n      return\n    }\n\n    const node = selection.getSelectionStart()\n    const parentNode = node && node.nodeType === 1 ? node.parentNode : null\n    const paragraph = findNearestParagraph(node)\n    const id = paragraph.id\n    let block = this.getBlock(id)\n    let parent = this.getBlock(block.parent)\n    const preBlock = this.findPreBlockInLocation(block)\n    const { left, right } = selection.getCaretOffsets(paragraph)\n    const inlineDegrade = this.checkBackspaceCase()\n    // Handle backspace when the previous is an inline image.\n    if (parentNode && parentNode.classList.contains('ag-inline-image')) {\n      if (selection.getCaretOffsets(node).left === 0) {\n        event.preventDefault()\n        event.stopPropagation()\n        const imageInfo = getImageInfo(parentNode)\n        return this.deleteImage(imageInfo)\n      }\n      if (selection.getCaretOffsets(node).left === 1 && right === 0) {\n        event.stopPropagation()\n        event.preventDefault()\n        const key = startBlock.key\n        const text = startBlock.text\n\n        startBlock.text = text.substring(0, start.offset - 1) + text.substring(start.offset)\n        const offset = start.offset - 1\n        this.cursor = {\n          start: { key, offset },\n          end: { key, offset }\n        }\n        return this.singleRender(startBlock)\n      }\n    }\n\n    // handle backspace when cursor at the end of inline image.\n    if (node.classList.contains('ag-image-container')) {\n      const imageWrapper = node.parentNode\n      const imageInfo = getImageInfo(imageWrapper)\n      if (start.offset === imageInfo.token.range.end) {\n        event.preventDefault()\n        event.stopPropagation()\n        return this.selectImage(imageInfo)\n      }\n    }\n\n    // Fix issue #1218\n    if (startBlock.functionType === 'cellContent' && /<br\\/>.{1}$/.test(startBlock.text)) {\n      event.preventDefault()\n      event.stopPropagation()\n\n      const { text } = startBlock\n      startBlock.text = text.substring(0, text.length - 1)\n      const key = startBlock.key\n      const offset = startBlock.text.length\n\n      this.cursor = {\n        start: { key, offset },\n        end: { key, offset }\n      }\n      return this.singleRender(startBlock)\n    }\n\n    // Fix delete the last character in table cell, the default action will delete the cell content if not preventDefault.\n    if (startBlock.functionType === 'cellContent' && left === 1 && right === 0) {\n      event.stopPropagation()\n      event.preventDefault()\n      startBlock.text = ''\n      const { key } = startBlock\n      const offset = 0\n      this.cursor = {\n        start: { key, offset },\n        end: { key, offset }\n      }\n\n      return this.singleRender(startBlock)\n    }\n\n    const tableHasContent = table => {\n      const tHead = table.children[0]\n      const tBody = table.children[1]\n      const tHeadHasContent = tHead.children[0].children.some(th => th.children[0].text.trim())\n      const tBodyHasContent = tBody.children.some(row => row.children.some(td => td.children[0].text.trim()))\n      return tHeadHasContent || tBodyHasContent\n    }\n\n    if (\n      block.type === 'span' &&\n      block.functionType === 'paragraphContent' &&\n      left === 0 &&\n      preBlock &&\n      preBlock.functionType === 'footnoteInput'\n    ) {\n      event.preventDefault()\n      event.stopPropagation()\n      if (!parent.nextSibling) {\n        const pBlock = this.createBlockP(block.text)\n        const figureBlock = this.closest(block, 'figure')\n        this.insertBefore(pBlock, figureBlock)\n        this.removeBlock(figureBlock)\n        const key = pBlock.children[0].key\n        const offset = 0\n        this.cursor = {\n          start: { key, offset },\n          end: { key, offset }\n        }\n\n        this.partialRender()\n      }\n    } else if (\n      block.type === 'span' &&\n      block.functionType === 'codeContent' &&\n      left === 0 &&\n      !block.preSibling\n    ) {\n      event.preventDefault()\n      event.stopPropagation()\n      if (\n        !block.nextSibling\n      ) {\n        const preBlock = this.getParent(parent)\n        const pBlock = this.createBlock('p')\n        const lineBlock = this.createBlock('span', { text: block.text })\n        const key = lineBlock.key\n        const offset = 0\n        this.appendChild(pBlock, lineBlock)\n        let referenceBlock = null\n        switch (preBlock.functionType) {\n          case 'fencecode':\n          case 'indentcode':\n          case 'frontmatter':\n            referenceBlock = preBlock\n            break\n          case 'multiplemath':\n          case 'flowchart':\n          case 'mermaid':\n          case 'sequence':\n          case 'vega-lite':\n          case 'html':\n            referenceBlock = this.getParent(preBlock)\n            break\n        }\n        this.insertBefore(pBlock, referenceBlock)\n        this.removeBlock(referenceBlock)\n\n        this.cursor = {\n          start: { key, offset },\n          end: { key, offset }\n        }\n        this.partialRender()\n      }\n    } else if (left === 0 && block.functionType === 'cellContent') {\n      event.preventDefault()\n      event.stopPropagation()\n      const table = this.closest(block, 'table')\n      const figure = this.closest(table, 'figure')\n      const hasContent = tableHasContent(table)\n      let key\n      let offset\n\n      if ((!preBlock || preBlock.functionType !== 'cellContent') && !hasContent) {\n        const paragraphContent = this.createBlock('span')\n        delete figure.functionType\n        figure.children = []\n        this.appendChild(figure, paragraphContent)\n        figure.text = ''\n        figure.type = 'p'\n        key = paragraphContent.key\n        offset = 0\n      } else if (preBlock) {\n        key = preBlock.key\n        offset = preBlock.text.length\n      }\n\n      if (key !== undefined && offset !== undefined) {\n        this.cursor = {\n          start: { key, offset },\n          end: { key, offset }\n        }\n\n        this.partialRender()\n      }\n    } else if (inlineDegrade) {\n      event.preventDefault()\n      if (block.type === 'span') {\n        block = this.getParent(block)\n        parent = this.getParent(parent)\n      }\n\n      switch (inlineDegrade.type) {\n        case 'STOP': // Cursor at begin of article and nothing need to do\n          break\n        case 'LI': {\n          if (inlineDegrade.info === 'REPLACEMENT') {\n            const children = parent.children\n            const grandpa = this.getBlock(parent.parent)\n            if (children[0].type === 'input') {\n              this.removeBlock(children[0])\n            }\n            children.forEach(child => {\n              this.insertBefore(child, grandpa)\n            })\n            this.removeBlock(grandpa)\n          } else if (inlineDegrade.info === 'REMOVE_INSERT_BEFORE') {\n            const children = parent.children\n            const grandpa = this.getBlock(parent.parent)\n            if (children[0].type === 'input') {\n              this.removeBlock(children[0])\n            }\n            children.forEach(child => {\n              this.insertBefore(child, grandpa)\n            })\n            this.removeBlock(parent)\n          } else if (inlineDegrade.info === 'INSERT_PRE_LIST_ITEM') {\n            const parPre = this.getBlock(parent.preSibling)\n            const children = parent.children\n            if (children[0].type === 'input') {\n              this.removeBlock(children[0])\n            }\n            children.forEach(child => {\n              this.appendChild(parPre, child)\n            })\n            this.removeBlock(parent)\n          }\n          break\n        }\n        case 'BLOCKQUOTE':\n          if (inlineDegrade.info === 'REPLACEMENT') {\n            this.insertBefore(block, parent)\n            this.removeBlock(parent)\n          } else if (inlineDegrade.info === 'INSERT_BEFORE') {\n            this.removeBlock(block)\n            this.insertBefore(block, parent)\n          }\n          break\n      }\n\n      const key = block.type === 'p' ? block.children[0].key : block.key\n      const offset = 0\n      this.cursor = {\n        start: { key, offset },\n        end: { key, offset }\n      }\n\n      if (inlineDegrade.type !== 'STOP') {\n        this.partialRender()\n      }\n    } else if (left === 0 && preBlock) {\n      event.preventDefault()\n      const { text } = block\n      const key = preBlock.key\n      const offset = preBlock.text.length\n      preBlock.text += text\n      // If block is a line block and its parent paragraph only has one text line,\n      // also need to remove the paragrah\n      if (this.isOnlyChild(block) && block.type === 'span') {\n        this.removeBlock(parent)\n      } else if (block.functionType !== 'languageInput' && block.functionType !== 'footnoteInput') {\n        this.removeBlock(block)\n      }\n\n      this.cursor = {\n        start: { key, offset },\n        end: { key, offset }\n      }\n      let needRenderAll = false\n\n      if (this.isCollapse() && preBlock.type === 'span' && preBlock.functionType === 'paragraphContent') {\n        this.checkInlineUpdate(preBlock)\n        needRenderAll = true\n      }\n\n      needRenderAll ? this.render() : this.partialRender()\n    }\n  }\n}\n\nexport default backspaceCtrl\n","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/contentState/enterCtrl.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/index.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/utils/turndownService.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/prism/index.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/utils/cumputeCheckBoxStatus.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/utils/getParentCheckBox.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/rules.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/index.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/marked/options.js",["1144"],"export default {\n  baseUrl: null,\n  breaks: false,\n  gfm: true,\n  headerIds: true,\n  headerPrefix: '',\n  highlight: null,\n  mathRenderer: null,\n  emojiRenderer: null,\n  tocRenderer: null,\n  langPrefix: 'language-',\n  mangle: true,\n  pedantic: false,\n  renderer: null, // new Renderer(),\n  silent: false,\n  smartLists: false,\n  smartypants: false,\n  xhtml: false,\n  disableInline: false,\n\n  // NOTE: sanitize and sanitizer are deprecated since version 0.7.0, should not be used and will be removed in the future.\n  sanitize: false,\n  sanitizer: null,\n\n  // Markdown extensions:\n  // TODO: We set whether to support `emoji`, `math`, `frontMatter` default value to `true`\n  // After we add user setting, we maybe set math and frontMatter default value to false.\n  // User need to enable them in the user setting.\n  emoji: true,\n  math: true,\n  frontMatter: true,\n  superSubScript: false,\n  footnote: false,\n  isGitlabCompatibilityEnabled: false,\n\n  isHtmlEnabled: true\n}\n","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/marked/parser.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/marked/lexer.js",["1145"],"import { normal, gfm, pedantic } from './blockRules'\nimport options from './options'\nimport { splitCells, rtrim, getUniqueId } from './utils'\n\n/**\n * Block Lexer\n */\n\nfunction Lexer (opts) {\n  this.tokens = []\n  this.tokens.links = Object.create(null)\n  this.tokens.footnotes = Object.create(null)\n  this.footnoteOrder = 0\n  this.options = Object.assign({}, options, opts)\n  this.rules = normal\n\n  if (this.options.pedantic) {\n    this.rules = pedantic\n  } else if (this.options.gfm) {\n    this.rules = gfm\n  }\n}\n\n/**\n * Preprocessing\n */\n\nLexer.prototype.lex = function (src) {\n  src = src\n    .replace(/\\r\\n|\\r/g, '\\n')\n    .replace(/\\t/g, '    ')\n  this.checkFrontmatter = true\n  this.footnoteOrder = 0\n  this.token(src, true)\n\n  // Move footnote token to the end of tokens.\n  const { tokens } = this\n  const hasNoFootnoteTokens = []\n  const footnoteTokens = []\n  let isInFootnote = false\n  for (const token of tokens) {\n    const { type } = token\n    if (type === 'footnote_start') {\n      isInFootnote = true\n      footnoteTokens.push(token)\n    } else if (type === 'footnote_end') {\n      isInFootnote = false\n      footnoteTokens.push(token)\n    } else if (isInFootnote) {\n      footnoteTokens.push(token)\n    } else {\n      hasNoFootnoteTokens.push(token)\n    }\n  }\n\n  const result = [...hasNoFootnoteTokens, ...footnoteTokens]\n  result.links = tokens.links\n  result.footnotes = tokens.footnotes\n  return result\n}\n\n/**\n * Lexing\n */\n\nLexer.prototype.token = function (src, top) {\n  const {\n    footnote,\n    frontMatter,\n    isGitlabCompatibilityEnabled,\n    math\n  } = this.options\n  src = src.replace(/^ +$/gm, '')\n\n  let loose\n  let cap\n  let bull\n  let b\n  let item\n  let space\n  let i\n  let tag\n  let l\n\n  // Only check front matter at the begining of a markdown file.\n  // Please see note in \"blockquote\" why we need \"checkFrontmatter\" and \"top\".\n  if (frontMatter) {\n    cap = this.rules.frontmatter.exec(src)\n    if (this.checkFrontmatter && top && cap) {\n      src = src.substring(cap[0].length)\n      let lang\n      let style\n      let text\n      if (cap[1]) {\n        lang = 'yaml'\n        style = '-'\n        text = cap[1]\n      } else if (cap[2]) {\n        lang = 'toml'\n        style = '+'\n        text = cap[2]\n      } else if (cap[3] || cap[4]) {\n        lang = 'json'\n        style = cap[3] ? ';' : '{'\n        text = cap[3] || cap[4]\n      }\n      this.tokens.push({\n        type: 'frontmatter',\n        text,\n        style,\n        lang\n      })\n    }\n    this.checkFrontmatter = false\n  }\n\n  while (src) {\n    // newline\n    cap = this.rules.newline.exec(src)\n    if (cap) {\n      src = src.substring(cap[0].length)\n      if (cap[0].length > 1) {\n        this.tokens.push({\n          type: 'space'\n        })\n      }\n    }\n\n    // code\n    // An indented code block cannot interrupt a paragraph.\n    cap = this.rules.code.exec(src)\n    if (cap) {\n      const lastToken = this.tokens[this.tokens.length - 1]\n      src = src.substring(cap[0].length)\n      if (lastToken && lastToken.type === 'paragraph') {\n        lastToken.text += `\\n${cap[0].trimRight()}`\n      } else {\n        cap = cap[0].replace(/^ {4}/gm, '')\n        this.tokens.push({\n          type: 'code',\n          codeBlockStyle: 'indented',\n          text: !this.options.pedantic\n            ? rtrim(cap, '\\n')\n            : cap\n        })\n      }\n      continue\n    }\n\n    // multiple line math\n    if (math) {\n      cap = this.rules.multiplemath.exec(src)\n      if (cap) {\n        src = src.substring(cap[0].length)\n        this.tokens.push({\n          type: 'multiplemath',\n          text: cap[1],\n          mathStyle: ''\n        })\n        continue\n      }\n\n      // match GitLab display math blocks (```math)\n      if (isGitlabCompatibilityEnabled) {\n        cap = this.rules.multiplemathGitlab.exec(src)\n        if (cap) {\n          src = src.substring(cap[0].length)\n          this.tokens.push({\n            type: 'multiplemath',\n            text: cap[2] || '',\n            mathStyle: 'gitlab'\n          })\n          continue\n        }\n      }\n    }\n\n    // footnote\n    if (footnote) {\n      cap = this.rules.footnote.exec(src)\n      if (top && cap) {\n        src = src.substring(cap[0].length)\n        const identifier = cap[1]\n        this.tokens.push({\n          type: 'footnote_start',\n          identifier\n        })\n\n        // NOTE: Order is wrong if footnote identifier 1 is behind footnote identifier 2 in text.\n        this.tokens.footnotes[identifier] = {\n          order: ++this.footnoteOrder,\n          identifier,\n          footnoteId: getUniqueId()\n        }\n\n        /* eslint-disable no-useless-escape */\n        // Remove the footnote identifer prefix. eg: `[^identifier]: `.\n        cap = cap[0].replace(/^\\[\\^[^\\^\\[\\]\\s]+?(?<!\\\\)\\]:\\s+/gm, '')\n        // Remove the four whitespace before each block of footnote.\n        cap = cap.replace(/\\n {4}(?=[^\\s])/g, '\\n')\n        /* eslint-enable no-useless-escape */\n\n        this.token(cap, top)\n\n        this.tokens.push({\n          type: 'footnote_end'\n        })\n\n        continue\n      }\n    }\n\n    // fences\n    cap = this.rules.fences.exec(src)\n    if (cap) {\n      src = src.substring(cap[0].length)\n      const raw = cap[0]\n      const text = indentCodeCompensation(raw, cap[3] || '')\n      this.tokens.push({\n        type: 'code',\n        codeBlockStyle: 'fenced',\n        lang: cap[2] ? cap[2].trim() : cap[2],\n        text\n      })\n      continue\n    }\n\n    // heading\n    cap = this.rules.heading.exec(src)\n    if (cap) {\n      src = src.substring(cap[0].length)\n      let text = cap[2] ? cap[2].trim() : ''\n\n      if (text.endsWith('#')) {\n        var trimmed = rtrim(text, '#')\n\n        if (this.options.pedantic) {\n          text = trimmed.trim()\n        } else if (!trimmed || trimmed.endsWith(' ')) {\n          // CommonMark requires space before trailing #s\n          text = trimmed.trim()\n        }\n      }\n\n      this.tokens.push({\n        type: 'heading',\n        headingStyle: 'atx',\n        depth: cap[1].length,\n        text\n      })\n      continue\n    }\n\n    // table no leading pipe (gfm)\n    cap = this.rules.nptable.exec(src)\n    if (cap) {\n      item = {\n        type: 'table',\n        header: splitCells(cap[1].replace(/^ *| *\\| *$/g, '')),\n        align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\n        cells: cap[3] ? cap[3].replace(/\\n$/, '').split('\\n') : []\n      }\n\n      if (item.header.length === item.align.length) {\n        src = src.substring(cap[0].length)\n\n        for (i = 0; i < item.align.length; i++) {\n          if (/^ *-+: *$/.test(item.align[i])) {\n            item.align[i] = 'right'\n          } else if (/^ *:-+: *$/.test(item.align[i])) {\n            item.align[i] = 'center'\n          } else if (/^ *:-+ *$/.test(item.align[i])) {\n            item.align[i] = 'left'\n          } else {\n            item.align[i] = null\n          }\n        }\n\n        for (i = 0; i < item.cells.length; i++) {\n          item.cells[i] = splitCells(item.cells[i], item.header.length)\n        }\n\n        this.tokens.push(item)\n\n        continue\n      }\n    }\n\n    // hr\n    cap = this.rules.hr.exec(src)\n    if (cap) {\n      const marker = cap[0].replace(/\\n*$/, '')\n      src = src.substring(cap[0].length)\n      this.tokens.push({\n        type: 'hr',\n        marker\n      })\n      continue\n    }\n\n    // blockquote\n    cap = this.rules.blockquote.exec(src)\n    if (cap) {\n      src = src.substring(cap[0].length)\n\n      this.tokens.push({\n        type: 'blockquote_start'\n      })\n\n      cap = cap[0].replace(/^ *> ?/gm, '')\n\n      // Pass `top` to keep the current\n      // \"toplevel\" state. This is exactly\n      // how markdown.pl works.\n      this.token(cap, top)\n\n      this.tokens.push({\n        type: 'blockquote_end'\n      })\n\n      continue\n    }\n\n    // NOTE: Complete list lexer part is a custom implementation based on an older marked.js version.\n\n    // list\n    cap = this.rules.list.exec(src)\n    if (cap) {\n      let checked\n      src = src.substring(cap[0].length)\n      bull = cap[2]\n      let isOrdered = bull.length > 1\n      this.tokens.push({\n        type: 'list_start',\n        ordered: isOrdered,\n        listType: bull.length > 1 ? 'order' : (/^( {0,3})([-*+]) \\[[xX ]\\]/.test(cap[0]) ? 'task' : 'bullet'),\n        start: isOrdered ? +(bull.slice(0, -1)) : ''\n      })\n\n      let next = false\n      let prevNext = true\n      let listItemIndices = []\n      let isTaskList = false\n\n      // Get each top-level item.\n      cap = cap[0].match(this.rules.item)\n      l = cap.length\n      i = 0\n\n      for (; i < l; i++) {\n        const itemWithBullet = cap[i]\n        item = itemWithBullet\n        let newIsTaskListItem = false\n\n        // Remove the list item's bullet so it is seen as the next token.\n        space = item.length\n        let newBull\n        item = item.replace(/^ *([*+-]|\\d+(?:\\.|\\))) {0,4}/, function (m, p1) {\n          // Get and remove list item bullet\n          newBull = p1 || bull\n          return ''\n        })\n\n        const newIsOrdered = bull.length > 1 && /\\d{1,9}/.test(newBull)\n        if (!newIsOrdered && this.options.gfm) {\n          checked = this.rules.checkbox.exec(item)\n          if (checked) {\n            checked = checked[1] === 'x' || checked[1] === 'X'\n            newIsTaskListItem = true\n\n            // Remove the list item's checkbox and adjust indentation by removing checkbox length.\n            item = item.replace(this.rules.checkbox, '')\n            space -= 4\n          } else {\n            checked = undefined\n          }\n        }\n\n        if (i === 0) {\n          isTaskList = newIsTaskListItem\n        } else if (\n          // Changing the bullet or ordered list delimiter starts a new list (CommonMark 264 and 265)\n          //   - unordered, unordered --> bull !== newBull --> new list (e.g \"-\" --> \"*\")\n          //   - ordered, ordered --> lastChar !== lastChar --> new list (e.g \".\" --> \")\")\n          //   - else --> new list (e.g. ordered --> unordered)\n          i !== 0 &&\n          (\n            (!isOrdered && !newIsOrdered && bull !== newBull) ||\n            (isOrdered && newIsOrdered && bull.slice(-1) !== newBull.slice(-1)) ||\n            (isOrdered !== newIsOrdered) ||\n            // Changing to/from task list item from/to bullet, starts a new list(work for marktext issue #870)\n            // Because we distinguish between task list and bullet list in Mark Text,\n            // the parsing here is somewhat different from the commonmark Spec,\n            // and the task list needs to be a separate list.\n            (isTaskList !== newIsTaskListItem)\n          )\n        ) {\n          this.tokens.push({\n            type: 'list_end'\n          })\n\n          // Start a new list\n          bull = newBull\n          isOrdered = newIsOrdered\n          isTaskList = newIsTaskListItem\n          this.tokens.push({\n            type: 'list_start',\n            ordered: isOrdered,\n            listType: bull.length > 1 ? 'order' : (/^( {0,3})([-*+]) \\[[xX ]\\]/.test(itemWithBullet) ? 'task' : 'bullet'),\n            start: isOrdered ? +(bull.slice(0, -1)) : ''\n          })\n        }\n\n        // Outdent whatever the\n        // list item contains. Hacky.\n        if (~item.indexOf('\\n ')) {\n          space -= item.length\n          item = !this.options.pedantic\n            ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')\n            : item.replace(/^ {1,4}/gm, '')\n        }\n\n        // Determine whether the next list item belongs here.\n        // Backpedal if it does not belong in this list.\n        if (i !== l - 1) {\n          b = this.rules.bullet.exec(cap[i + 1])[0]\n          if (bull.length > 1 ? b.length === 1\n            : (b.length > 1 || (this.options.smartLists && b !== bull))) {\n            src = cap.slice(i + 1).join('\\n') + src\n            i = l - 1\n          }\n        }\n\n        let prevItem = ''\n        if (i === 0) {\n          prevItem = item\n        } else {\n          prevItem = cap[i - 1]\n        }\n\n        // Determine whether item is loose or not. If previous item is loose\n        // this item is also loose.\n        // A list is loose if any of its constituent list items are separated by blank lines,\n        // or if any of its constituent list items directly contain two block-level elements with a blank line between them.\n        // loose = next = next || /^ *([*+-]|\\d{1,9}(?:\\.|\\)))( +\\S+\\n\\n(?!\\s*$)|\\n\\n(?!\\s*$))/.test(itemWithBullet)\n        loose = next = next || /\\n\\n(?!\\s*$)/.test(item)\n        // Check if previous line ends with a new line.\n        if (!loose && (i !== 0 || l > 1) && prevItem.length !== 0 && prevItem.charAt(prevItem.length - 1) === '\\n') {\n          loose = next = true\n        }\n\n        // A list is either loose or tight, so update previous list items but not nested list items.\n        if (next && prevNext !== next) {\n          for (const index of listItemIndices) {\n            this.tokens[index].type = 'loose_item_start'\n          }\n          listItemIndices = []\n        }\n        prevNext = next\n\n        if (!loose) {\n          listItemIndices.push(this.tokens.length)\n        }\n\n        const isOrderedListItem = /\\d/.test(bull)\n        this.tokens.push({\n          checked,\n          listItemType: bull.length > 1 ? 'order' : (isTaskList ? 'task' : 'bullet'),\n          bulletMarkerOrDelimiter: isOrderedListItem ? bull.slice(-1) : bull.charAt(0),\n          type: loose ? 'loose_item_start' : 'list_item_start'\n        })\n\n        if (/^\\s*$/.test(item)) {\n          this.tokens.push({\n            type: 'text',\n            text: ''\n          })\n        } else {\n          // Recurse.\n          this.token(item, false)\n        }\n\n        this.tokens.push({\n          type: 'list_item_end'\n        })\n      }\n\n      this.tokens.push({\n        type: 'list_end'\n      })\n      continue\n    }\n\n    // html\n    cap = this.rules.html.exec(src)\n    if (cap) {\n      src = src.substring(cap[0].length)\n      this.tokens.push({\n        type: this.options.sanitize\n          ? 'paragraph'\n          : 'html',\n        pre: !this.options.sanitizer &&\n          (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),\n        text: this.options.sanitize ? (this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0])) : cap[0]\n      })\n      continue\n    }\n\n    // def\n    cap = this.rules.def.exec(src)\n    if (top && cap) {\n      let text = ''\n      do {\n        src = src.substring(cap[0].length)\n        if (cap[3]) cap[3] = cap[3].substring(1, cap[3].length - 1)\n        tag = cap[1].toLowerCase().replace(/\\s+/g, ' ')\n        if (!this.tokens.links[tag]) {\n          this.tokens.links[tag] = {\n            href: cap[2],\n            title: cap[3]\n          }\n        }\n\n        text += cap[0]\n        if (cap[0].endsWith('\\n\\n')) break\n        cap = this.rules.def.exec(src)\n      } while (cap)\n\n      if (this.options.disableInline) {\n        this.tokens.push({\n          type: 'paragraph',\n          text: text.replace(/\\n*$/, '')\n        })\n      }\n      continue\n    }\n\n    // table (gfm)\n    cap = this.rules.table.exec(src)\n    if (cap) {\n      item = {\n        type: 'table',\n        header: splitCells(cap[1].replace(/^ *| *\\| *$/g, '')),\n        align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\n        cells: cap[3] ? cap[3].replace(/\\n$/, '').split('\\n') : []\n      }\n\n      if (item.header.length === item.align.length) {\n        src = src.substring(cap[0].length)\n\n        for (i = 0; i < item.align.length; i++) {\n          if (/^ *-+: *$/.test(item.align[i])) {\n            item.align[i] = 'right'\n          } else if (/^ *:-+: *$/.test(item.align[i])) {\n            item.align[i] = 'center'\n          } else if (/^ *:-+ *$/.test(item.align[i])) {\n            item.align[i] = 'left'\n          } else {\n            item.align[i] = null\n          }\n        }\n\n        for (i = 0; i < item.cells.length; i++) {\n          item.cells[i] = splitCells(\n            item.cells[i].replace(/^ *\\| *| *\\| *$/g, ''),\n            item.header.length)\n        }\n\n        this.tokens.push(item)\n\n        continue\n      }\n    }\n\n    // lheading\n    cap = this.rules.lheading.exec(src)\n    if (cap) {\n      const precededToken = this.tokens[this.tokens.length - 1]\n      const chops = cap[0].trim().split(/\\n/)\n      const marker = chops[chops.length - 1]\n      src = src.substring(cap[0].length)\n\n      if (precededToken && precededToken.type === 'paragraph') {\n        this.tokens.pop()\n        this.tokens.push({\n          type: 'heading',\n          headingStyle: 'setext',\n          depth: cap[2].charAt(0) === '=' ? 1 : 2,\n          text: precededToken.text + '\\n' + cap[1],\n          marker\n        })\n      } else {\n        this.tokens.push({\n          type: 'heading',\n          headingStyle: 'setext',\n          depth: cap[2].charAt(0) === '=' ? 1 : 2,\n          text: cap[1],\n          marker\n        })\n      }\n      continue\n    }\n\n    // top-level paragraph\n    cap = this.rules.paragraph.exec(src)\n    if (top && cap) {\n      src = src.substring(cap[0].length)\n\n      if (/^\\[toc\\]\\n?$/i.test(cap[1])) {\n        this.tokens.push({ type: 'toc', text: '[TOC]' })\n        continue\n      }\n\n      this.tokens.push({\n        type: 'paragraph',\n        text: cap[1].charAt(cap[1].length - 1) === '\\n'\n          ? cap[1].slice(0, -1)\n          : cap[1]\n      })\n      continue\n    }\n\n    // text\n    cap = this.rules.text.exec(src)\n    if (cap) {\n      // Top-level should never reach here.\n      src = src.substring(cap[0].length)\n      this.tokens.push({\n        type: 'text',\n        text: cap[0]\n      })\n      continue\n    }\n\n    if (src) {\n      throw new Error('Infinite loop on byte: ' + src.charCodeAt(0))\n    }\n  }\n}\n\nfunction indentCodeCompensation (raw, text) {\n  const matchIndentToCode = raw.match(/^(\\s+)(?:```)/)\n\n  if (matchIndentToCode === null) {\n    return text\n  }\n\n  const indentToCode = matchIndentToCode[1]\n\n  return text\n    .split('\\n')\n    .map(node => {\n      const matchIndentInNode = node.match(/^\\s+/)\n      if (matchIndentInNode === null) {\n        return node\n      }\n\n      const [indentInNode] = matchIndentInNode\n\n      if (indentInNode.length >= indentToCode.length) {\n        return node.slice(indentToCode.length)\n      }\n\n      return node\n    })\n    .join('\\n')\n}\n\nexport default Lexer\n","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/marked/renderer.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/utils.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/marked/utils.js",["1146"],"/**\n * Helpers\n */\n\nlet uniqueIdCounter = 0\n\nexport const getUniqueId = () => ++uniqueIdCounter\n\nexport const escape = function escape (html, encode) {\n  if (encode) {\n    if (escape.escapeTest.test(html)) {\n      return html.replace(escape.escapeReplace, function (ch) { return escape.replacements[ch] })\n    }\n  } else {\n    if (escape.escapeTestNoEncode.test(html)) {\n      return html.replace(escape.escapeReplaceNoEncode, function (ch) { return escape.replacements[ch] })\n    }\n  }\n\n  return html\n}\n\nescape.escapeTest = /[&<>\"']/\nescape.escapeReplace = /[&<>\"']/g\nescape.replacements = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;',\n  \"'\": '&#39;'\n}\n\nescape.escapeTestNoEncode = /[<>\"']|&(?!#?\\w+;)/\nescape.escapeReplaceNoEncode = /[<>\"']|&(?!#?\\w+;)/g\n\nexport const unescape = function unescape (html) {\n  // explicitly match decimal, hex, and named HTML entities\n  return html.replace(/&(#(?:\\d+)|(?:#x[0-9A-Fa-f]+)|(?:\\w+));?/ig, function (_, n) {\n    n = n.toLowerCase()\n    if (n === 'colon') return ':'\n    if (n.charAt(0) === '#') {\n      return n.charAt(1) === 'x'\n        ? String.fromCharCode(parseInt(n.substring(2), 16))\n        : String.fromCharCode(+n.substring(1))\n    }\n    return ''\n  })\n}\n\nexport const edit = function edit (regex, opt) {\n  regex = regex.source || regex\n  opt = opt || ''\n  return {\n    replace: function (name, val) {\n      val = val.source || val\n      val = val.replace(/(^|[^\\[])\\^/g, '$1') // eslint-disable-line no-useless-escape\n      regex = regex.replace(name, val)\n      return this\n    },\n    getRegex: function () {\n      return new RegExp(regex, opt)\n    }\n  }\n}\n\nexport const cleanUrl = function cleanUrl (sanitize, base, href) {\n  if (sanitize) {\n    let prot = ''\n    try {\n      prot = decodeURIComponent(unescape(href))\n        .replace(/[^\\w:]/g, '')\n        .toLowerCase()\n    } catch (e) {\n      return null\n    }\n    if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {\n      return null\n    }\n  }\n  if (base && !originIndependentUrl.test(href)) {\n    href = resolveUrl(base, href)\n  }\n  try {\n    href = encodeURI(href).replace(/%25/g, '%')\n  } catch (e) {\n    return null\n  }\n  return href\n}\n\nconst resolveUrl = function resolveUrl (base, href) {\n  if (!baseUrls[' ' + base]) {\n    // we can ignore everything in base after the last slash of its path component,\n    // but we might need to add _that_\n    // https://tools.ietf.org/html/rfc3986#section-3\n    if (/^[^:]+:\\/*[^/]*$/.test(base)) {\n      baseUrls[' ' + base] = base + '/'\n    } else {\n      baseUrls[' ' + base] = rtrim(base, '/', true)\n    }\n  }\n  base = baseUrls[' ' + base]\n  let relativeBase = base.indexOf(':') === -1\n\n  if (href.slice(0, 2) === '//') {\n    if (relativeBase) {\n      return href\n    }\n    return base.replace(/^([^:]+:)[\\s\\S]*$/, '$1') + href\n  } else if (href.charAt(0) === '/') {\n    if (relativeBase) {\n      return href\n    }\n    return base.replace(/^([^:]+:\\/*[^/]*)[\\s\\S]*$/, '$1') + href\n  } else {\n    return base + href\n  }\n}\nconst baseUrls = {}\nconst originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i\n\nexport const noop = function noop () {}\nnoop.exec = noop\n\nexport const splitCells = function splitCells (tableRow, count) {\n  // ensure that every cell-delimiting pipe has a space\n  // before it to distinguish it from an escaped pipe\n  const row = tableRow.replace(/\\|/g, function (match, offset, str) {\n    let escaped = false\n    let curr = offset\n    while (--curr >= 0 && str[curr] === '\\\\') escaped = !escaped\n    if (escaped) {\n      // odd number of slashes means | is escaped\n      // so we leave it alone\n      return '|'\n    } else {\n      // add space before unescaped |\n      return ' |'\n    }\n  })\n  const cells = row.split(/ \\|/)\n  let i = 0\n\n  if (cells.length > count) {\n    cells.splice(count)\n  } else {\n    while (cells.length < count) cells.push('')\n  }\n\n  for (; i < cells.length; i++) {\n    // leading or trailing whitespace is ignored per the gfm spec\n    cells[i] = cells[i].trim().replace(/\\\\\\|/g, '|')\n  }\n  return cells\n}\n\n// Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').\n// /c*$/ is vulnerable to REDOS.\n// invert: Remove suffix of non-c chars instead. Default falsey.\nexport const rtrim = function rtrim (str, c, invert) {\n  if (str.length === 0) {\n    return ''\n  }\n\n  // Length of suffix matching the invert condition.\n  let suffLen = 0\n\n  // Step left until we fail to match the invert condition.\n  while (suffLen < str.length) {\n    const currChar = str.charAt(str.length - suffLen - 1)\n    if (currChar === c && !invert) {\n      suffLen++\n    } else if (currChar !== c && invert) {\n      suffLen++\n    } else {\n      break\n    }\n  }\n\n  return str.substr(0, str.length - suffLen)\n}\n\nexport const findClosingBracket = function findClosingBracket (str, b) {\n  if (str.indexOf(b[1]) === -1) {\n    return -1\n  }\n  let level = 0\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === '\\\\') {\n      i++\n    } else if (str[i] === b[0]) {\n      level++\n    } else if (str[i] === b[1]) {\n      level--\n      if (level < 0) {\n        return i\n      }\n    }\n  }\n  return -1\n}\n","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/prism/loadLanguage.js",["1147","1148"],"import languages from './languages'\nlet peerDependentsMap = null\nexport const loadedCache = new Set(['markup', 'css', 'clike', 'javascript'])\nconst prismComponentCache = new Map()\n\nfunction getPeerDependentsMap () {\n  const peerDependentsMap = {}\n  Object.keys(languages).forEach(function (language) {\n    if (language === 'meta') {\n      return false\n    }\n    if (languages[language].peerDependencies) {\n      let peerDependencies = languages[language].peerDependencies\n      if (!Array.isArray(peerDependencies)) {\n        peerDependencies = [peerDependencies]\n      }\n      peerDependencies.forEach(function (peerDependency) {\n        if (!peerDependentsMap[peerDependency]) {\n          peerDependentsMap[peerDependency] = []\n        }\n        peerDependentsMap[peerDependency].push(language)\n      })\n    }\n  })\n  return peerDependentsMap\n}\n\nfunction getPeerDependents (mainLanguage) {\n  if (!peerDependentsMap) {\n    peerDependentsMap = getPeerDependentsMap()\n  }\n  return peerDependentsMap[mainLanguage] || []\n}\n\n// Look for the origin languge by alias\nexport const transfromAliasToOrigin = arr => {\n  const result = []\n  for (const lang of arr) {\n    if (languages[lang]) {\n      result.push(lang)\n    } else {\n      const language = Object.keys(languages).find(name => {\n        const l = languages[name]\n        if (l.alias) {\n          return l.alias === lang || Array.isArray(l.alias) && l.alias.includes(lang)\n        }\n        return false\n      })\n\n      if (language) {\n        result.push(language)\n      } else {\n        // The lang is not exist, the will handle in `initLoadLanguage`\n        result.push(lang)\n      }\n    }\n  }\n  return result\n}\n\nfunction initLoadLanguage (Prism) {\n  return async function loadLanguages (arr, withoutDependencies) {\n    // If no argument is passed, load all components\n    if (!arr) {\n      arr = Object.keys(languages).filter(function (language) {\n        return language !== 'meta'\n      })\n    }\n    if (arr && !arr.length) {\n      return Promise.reject(new Error('The first parameter should be a list of load languages or single language.'))\n    }\n\n    if (!Array.isArray(arr)) {\n      arr = [arr]\n    }\n\n    const promises = []\n    const transformedLangs = transfromAliasToOrigin(arr)\n    for (const language of transformedLangs) {\n      // handle not existed\n      if (!languages[language]) {\n        promises.push(Promise.resolve({\n          lang: language,\n          status: 'noexist'\n        }))\n        continue\n      }\n      // handle already cached\n      if (loadedCache.has(language)) {\n        promises.push(Promise.resolve({\n          lang: language,\n          status: 'cached'\n        }))\n        continue\n      }\n\n      // Load dependencies first\n      if (!withoutDependencies && languages[language].require) {\n        const results = await loadLanguages(languages[language].require)\n        promises.push(...results)\n      }\n\n      delete Prism.languages[language]\n      if (!prismComponentCache.has(language)) {\n        await import('prismjs/components/prism-' + language)\n        prismComponentCache.set(language, Prism.languages[language])\n      } else {\n        Prism.languages[language] = prismComponentCache.get(language)\n      }\n      loadedCache.add(language)\n      promises.push(Promise.resolve({\n        status: 'loaded',\n        lang: language\n      }))\n\n      // Reload dependents\n      const dependents = getPeerDependents(language).filter(function (dependent) {\n        // If dependent language was already loaded,\n        // we want to reload it.\n        if (Prism.languages[dependent]) {\n          delete Prism.languages[dependent]\n          loadedCache.delete(dependent)\n          return true\n        }\n        return false\n      })\n      if (dependents.length) {\n        const results = await loadLanguages(dependents, true)\n        promises.push(...results)\n      }\n    }\n\n    return Promise.all(promises)\n  }\n}\n\nexport default initLoadLanguage\n","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/marked/textRenderer.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/marked/blockRules.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/marked/slugger.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/marked/inlineLexer.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/snabbdom.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderBlock/index.js",["1149"],"import renderBlock from './renderBlock'\nimport renderLeafBlock from './renderLeafBlock'\nimport renderContainerBlock from './renderContainerBlock'\nimport renderIcon from './renderIcon'\n\nexport default {\n  renderBlock,\n  renderLeafBlock,\n  renderContainerBlock,\n  renderIcon\n}\n","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderInlines/index.js",["1150"],"import backlashInToken from './backlashInToken'\nimport backlash from './backlash'\nimport highlight from './highlight'\nimport header from './header'\nimport link from './link'\nimport htmlTag from './htmlTag'\nimport hr from './hr'\nimport tailHeader from './tailHeader'\nimport hardLineBreak from './hardLineBreak'\nimport softLineBreak from './softLineBreak'\nimport codeFense from './codeFense'\nimport inlineMath from './inlineMath'\nimport autoLink from './autoLink'\nimport autoLinkExtension from './autoLinkExtension'\nimport loadImageAsync from './loadImageAsync'\nimport image from './image'\nimport delEmStrongFac from './delEmStringFactory'\nimport emoji from './emoji'\nimport inlineCode from './inlineCode'\nimport text from './text'\nimport del from './del'\nimport em from './em'\nimport strong from './strong'\nimport htmlEscape from './htmlEscape'\nimport multipleMath from './multipleMath'\nimport referenceDefinition from './referenceDefinition'\nimport htmlRuby from './htmlRuby'\nimport referenceLink from './referenceLink'\nimport referenceImage from './referenceImage'\nimport superSubScript from './superSubScript'\nimport footnoteIdentifier from './footnoteIdentifier'\n\nexport default {\n  backlashInToken,\n  backlash,\n  highlight,\n  header,\n  link,\n  htmlTag,\n  hr,\n  tailHeader,\n  hardLineBreak,\n  softLineBreak,\n  codeFense,\n  inlineMath,\n  autoLink,\n  autoLinkExtension,\n  loadImageAsync,\n  image,\n  delEmStrongFac,\n  emoji,\n  inlineCode,\n  text,\n  del,\n  em,\n  strong,\n  htmlEscape,\n  multipleMath,\n  referenceDefinition,\n  htmlRuby,\n  referenceLink,\n  referenceImage,\n  superSubScript,\n  footnoteIdentifier\n}\n","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/marked/urlify.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/marked/inlineRules.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderInlines/footnoteIdentifier.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderBlock/renderIcon.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderInlines/superSubScript.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderInlines/referenceImage.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderInlines/referenceLink.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderInlines/htmlRuby.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderInlines/referenceDefinition.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderInlines/multipleMath.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderInlines/htmlEscape.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderInlines/strong.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderInlines/text.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderInlines/del.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderInlines/em.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderInlines/inlineCode.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderInlines/emoji.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderInlines/delEmStringFactory.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderInlines/image.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderInlines/loadImageAsync.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderInlines/autoLinkExtension.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderInlines/autoLink.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderInlines/inlineMath.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderInlines/codeFense.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderInlines/softLineBreak.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderInlines/hardLineBreak.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderInlines/tailHeader.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderInlines/hr.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderInlines/htmlTag.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderInlines/link.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderInlines/header.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderInlines/highlight.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderInlines/backlash.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderInlines/backlashInToken.js",["1151"],"import { union, isEven } from '../../../utils'\nimport { CLASS_OR_ID } from '../../../config'\n// TODO HIGHLIGHT\nexport default function backlashInToken (h, backlashes, outerClass, start, token) {\n  const { highlights = [] } = token\n  const chunks = backlashes.split('')\n  const len = chunks.length\n  const result = []\n  let i\n\n  for (i = 0; i < len; i++) {\n    const chunk = chunks[i]\n    const light = highlights.filter(light => union({ start: start + i, end: start + i + 1 }, light))\n    let selector = 'span'\n    if (light.length) {\n      const className = this.getHighlightClassName(light[0].active)\n      selector += `.${className}`\n    }\n    if (isEven(i)) {\n      result.push(\n        h(`${selector}.${outerClass}`, chunk)\n      )\n    } else {\n      result.push(\n        h(`${selector}.${CLASS_OR_ID.AG_BACKLASH}`, chunk)\n      )\n    }\n  }\n\n  return result\n}\n","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderBlock/renderContainerBlock.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderBlock/renderLeafBlock.js",["1152"],"import katex from 'katex'\nimport prism, { loadedCache, transfromAliasToOrigin } from '../../../prism/'\nimport { CLASS_OR_ID, DEVICE_MEMORY, PREVIEW_DOMPURIFY_CONFIG, HAS_TEXT_BLOCK_REG } from '../../../config'\nimport { tokenizer } from '../../'\nimport { snakeToCamel, sanitize, escapeHtml, getLongUniqueId, getImageInfo } from '../../../utils'\nimport { h, htmlToVNode } from '../snabbdom'\n\n// todo@jocs any better solutions?\nconst MARKER_HASK = {\n  '<': `%${getLongUniqueId()}%`,\n  '>': `%${getLongUniqueId()}%`,\n  '\"': `%${getLongUniqueId()}%`,\n  \"'\": `%${getLongUniqueId()}%`\n}\n\nconst getHighlightHtml = (text, highlights, escape = false, handleLineEnding = false) => {\n  let code = ''\n  let pos = 0\n  const getEscapeHTML = (className, content) => {\n    return `${MARKER_HASK['<']}span class=${MARKER_HASK['\"']}${className}${MARKER_HASK['\"']}${MARKER_HASK['>']}${content}${MARKER_HASK['<']}/span${MARKER_HASK['>']}`\n  }\n\n  for (const highlight of highlights) {\n    const { start, end, active } = highlight\n    code += text.substring(pos, start)\n    const className = active ? 'ag-highlight' : 'ag-selection'\n    let highlightContent = text.substring(start, end)\n    if (handleLineEnding && text.endsWith('\\n') && end === text.length) {\n      highlightContent = highlightContent.substring(start, end - 1) +\n      (escape\n        ? getEscapeHTML('ag-line-end', '\\n')\n        : '<span class=\"ag-line-end\">\\n</span>')\n    }\n    code += escape\n      ? getEscapeHTML(className, highlightContent)\n      : `<span class=\"${className}\">${highlightContent}</span>`\n    pos = end\n  }\n  if (pos !== text.length) {\n    if (handleLineEnding && text.endsWith('\\n')) {\n      code += text.substring(pos, text.length - 1) +\n      (escape\n        ? getEscapeHTML('ag-line-end', '\\n')\n        : '<span class=\"ag-line-end\">\\n</span>')\n    } else {\n      code += text.substring(pos)\n    }\n  }\n\n  return code\n}\n\nconst hasReferenceToken = tokens => {\n  let result = false\n  const travel = tokens => {\n    for (const token of tokens) {\n      if (/reference_image|reference_link/.test(token.type)) {\n        result = true\n        break\n      }\n      if (Array.isArray(token.children) && token.children.length) {\n        travel(token.children)\n      }\n    }\n  }\n  travel(tokens)\n  return result\n}\n\nexport default function renderLeafBlock (parent, block, activeBlocks, matches, useCache = false) {\n  const { loadMathMap } = this\n  const { cursor } = this.muya.contentState\n  let selector = this.getSelector(block, activeBlocks)\n  // highlight search key in block\n  const highlights = matches.filter(m => m.key === block.key)\n  const {\n    text,\n    type,\n    checked,\n    key,\n    lang,\n    functionType,\n    editable\n  } = block\n\n  const data = {\n    props: {},\n    attrs: {},\n    dataset: {},\n    style: {}\n  }\n\n  let children = ''\n\n  if (text) {\n    let tokens = []\n    if (highlights.length === 0 && this.tokenCache.has(text)) {\n      tokens = this.tokenCache.get(text)\n    } else if (\n      HAS_TEXT_BLOCK_REG.test(type) &&\n      functionType !== 'codeContent' &&\n      functionType !== 'languageInput'\n    ) {\n      const hasBeginRules = /paragraphContent|atxLine/.test(functionType)\n\n      tokens = tokenizer(text, {\n        highlights,\n        hasBeginRules,\n        labels: this.labels,\n        options: this.muya.options\n      })\n      const hasReferenceTokens = hasReferenceToken(tokens)\n      if (highlights.length === 0 && useCache && DEVICE_MEMORY >= 4 && !hasReferenceTokens) {\n        this.tokenCache.set(text, tokens)\n      }\n    }\n\n    children = tokens.reduce((acc, token) => [...acc, ...this[snakeToCamel(token.type)](h, cursor, block, token)], [])\n  }\n\n  if (editable === false) {\n    Object.assign(data.attrs, {\n      spellcheck: 'false',\n      contenteditable: 'false'\n    })\n  }\n\n  if (type === 'div') {\n    const code = this.codeCache.get(block.preSibling)\n    switch (functionType) {\n      case 'html': {\n        selector += `.${CLASS_OR_ID.AG_HTML_PREVIEW}`\n        Object.assign(data.attrs, { spellcheck: 'false' })\n\n        const { disableHtml } = this.muya.options\n        const htmlContent = sanitize(code, PREVIEW_DOMPURIFY_CONFIG, disableHtml)\n\n        // handle empty html bock\n        if (/^<([a-z][a-z\\d]*)[^>]*?>(\\s*)<\\/\\1>$/.test(htmlContent.trim())) {\n          children = htmlToVNode('<div class=\"ag-empty\">&lt;Empty HTML Block&gt;</div>')\n        } else {\n          const parser = new DOMParser()\n          const doc = parser.parseFromString(htmlContent, 'text/html')\n          const imgs = doc.documentElement.querySelectorAll('img')\n          for (const img of imgs) {\n            const src = img.getAttribute('src')\n            const imageInfo = getImageInfo(src)\n            img.setAttribute('src', imageInfo.src)\n          }\n\n          children = htmlToVNode(doc.documentElement.querySelector('body').innerHTML)\n        }\n        break\n      }\n      case 'multiplemath': {\n        const key = `${code}_display_math`\n        selector += `.${CLASS_OR_ID.AG_CONTAINER_PREVIEW}`\n        Object.assign(data.attrs, { spellcheck: 'false' })\n        if (code === '') {\n          children = '< Empty Mathematical Formula >'\n          selector += `.${CLASS_OR_ID.AG_EMPTY}`\n        } else if (loadMathMap.has(key)) {\n          children = loadMathMap.get(key)\n        } else {\n          try {\n            const html = katex.renderToString(code, {\n              displayMode: true\n            })\n\n            children = htmlToVNode(html)\n            loadMathMap.set(key, children)\n          } catch (err) {\n            children = '< Invalid Mathematical Formula >'\n            selector += `.${CLASS_OR_ID.AG_MATH_ERROR}`\n          }\n        }\n        break\n      }\n      case 'mermaid': {\n        selector += `.${CLASS_OR_ID.AG_CONTAINER_PREVIEW}`\n        Object.assign(data.attrs, { spellcheck: 'false' })\n        if (code === '') {\n          children = '< Empty Mermaid Block >'\n          selector += `.${CLASS_OR_ID.AG_EMPTY}`\n        } else {\n          children = 'Loading...'\n          this.mermaidCache.set(`#${block.key}`, {\n            code,\n            functionType\n          })\n        }\n        break\n      }\n      case 'flowchart':\n      case 'sequence':\n      case 'vega-lite': {\n        selector += `.${CLASS_OR_ID.AG_CONTAINER_PREVIEW}`\n        Object.assign(data.attrs, { spellcheck: 'false' })\n        if (code === '') {\n          children = '< Empty Diagram Block >'\n          selector += `.${CLASS_OR_ID.AG_EMPTY}`\n        } else {\n          children = 'Loading...'\n          this.diagramCache.set(`#${block.key}`, {\n            code,\n            functionType\n          })\n        }\n        break\n      }\n    }\n  } else if (type === 'input') {\n    const { fontSize, lineHeight } = this.muya.options\n\n    Object.assign(data.attrs, {\n      type: 'checkbox',\n      style: `top: ${(fontSize * lineHeight / 2 - 8).toFixed(2)}px`\n    })\n\n    selector = `${type}#${key}.${CLASS_OR_ID.AG_TASK_LIST_ITEM_CHECKBOX}`\n    if (checked) {\n      Object.assign(data.attrs, {\n        checked: true\n      })\n      selector += `.${CLASS_OR_ID.AG_CHECKBOX_CHECKED}`\n    }\n    children = ''\n  } else if (type === 'span' && functionType === 'codeContent') {\n    const code = escapeHtml(getHighlightHtml(text, highlights, true, true))\n      .replace(new RegExp(MARKER_HASK['<'], 'g'), '<')\n      .replace(new RegExp(MARKER_HASK['>'], 'g'), '>')\n      .replace(new RegExp(MARKER_HASK['\"'], 'g'), '\"')\n      .replace(new RegExp(MARKER_HASK[\"'\"], 'g'), \"'\")\n    // transfrom alias to original language\n    const transformedLang = transfromAliasToOrigin([lang])[0]\n\n    if (transformedLang && /\\S/.test(code) && loadedCache.has(transformedLang)) {\n      const wrapper = document.createElement('div')\n      wrapper.classList.add(`language-${transformedLang}`)\n      wrapper.innerHTML = code\n      prism.highlightElement(wrapper, false, function () {\n        const highlightedCode = this.innerHTML\n        selector += `.language-${transformedLang}`\n        children = htmlToVNode(highlightedCode)\n      })\n    } else {\n      children = htmlToVNode(code)\n    }\n  } else if (type === 'span' && functionType === 'languageInput') {\n    const html = getHighlightHtml(text, highlights)\n    children = htmlToVNode(html)\n  } else if (type === 'span' && functionType === 'footnoteInput') {\n    Object.assign(data.attrs, { spellcheck: 'false' })\n  }\n\n  if (!block.parent) {\n    return h(selector, data, [this.renderIcon(block), ...children])\n  } else {\n    return h(selector, data, children)\n  }\n}\n","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderBlock/renderBlock.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderBlock/renderTableDargBar.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderBlock/renderCopyButton.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderBlock/renderContainerEditIcon.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderBlock/renderFootnoteJump.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/renderBlock/renderToolBar.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/muya/lib/parser/render/sequence.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/index.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/utils/exportHtml.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/utils/exportMarkdown.js",["1153","1154"],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/utils/index.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/eventHandler/event.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/eventHandler/mouseEvent.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/eventHandler/clipboard.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/eventHandler/keyboard.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/eventHandler/dragDrop.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/eventHandler/clickEvent.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/eventHandler/resize.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/contentState/index.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/config/index.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/ui/tooltip/index.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/utils/dompurify.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/utils/getLinkInfo.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/contentState/backspaceCtrl.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/contentState/updateCtrl.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/contentState/enterCtrl.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/utils/domManipulate.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/utils/getImageInfo.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/contentState/codeBlockCtrl.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/contentState/tableDragBarCtrl.js",["1155","1156"],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/contentState/deleteCtrl.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/contentState/tableSelectCellsCtrl.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/contentState/tableBlockCtrl.js",["1157","1158"],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/contentState/arrowCtrl.js",["1159"],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/contentState/core.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/contentState/history.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/contentState/copyCutCtrl.js",["1160","1161"],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/contentState/tabCtrl.js",["1162","1163","1164"],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/contentState/pasteCtrl.js",["1165"],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/contentState/containerCtrl.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/contentState/emojiCtrl.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/contentState/formatCtrl.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/contentState/inputCtrl.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/contentState/htmlBlock.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/contentState/searchCtrl.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/contentState/clickCtrl.js",["1166"],"import selection from '../selection';\nimport { isMuyaEditorElement } from '../selection/dom';\nimport { HAS_TEXT_BLOCK_REG, CLASS_OR_ID } from '../config';\nimport { getParentCheckBox } from '../utils/getParentCheckBox';\nimport { cumputeCheckboxStatus } from '../utils/cumputeCheckBoxStatus';\n\nconst clickCtrl = (ContentState) => {\n  ContentState.prototype.clickHandler = function (event) {\n    const { eventCenter } = this.muya;\n    const { target } = event;\n    if (isMuyaEditorElement(target)) {\n      const lastBlock = this.getLastBlock();\n      const archor = this.findOutMostBlock(lastBlock);\n      const archorParagraph = document.querySelector(`#${archor.key}`);\n      const rect = archorParagraph.getBoundingClientRect();\n      // If click below the last paragraph\n      // and the last paragraph is not empty, create a new empty paragraph\n      if (event.clientY > rect.top + rect.height) {\n        let needToInsertNewParagraph = false;\n        if (lastBlock.type === 'span') {\n          if (\n            /atxLine|paragraphContent/.test(lastBlock.functionType) &&\n            /\\S/.test(lastBlock.text)\n          ) {\n            needToInsertNewParagraph = true;\n          }\n          if (!/atxLine|paragraphContent/.test(lastBlock.functionType)) {\n            needToInsertNewParagraph = true;\n          }\n        } else {\n          needToInsertNewParagraph = true;\n        }\n\n        if (needToInsertNewParagraph) {\n          event.preventDefault();\n          const paragraphBlock = this.createBlockP();\n          this.insertAfter(paragraphBlock, archor);\n          const key = paragraphBlock.children[0].key;\n          const offset = 0;\n          this.cursor = {\n            start: { key, offset },\n            end: { key, offset },\n          };\n\n          return this.render();\n        }\n      }\n    }\n    // handle front menu click\n    const { start: oldStart, end: oldEnd } = this.cursor;\n    if (oldStart && oldEnd) {\n      let hasSameParent = false;\n      const startBlock = this.getBlock(oldStart.key);\n      const endBlock = this.getBlock(oldEnd.key);\n      if (startBlock && endBlock) {\n        const startOutBlock = this.findOutMostBlock(startBlock);\n        const endOutBlock = this.findOutMostBlock(endBlock);\n        hasSameParent = startOutBlock === endOutBlock;\n      }\n      // show the muya-front-menu only when the cursor in the same paragraph\n      if (target.closest('.ag-front-icon') && hasSameParent) {\n        const currentBlock = this.findOutMostBlock(startBlock);\n        const frontIcon = target.closest('.ag-front-icon');\n        const rect = frontIcon.getBoundingClientRect();\n        const reference = {\n          getBoundingClientRect() {\n            return rect;\n          },\n          clientWidth: rect.width,\n          clientHeight: rect.height,\n          id: currentBlock.key,\n        };\n        this.selectedBlock = currentBlock;\n        eventCenter.dispatch('muya-front-menu', {\n          reference,\n          outmostBlock: currentBlock,\n          startBlock,\n          endBlock,\n        });\n        return this.partialRender();\n      }\n    }\n    const { start, end } = selection.getCursorRange();\n    // fix #625, the selection maybe not in edit area.\n    if (!start || !end) {\n      return;\n    }\n    // format-click\n    const node = selection.getSelectionStart();\n    const inlineNode = node ? node.closest('.ag-inline-rule') : null;\n\n    // link-format-click\n    let parentNode = inlineNode;\n    while (\n      parentNode !== null &&\n      parentNode.classList.contains(CLASS_OR_ID.AG_INLINE_RULE)\n    ) {\n      if (parentNode.tagName === 'A') {\n        const formatType = 'link'; // auto link or []() link\n        const data = {\n          text: inlineNode.textContent,\n          href: parentNode.getAttribute('href'),\n        };\n        eventCenter.dispatch('format-click', {\n          event,\n          formatType,\n          data,\n        });\n        break;\n      } else {\n        parentNode = parentNode.parentNode;\n      }\n    }\n\n    if (inlineNode) {\n      let formatType = null;\n      let data = null;\n      switch (inlineNode.tagName) {\n        case 'SPAN': {\n          if (inlineNode.hasAttribute('data-emoji')) {\n            formatType = 'emoji';\n            data = inlineNode.getAttribute('data-emoji');\n          } else if (inlineNode.classList.contains('ag-math-text')) {\n            formatType = 'inline_math';\n            data = inlineNode.textContent;\n          }\n          break;\n        }\n        case 'STRONG': {\n          formatType = 'strong';\n          data = inlineNode.textContent;\n          break;\n        }\n        case 'EM': {\n          formatType = 'em';\n          data = inlineNode.textContent;\n          break;\n        }\n        case 'DEL': {\n          formatType = 'del';\n          data = inlineNode.textContent;\n          break;\n        }\n        case 'CODE': {\n          formatType = 'inline_code';\n          data = inlineNode.textContent;\n          break;\n        }\n      }\n      if (formatType) {\n        eventCenter.dispatch('format-click', {\n          event,\n          formatType,\n          data,\n        });\n      }\n    }\n    const block = this.getBlock(start.key);\n    let needRender = false;\n    // is show format float box?\n    if (\n      start.key === end.key &&\n      start.offset !== end.offset &&\n      HAS_TEXT_BLOCK_REG.test(block.type) &&\n      block.functionType !== 'codeContent' &&\n      block.functionType !== 'languageInput'\n    ) {\n      const reference = this.getPositionReference();\n      const { formats } = this.selectionFormats();\n      eventCenter.dispatch('muya-format-picker', { reference, formats });\n    }\n\n    // update '```xxx' to code block when you click other place or use press arrow key.\n    if (block && start.key !== this.cursor.start.key) {\n      const oldBlock = this.getBlock(this.cursor.start.key);\n      if (oldBlock) {\n        needRender = needRender || this.codeBlockUpdate(oldBlock);\n      }\n    }\n\n    // change active status when paragraph changed\n    if (\n      start.key !== this.cursor.start.key ||\n      end.key !== this.cursor.end.key\n    ) {\n      needRender = true;\n    }\n\n    const needMarkedUpdate =\n      this.checkNeedRender(this.cursor) || this.checkNeedRender({ start, end });\n\n    if (needRender) {\n      this.cursor = { start, end };\n      return this.partialRender();\n    } else if (needMarkedUpdate) {\n      // Fix: whole select can not be canceled #613\n      requestAnimationFrame(() => {\n        const cursor = selection.getCursorRange();\n        if (!cursor.start || !cursor.end) {\n          return;\n        }\n        this.cursor = cursor;\n\n        return this.partialRender();\n      });\n    } else {\n      this.cursor = { start, end };\n    }\n  };\n\n  ContentState.prototype.setCheckBoxState = function (checkbox, checked) {\n    checkbox.checked = checked;\n    const block = this.getBlock(checkbox.id);\n    block.checked = checked;\n    checkbox.classList.toggle(CLASS_OR_ID.AG_CHECKBOX_CHECKED);\n  };\n\n  ContentState.prototype.updateParentsCheckBoxState = function (checkbox) {\n    let parent = getParentCheckBox(checkbox);\n    while (parent !== null) {\n      const checked = cumputeCheckboxStatus(parent);\n      if (parent.checked !== checked) {\n        this.setCheckBoxState(parent, checked);\n        parent = getParentCheckBox(parent);\n      } else {\n        break;\n      }\n    }\n  };\n\n  ContentState.prototype.updateChildrenCheckBoxState = function (\n    checkbox,\n    checked\n  ) {\n    const checkboxes = checkbox.parentElement.querySelectorAll(\n      `input ~ ul .${CLASS_OR_ID.AG_TASK_LIST_ITEM_CHECKBOX}`\n    );\n    const len = checkboxes.length;\n    for (let i = 0; i < len; i++) {\n      const checkbox = checkboxes[i];\n      if (checkbox.checked !== checked) {\n        this.setCheckBoxState(checkbox, checked);\n      }\n    }\n  };\n\n  // handle task list item checkbox click\n  ContentState.prototype.listItemCheckBoxClick = function (checkbox) {\n    const { checked } = checkbox;\n    this.setCheckBoxState(checkbox, checked);\n\n    // A task checked, then related task should be update\n    const { autoCheck } = this.muya.options;\n    if (autoCheck) {\n      this.updateChildrenCheckBoxState(checkbox, checked);\n      this.updateParentsCheckBoxState(checkbox);\n    }\n\n    const block = this.getBlock(checkbox.id);\n    const parentBlock = this.getParent(block);\n    const firstEditableBlock = this.firstInDescendant(parentBlock);\n    const { key } = firstEditableBlock;\n    const offset = 0;\n    this.cursor = { start: { key, offset }, end: { key, offset } };\n    return this.partialRender();\n  };\n};\n\nexport default clickCtrl;\n","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/contentState/tocCtrl.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/contentState/paragraphCtrl.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/contentState/linkCtrl.js",["1167"],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/contentState/footnoteCtrl.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/contentState/imageCtrl.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/utils/importMarkdown.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/contentState/dragDropCtrl.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/selection/cursor.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/selection/dom.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/escapeCharacter.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/selection/index.js",["1168","1169","1170"],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/renderers/index.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/ui/emojis/index.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/marked/index.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/index.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/utils/cumputeCheckBoxStatus.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/utils/getParentCheckBox.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/rules.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/utils/turndownService.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/index.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/prism/index.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/sequence.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/marked/renderer.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/marked/parser.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/marked/lexer.js",["1171"],"import { normal, gfm, pedantic } from './blockRules';\nimport options from './options';\nimport { splitCells, rtrim, getUniqueId } from './utils';\n\n/**\n * Block Lexer\n */\n\nfunction Lexer(opts) {\n  this.tokens = [];\n  this.tokens.links = Object.create(null);\n  this.tokens.footnotes = Object.create(null);\n  this.footnoteOrder = 0;\n  this.options = Object.assign({}, options, opts);\n  this.rules = normal;\n\n  if (this.options.pedantic) {\n    this.rules = pedantic;\n  } else if (this.options.gfm) {\n    this.rules = gfm;\n  }\n}\n\n/**\n * Preprocessing\n */\n\nLexer.prototype.lex = function (src = '') {\n  src = src.replace(/\\r\\n|\\r/g, '\\n').replace(/\\t/g, '    ');\n  this.checkFrontmatter = true;\n  this.footnoteOrder = 0;\n  this.token(src, true);\n\n  // Move footnote token to the end of tokens.\n  const { tokens } = this;\n  const hasNoFootnoteTokens = [];\n  const footnoteTokens = [];\n  let isInFootnote = false;\n  for (const token of tokens) {\n    const { type } = token;\n    if (type === 'footnote_start') {\n      isInFootnote = true;\n      footnoteTokens.push(token);\n    } else if (type === 'footnote_end') {\n      isInFootnote = false;\n      footnoteTokens.push(token);\n    } else if (isInFootnote) {\n      footnoteTokens.push(token);\n    } else {\n      hasNoFootnoteTokens.push(token);\n    }\n  }\n\n  const result = [...hasNoFootnoteTokens, ...footnoteTokens];\n  result.links = tokens.links;\n  result.footnotes = tokens.footnotes;\n  return result;\n};\n\n/**\n * Lexing\n */\n\nLexer.prototype.token = function (src, top) {\n  const {\n    footnote,\n    frontMatter,\n    isGitlabCompatibilityEnabled,\n    math,\n  } = this.options;\n  src = src.replace(/^ +$/gm, '');\n\n  let loose;\n  let cap;\n  let bull;\n  let b;\n  let item;\n  let space;\n  let i;\n  let tag;\n  let l;\n\n  // Only check front matter at the begining of a markdown file.\n  // Please see note in \"blockquote\" why we need \"checkFrontmatter\" and \"top\".\n  if (frontMatter) {\n    cap = this.rules.frontmatter.exec(src);\n    if (this.checkFrontmatter && top && cap) {\n      src = src.substring(cap[0].length);\n      let lang;\n      let style;\n      let text;\n      if (cap[1]) {\n        lang = 'yaml';\n        style = '-';\n        text = cap[1];\n      } else if (cap[2]) {\n        lang = 'toml';\n        style = '+';\n        text = cap[2];\n      } else if (cap[3] || cap[4]) {\n        lang = 'json';\n        style = cap[3] ? ';' : '{';\n        text = cap[3] || cap[4];\n      }\n      this.tokens.push({\n        type: 'frontmatter',\n        text,\n        style,\n        lang,\n      });\n    }\n    this.checkFrontmatter = false;\n  }\n\n  while (src) {\n    // newline\n    cap = this.rules.newline.exec(src);\n    if (cap) {\n      src = src.substring(cap[0].length);\n      if (cap[0].length > 1) {\n        this.tokens.push({\n          type: 'space',\n        });\n      }\n    }\n\n    // code\n    // An indented code block cannot interrupt a paragraph.\n    cap = this.rules.code.exec(src);\n    if (cap) {\n      const lastToken = this.tokens[this.tokens.length - 1];\n      src = src.substring(cap[0].length);\n      if (lastToken && lastToken.type === 'paragraph') {\n        lastToken.text += `\\n${cap[0].trimRight()}`;\n      } else {\n        cap = cap[0].replace(/^ {4}/gm, '');\n        this.tokens.push({\n          type: 'code',\n          codeBlockStyle: 'indented',\n          text: !this.options.pedantic ? rtrim(cap, '\\n') : cap,\n        });\n      }\n      continue;\n    }\n\n    // multiple line math\n    if (math) {\n      cap = this.rules.multiplemath.exec(src);\n      if (cap) {\n        src = src.substring(cap[0].length);\n        this.tokens.push({\n          type: 'multiplemath',\n          text: cap[1],\n          mathStyle: '',\n        });\n        continue;\n      }\n\n      // match GitLab display math blocks (```math)\n      if (isGitlabCompatibilityEnabled) {\n        cap = this.rules.multiplemathGitlab.exec(src);\n        if (cap) {\n          src = src.substring(cap[0].length);\n          this.tokens.push({\n            type: 'multiplemath',\n            text: cap[2] || '',\n            mathStyle: 'gitlab',\n          });\n          continue;\n        }\n      }\n    }\n\n    // footnote\n    if (footnote) {\n      cap = this.rules.footnote.exec(src);\n      if (top && cap) {\n        src = src.substring(cap[0].length);\n        const identifier = cap[1];\n        this.tokens.push({\n          type: 'footnote_start',\n          identifier,\n        });\n\n        // NOTE: Order is wrong if footnote identifier 1 is behind footnote identifier 2 in text.\n        this.tokens.footnotes[identifier] = {\n          order: ++this.footnoteOrder,\n          identifier,\n          footnoteId: getUniqueId(),\n        };\n\n        /* eslint-disable no-useless-escape */\n        // Remove the footnote identifer prefix. eg: `[^identifier]: `.\n        cap = cap[0].replace(/^\\[\\^[^\\^\\[\\]\\s]+?(?<!\\\\)\\]:\\s+/gm, '');\n        // Remove the four whitespace before each block of footnote.\n        cap = cap.replace(/\\n {4}(?=[^\\s])/g, '\\n');\n        /* eslint-enable no-useless-escape */\n\n        this.token(cap, top);\n\n        this.tokens.push({\n          type: 'footnote_end',\n        });\n\n        continue;\n      }\n    }\n\n    // fences\n    cap = this.rules.fences.exec(src);\n    if (cap) {\n      src = src.substring(cap[0].length);\n      const raw = cap[0];\n      const text = indentCodeCompensation(raw, cap[3] || '');\n      this.tokens.push({\n        type: 'code',\n        codeBlockStyle: 'fenced',\n        lang: cap[2] ? cap[2].trim() : cap[2],\n        text,\n      });\n      continue;\n    }\n\n    // heading\n    cap = this.rules.heading.exec(src);\n    if (cap) {\n      src = src.substring(cap[0].length);\n      let text = cap[2] ? cap[2].trim() : '';\n\n      if (text.endsWith('#')) {\n        var trimmed = rtrim(text, '#');\n\n        if (this.options.pedantic) {\n          text = trimmed.trim();\n        } else if (!trimmed || trimmed.endsWith(' ')) {\n          // CommonMark requires space before trailing #s\n          text = trimmed.trim();\n        }\n      }\n\n      this.tokens.push({\n        type: 'heading',\n        headingStyle: 'atx',\n        depth: cap[1].length,\n        text,\n      });\n      continue;\n    }\n\n    // table no leading pipe (gfm)\n    cap = this.rules.nptable.exec(src);\n    if (cap) {\n      item = {\n        type: 'table',\n        header: splitCells(cap[1].replace(/^ *| *\\| *$/g, '')),\n        align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\n        cells: cap[3] ? cap[3].replace(/\\n$/, '').split('\\n') : [],\n      };\n\n      if (item.header.length === item.align.length) {\n        src = src.substring(cap[0].length);\n\n        for (i = 0; i < item.align.length; i++) {\n          if (/^ *-+: *$/.test(item.align[i])) {\n            item.align[i] = 'right';\n          } else if (/^ *:-+: *$/.test(item.align[i])) {\n            item.align[i] = 'center';\n          } else if (/^ *:-+ *$/.test(item.align[i])) {\n            item.align[i] = 'left';\n          } else {\n            item.align[i] = null;\n          }\n        }\n\n        for (i = 0; i < item.cells.length; i++) {\n          item.cells[i] = splitCells(item.cells[i], item.header.length);\n        }\n\n        this.tokens.push(item);\n\n        continue;\n      }\n    }\n\n    // hr\n    cap = this.rules.hr.exec(src);\n    if (cap) {\n      const marker = cap[0].replace(/\\n*$/, '');\n      src = src.substring(cap[0].length);\n      this.tokens.push({\n        type: 'hr',\n        marker,\n      });\n      continue;\n    }\n\n    // blockquote\n    cap = this.rules.blockquote.exec(src);\n    if (cap) {\n      src = src.substring(cap[0].length);\n\n      this.tokens.push({\n        type: 'blockquote_start',\n      });\n\n      cap = cap[0].replace(/^ *> ?/gm, '');\n\n      // Pass `top` to keep the current\n      // \"toplevel\" state. This is exactly\n      // how markdown.pl works.\n      this.token(cap, top);\n\n      this.tokens.push({\n        type: 'blockquote_end',\n      });\n\n      continue;\n    }\n\n    // NOTE: Complete list lexer part is a custom implementation based on an older marked.js version.\n\n    // list\n    cap = this.rules.list.exec(src);\n    if (cap) {\n      let checked;\n      src = src.substring(cap[0].length);\n      bull = cap[2];\n      let isOrdered = bull.length > 1;\n      this.tokens.push({\n        type: 'list_start',\n        ordered: isOrdered,\n        listType:\n          bull.length > 1\n            ? 'order'\n            : /^( {0,3})([-*+]) \\[[xX ]\\]/.test(cap[0])\n            ? 'task'\n            : 'bullet',\n        start: isOrdered ? +bull.slice(0, -1) : '',\n      });\n\n      let next = false;\n      let prevNext = true;\n      let listItemIndices = [];\n      let isTaskList = false;\n\n      // Get each top-level item.\n      cap = cap[0].match(this.rules.item);\n      l = cap.length;\n      i = 0;\n\n      for (; i < l; i++) {\n        const itemWithBullet = cap[i];\n        item = itemWithBullet;\n        let newIsTaskListItem = false;\n\n        // Remove the list item's bullet so it is seen as the next token.\n        space = item.length;\n        let newBull;\n        item = item.replace(/^ *([*+-]|\\d+(?:\\.|\\))) {0,4}/, function (m, p1) {\n          // Get and remove list item bullet\n          newBull = p1 || bull;\n          return '';\n        });\n\n        const newIsOrdered = bull.length > 1 && /\\d{1,9}/.test(newBull);\n        if (!newIsOrdered && this.options.gfm) {\n          checked = this.rules.checkbox.exec(item);\n          if (checked) {\n            checked = checked[1] === 'x' || checked[1] === 'X';\n            newIsTaskListItem = true;\n\n            // Remove the list item's checkbox and adjust indentation by removing checkbox length.\n            item = item.replace(this.rules.checkbox, '');\n            space -= 4;\n          } else {\n            checked = undefined;\n          }\n        }\n\n        if (i === 0) {\n          isTaskList = newIsTaskListItem;\n        } else if (\n          // Changing the bullet or ordered list delimiter starts a new list (CommonMark 264 and 265)\n          //   - unordered, unordered --> bull !== newBull --> new list (e.g \"-\" --> \"*\")\n          //   - ordered, ordered --> lastChar !== lastChar --> new list (e.g \".\" --> \")\")\n          //   - else --> new list (e.g. ordered --> unordered)\n          i !== 0 &&\n          ((!isOrdered && !newIsOrdered && bull !== newBull) ||\n            (isOrdered &&\n              newIsOrdered &&\n              bull.slice(-1) !== newBull.slice(-1)) ||\n            isOrdered !== newIsOrdered ||\n            // Changing to/from task list item from/to bullet, starts a new list(work for marktext issue #870)\n            // Because we distinguish between task list and bullet list in Mark Text,\n            // the parsing here is somewhat different from the commonmark Spec,\n            // and the task list needs to be a separate list.\n            isTaskList !== newIsTaskListItem)\n        ) {\n          this.tokens.push({\n            type: 'list_end',\n          });\n\n          // Start a new list\n          bull = newBull;\n          isOrdered = newIsOrdered;\n          isTaskList = newIsTaskListItem;\n          this.tokens.push({\n            type: 'list_start',\n            ordered: isOrdered,\n            listType:\n              bull.length > 1\n                ? 'order'\n                : /^( {0,3})([-*+]) \\[[xX ]\\]/.test(itemWithBullet)\n                ? 'task'\n                : 'bullet',\n            start: isOrdered ? +bull.slice(0, -1) : '',\n          });\n        }\n\n        // Outdent whatever the\n        // list item contains. Hacky.\n        if (~item.indexOf('\\n ')) {\n          space -= item.length;\n          item = !this.options.pedantic\n            ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')\n            : item.replace(/^ {1,4}/gm, '');\n        }\n\n        // Determine whether the next list item belongs here.\n        // Backpedal if it does not belong in this list.\n        if (i !== l - 1) {\n          b = this.rules.bullet.exec(cap[i + 1])[0];\n          if (\n            bull.length > 1\n              ? b.length === 1\n              : b.length > 1 || (this.options.smartLists && b !== bull)\n          ) {\n            src = cap.slice(i + 1).join('\\n') + src;\n            i = l - 1;\n          }\n        }\n\n        let prevItem = '';\n        if (i === 0) {\n          prevItem = item;\n        } else {\n          prevItem = cap[i - 1];\n        }\n\n        // Determine whether item is loose or not. If previous item is loose\n        // this item is also loose.\n        // A list is loose if any of its constituent list items are separated by blank lines,\n        // or if any of its constituent list items directly contain two block-level elements with a blank line between them.\n        // loose = next = next || /^ *([*+-]|\\d{1,9}(?:\\.|\\)))( +\\S+\\n\\n(?!\\s*$)|\\n\\n(?!\\s*$))/.test(itemWithBullet)\n        loose = next = next || /\\n\\n(?!\\s*$)/.test(item);\n        // Check if previous line ends with a new line.\n        if (\n          !loose &&\n          (i !== 0 || l > 1) &&\n          prevItem.length !== 0 &&\n          prevItem.charAt(prevItem.length - 1) === '\\n'\n        ) {\n          loose = next = true;\n        }\n\n        // A list is either loose or tight, so update previous list items but not nested list items.\n        if (next && prevNext !== next) {\n          for (const index of listItemIndices) {\n            this.tokens[index].type = 'loose_item_start';\n          }\n          listItemIndices = [];\n        }\n        prevNext = next;\n\n        if (!loose) {\n          listItemIndices.push(this.tokens.length);\n        }\n\n        const isOrderedListItem = /\\d/.test(bull);\n        this.tokens.push({\n          checked,\n          listItemType:\n            bull.length > 1 ? 'order' : isTaskList ? 'task' : 'bullet',\n          bulletMarkerOrDelimiter: isOrderedListItem\n            ? bull.slice(-1)\n            : bull.charAt(0),\n          type: loose ? 'loose_item_start' : 'list_item_start',\n        });\n\n        if (/^\\s*$/.test(item)) {\n          this.tokens.push({\n            type: 'text',\n            text: '',\n          });\n        } else {\n          // Recurse.\n          this.token(item, false);\n        }\n\n        this.tokens.push({\n          type: 'list_item_end',\n        });\n      }\n\n      this.tokens.push({\n        type: 'list_end',\n      });\n      continue;\n    }\n\n    // html\n    cap = this.rules.html.exec(src);\n    if (cap) {\n      src = src.substring(cap[0].length);\n      this.tokens.push({\n        type: this.options.sanitize ? 'paragraph' : 'html',\n        pre:\n          !this.options.sanitizer &&\n          (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),\n        text: this.options.sanitize\n          ? this.options.sanitizer\n            ? this.options.sanitizer(cap[0])\n            : escape(cap[0])\n          : cap[0],\n      });\n      continue;\n    }\n\n    // def\n    cap = this.rules.def.exec(src);\n    if (top && cap) {\n      let text = '';\n      do {\n        src = src.substring(cap[0].length);\n        if (cap[3]) cap[3] = cap[3].substring(1, cap[3].length - 1);\n        tag = cap[1].toLowerCase().replace(/\\s+/g, ' ');\n        if (!this.tokens.links[tag]) {\n          this.tokens.links[tag] = {\n            href: cap[2],\n            title: cap[3],\n          };\n        }\n\n        text += cap[0];\n        if (cap[0].endsWith('\\n\\n')) break;\n        cap = this.rules.def.exec(src);\n      } while (cap);\n\n      if (this.options.disableInline) {\n        this.tokens.push({\n          type: 'paragraph',\n          text: text.replace(/\\n*$/, ''),\n        });\n      }\n      continue;\n    }\n\n    // table (gfm)\n    cap = this.rules.table.exec(src);\n    if (cap) {\n      item = {\n        type: 'table',\n        header: splitCells(cap[1].replace(/^ *| *\\| *$/g, '')),\n        align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\n        cells: cap[3] ? cap[3].replace(/\\n$/, '').split('\\n') : [],\n      };\n\n      if (item.header.length === item.align.length) {\n        src = src.substring(cap[0].length);\n\n        for (i = 0; i < item.align.length; i++) {\n          if (/^ *-+: *$/.test(item.align[i])) {\n            item.align[i] = 'right';\n          } else if (/^ *:-+: *$/.test(item.align[i])) {\n            item.align[i] = 'center';\n          } else if (/^ *:-+ *$/.test(item.align[i])) {\n            item.align[i] = 'left';\n          } else {\n            item.align[i] = null;\n          }\n        }\n\n        for (i = 0; i < item.cells.length; i++) {\n          item.cells[i] = splitCells(\n            item.cells[i].replace(/^ *\\| *| *\\| *$/g, ''),\n            item.header.length\n          );\n        }\n\n        this.tokens.push(item);\n\n        continue;\n      }\n    }\n\n    // lheading\n    cap = this.rules.lheading.exec(src);\n    if (cap) {\n      const precededToken = this.tokens[this.tokens.length - 1];\n      const chops = cap[0].trim().split(/\\n/);\n      const marker = chops[chops.length - 1];\n      src = src.substring(cap[0].length);\n\n      if (precededToken && precededToken.type === 'paragraph') {\n        this.tokens.pop();\n        this.tokens.push({\n          type: 'heading',\n          headingStyle: 'setext',\n          depth: cap[2].charAt(0) === '=' ? 1 : 2,\n          text: precededToken.text + '\\n' + cap[1],\n          marker,\n        });\n      } else {\n        this.tokens.push({\n          type: 'heading',\n          headingStyle: 'setext',\n          depth: cap[2].charAt(0) === '=' ? 1 : 2,\n          text: cap[1],\n          marker,\n        });\n      }\n      continue;\n    }\n\n    // top-level paragraph\n    cap = this.rules.paragraph.exec(src);\n    if (top && cap) {\n      src = src.substring(cap[0].length);\n\n      if (/^\\[toc\\]\\n?$/i.test(cap[1])) {\n        this.tokens.push({ type: 'toc', text: '[TOC]' });\n        continue;\n      }\n\n      this.tokens.push({\n        type: 'paragraph',\n        text:\n          cap[1].charAt(cap[1].length - 1) === '\\n'\n            ? cap[1].slice(0, -1)\n            : cap[1],\n      });\n      continue;\n    }\n\n    // text\n    cap = this.rules.text.exec(src);\n    if (cap) {\n      // Top-level should never reach here.\n      src = src.substring(cap[0].length);\n      this.tokens.push({\n        type: 'text',\n        text: cap[0],\n      });\n      continue;\n    }\n\n    if (src) {\n      throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));\n    }\n  }\n};\n\nfunction indentCodeCompensation(raw, text) {\n  const matchIndentToCode = raw.match(/^(\\s+)(?:```)/);\n\n  if (matchIndentToCode === null) {\n    return text;\n  }\n\n  const indentToCode = matchIndentToCode[1];\n\n  return text\n    .split('\\n')\n    .map((node) => {\n      const matchIndentInNode = node.match(/^\\s+/);\n      if (matchIndentInNode === null) {\n        return node;\n      }\n\n      const [indentInNode] = matchIndentInNode;\n\n      if (indentInNode.length >= indentToCode.length) {\n        return node.slice(indentToCode.length);\n      }\n\n      return node;\n    })\n    .join('\\n');\n}\n\nexport default Lexer;\n","/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/marked/options.js",["1172"],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/snabbdom.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/marked/utils.js",["1173"],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/utils.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/prism/loadLanguage.js",["1174","1175"],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderBlock/index.js",["1176"],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderInlines/index.js",["1177"],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/marked/textRenderer.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/marked/slugger.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/marked/blockRules.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/marked/inlineLexer.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderBlock/renderIcon.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderBlock/renderLeafBlock.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderInlines/backlashInToken.js",["1178"],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderInlines/backlash.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderBlock/renderContainerBlock.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderInlines/header.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderBlock/renderBlock.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderInlines/highlight.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderInlines/link.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderInlines/hr.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderInlines/htmlTag.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderInlines/autoLink.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderInlines/inlineMath.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderInlines/hardLineBreak.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderInlines/image.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderInlines/autoLinkExtension.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderInlines/loadImageAsync.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderInlines/emoji.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderInlines/delEmStringFactory.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderInlines/del.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderInlines/htmlEscape.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderInlines/inlineCode.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderInlines/referenceDefinition.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderInlines/strong.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderInlines/htmlRuby.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderInlines/text.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderInlines/em.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderInlines/referenceLink.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderInlines/multipleMath.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderInlines/tailHeader.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderInlines/codeFense.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderInlines/softLineBreak.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderInlines/footnoteIdentifier.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderInlines/referenceImage.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderInlines/superSubScript.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/marked/urlify.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/marked/inlineRules.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderBlock/renderToolBar.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderBlock/renderContainerEditIcon.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderBlock/renderCopyButton.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderBlock/renderFootnoteJump.js",[],"/Users/jacklee/Project/cloud-doc相关/cloud-note/src/components/Muya/lib/parser/render/renderBlock/renderTableDargBar.js",[],{"ruleId":"1179","replacedBy":"1180"},{"ruleId":"1181","replacedBy":"1182"},{"ruleId":"1183","severity":1,"message":"1184","line":3,"column":10,"nodeType":"1185","messageId":"1186","endLine":3,"endColumn":13},{"ruleId":"1183","severity":1,"message":"1187","line":3,"column":15,"nodeType":"1185","messageId":"1186","endLine":3,"endColumn":18},{"ruleId":"1183","severity":1,"message":"1188","line":57,"column":9,"nodeType":"1185","messageId":"1186","endLine":57,"endColumn":21},{"ruleId":"1183","severity":1,"message":"1189","line":6,"column":10,"nodeType":"1185","messageId":"1186","endLine":6,"endColumn":15},{"ruleId":"1183","severity":1,"message":"1190","line":6,"column":26,"nodeType":"1185","messageId":"1186","endLine":6,"endColumn":31},{"ruleId":"1183","severity":1,"message":"1191","line":7,"column":10,"nodeType":"1185","messageId":"1186","endLine":7,"endColumn":17},{"ruleId":"1183","severity":1,"message":"1192","line":14,"column":27,"nodeType":"1185","messageId":"1186","endLine":14,"endColumn":33},{"ruleId":"1183","severity":1,"message":"1193","line":9,"column":8,"nodeType":"1185","messageId":"1186","endLine":9,"endColumn":19},{"ruleId":"1194","severity":1,"message":"1195","line":29,"column":6,"nodeType":"1196","endLine":29,"endColumn":8,"suggestions":"1197"},{"ruleId":"1194","severity":1,"message":"1198","line":22,"column":6,"nodeType":"1196","endLine":22,"endColumn":8,"suggestions":"1199"},{"ruleId":"1183","severity":1,"message":"1200","line":2,"column":8,"nodeType":"1185","messageId":"1186","endLine":2,"endColumn":14},{"ruleId":"1183","severity":1,"message":"1201","line":4,"column":10,"nodeType":"1185","messageId":"1186","endLine":4,"endColumn":17},{"ruleId":"1183","severity":1,"message":"1202","line":4,"column":19,"nodeType":"1185","messageId":"1186","endLine":4,"endColumn":24},{"ruleId":"1183","severity":1,"message":"1203","line":8,"column":23,"nodeType":"1185","messageId":"1186","endLine":8,"endColumn":31},{"ruleId":"1183","severity":1,"message":"1204","line":8,"column":41,"nodeType":"1185","messageId":"1186","endLine":8,"endColumn":45},{"ruleId":"1183","severity":1,"message":"1189","line":9,"column":10,"nodeType":"1185","messageId":"1186","endLine":9,"endColumn":15},{"ruleId":"1183","severity":1,"message":"1205","line":55,"column":22,"nodeType":"1185","messageId":"1186","endLine":55,"endColumn":35},{"ruleId":"1183","severity":1,"message":"1206","line":1,"column":8,"nodeType":"1185","messageId":"1186","endLine":1,"endColumn":15},{"ruleId":"1183","severity":1,"message":"1200","line":2,"column":8,"nodeType":"1185","messageId":"1186","endLine":2,"endColumn":14},{"ruleId":"1183","severity":1,"message":"1207","line":1,"column":38,"nodeType":"1185","messageId":"1186","endLine":1,"endColumn":49},{"ruleId":"1183","severity":1,"message":"1208","line":2,"column":25,"nodeType":"1185","messageId":"1186","endLine":2,"endColumn":31},{"ruleId":"1194","severity":1,"message":"1209","line":26,"column":6,"nodeType":"1196","endLine":26,"endColumn":15,"suggestions":"1210"},{"ruleId":"1179","replacedBy":"1211"},{"ruleId":"1181","replacedBy":"1212"},{"ruleId":"1179","replacedBy":"1213"},{"ruleId":"1181","replacedBy":"1214"},{"ruleId":"1215","severity":1,"message":"1216","line":69,"column":11,"nodeType":"1217","messageId":"1218","endLine":94,"endColumn":12},{"ruleId":"1215","severity":1,"message":"1216","line":203,"column":5,"nodeType":"1217","messageId":"1218","endLine":221,"endColumn":6},{"ruleId":"1215","severity":1,"message":"1216","line":100,"column":7,"nodeType":"1217","messageId":"1218","endLine":126,"endColumn":8},{"ruleId":"1215","severity":1,"message":"1216","line":284,"column":5,"nodeType":"1217","messageId":"1218","endLine":305,"endColumn":6},{"ruleId":"1219","severity":1,"message":"1220","line":485,"column":35,"nodeType":"1221","messageId":"1222","endLine":485,"endColumn":37},{"ruleId":"1219","severity":1,"message":"1220","line":485,"column":64,"nodeType":"1221","messageId":"1222","endLine":485,"endColumn":66},{"ruleId":"1215","severity":1,"message":"1216","line":10,"column":5,"nodeType":"1217","messageId":"1218","endLine":24,"endColumn":6},{"ruleId":"1219","severity":1,"message":"1220","line":199,"column":66,"nodeType":"1221","messageId":"1222","endLine":199,"endColumn":68},{"ruleId":"1219","severity":1,"message":"1220","line":200,"column":70,"nodeType":"1221","messageId":"1222","endLine":200,"endColumn":72},{"ruleId":"1215","severity":1,"message":"1216","line":107,"column":7,"nodeType":"1217","messageId":"1218","endLine":138,"endColumn":8},{"ruleId":"1215","severity":1,"message":"1216","line":9,"column":3,"nodeType":"1217","messageId":"1218","endLine":48,"endColumn":4},{"ruleId":"1215","severity":1,"message":"1216","line":60,"column":3,"nodeType":"1217","messageId":"1218","endLine":85,"endColumn":4},{"ruleId":"1215","severity":1,"message":"1216","line":95,"column":3,"nodeType":"1217","messageId":"1218","endLine":136,"endColumn":4},{"ruleId":"1219","severity":1,"message":"1220","line":222,"column":30,"nodeType":"1221","messageId":"1222","endLine":222,"endColumn":32},{"ruleId":"1219","severity":1,"message":"1220","line":223,"column":29,"nodeType":"1221","messageId":"1222","endLine":223,"endColumn":31},{"ruleId":"1219","severity":1,"message":"1220","line":246,"column":37,"nodeType":"1221","messageId":"1222","endLine":246,"endColumn":39},{"ruleId":"1219","severity":1,"message":"1220","line":247,"column":38,"nodeType":"1221","messageId":"1222","endLine":247,"endColumn":40},{"ruleId":"1219","severity":1,"message":"1220","line":250,"column":37,"nodeType":"1221","messageId":"1222","endLine":250,"endColumn":39},{"ruleId":"1219","severity":1,"message":"1220","line":251,"column":36,"nodeType":"1221","messageId":"1222","endLine":251,"endColumn":38},{"ruleId":"1219","severity":1,"message":"1220","line":345,"column":33,"nodeType":"1221","messageId":"1222","endLine":345,"endColumn":35},{"ruleId":"1219","severity":1,"message":"1220","line":345,"column":78,"nodeType":"1221","messageId":"1222","endLine":345,"endColumn":80},{"ruleId":"1215","severity":1,"message":"1216","line":359,"column":9,"nodeType":"1217","messageId":"1218","endLine":377,"endColumn":10},{"ruleId":"1215","severity":1,"message":"1216","line":479,"column":5,"nodeType":"1217","messageId":"1218","endLine":633,"endColumn":6},{"ruleId":"1219","severity":1,"message":"1220","line":660,"column":17,"nodeType":"1221","messageId":"1222","endLine":660,"endColumn":19},{"ruleId":"1219","severity":1,"message":"1220","line":660,"column":68,"nodeType":"1221","messageId":"1222","endLine":660,"endColumn":70},{"ruleId":"1215","severity":1,"message":"1216","line":928,"column":5,"nodeType":"1217","messageId":"1218","endLine":1031,"endColumn":6},{"ruleId":"1215","severity":1,"message":"1216","line":196,"column":7,"nodeType":"1217","messageId":"1218","endLine":211,"endColumn":8},{"ruleId":"1215","severity":1,"message":"1216","line":277,"column":5,"nodeType":"1217","messageId":"1218","endLine":317,"endColumn":6},{"ruleId":"1215","severity":1,"message":"1216","line":379,"column":7,"nodeType":"1217","messageId":"1218","endLine":406,"endColumn":8},{"ruleId":"1215","severity":1,"message":"1216","line":68,"column":7,"nodeType":"1217","messageId":"1218","endLine":85,"endColumn":8},{"ruleId":"1223","severity":1,"message":"1224","line":316,"column":38,"nodeType":"1225","messageId":"1226","endLine":318,"endColumn":14},{"ruleId":"1223","severity":1,"message":"1224","line":328,"column":38,"nodeType":"1225","messageId":"1226","endLine":330,"endColumn":14},{"ruleId":"1215","severity":1,"message":"1216","line":121,"column":5,"nodeType":"1217","messageId":"1218","endLine":235,"endColumn":6},{"ruleId":"1223","severity":1,"message":"1224","line":175,"column":32,"nodeType":"1225","messageId":"1226","endLine":186,"endColumn":16},{"ruleId":"1219","severity":1,"message":"1227","line":154,"column":28,"nodeType":"1221","messageId":"1222","endLine":154,"endColumn":30},{"ruleId":"1219","severity":1,"message":"1227","line":154,"column":69,"nodeType":"1221","messageId":"1222","endLine":154,"endColumn":71},{"ruleId":"1219","severity":1,"message":"1220","line":154,"column":69,"nodeType":"1221","messageId":"1222","endLine":154,"endColumn":71},{"ruleId":"1219","severity":1,"message":"1220","line":155,"column":59,"nodeType":"1221","messageId":"1222","endLine":155,"endColumn":61},{"ruleId":"1219","severity":1,"message":"1227","line":217,"column":31,"nodeType":"1221","messageId":"1222","endLine":217,"endColumn":33},{"ruleId":"1219","severity":1,"message":"1227","line":217,"column":60,"nodeType":"1221","messageId":"1222","endLine":217,"endColumn":62},{"ruleId":"1215","severity":1,"message":"1216","line":388,"column":9,"nodeType":"1217","messageId":"1218","endLine":402,"endColumn":10},{"ruleId":"1215","severity":1,"message":"1216","line":450,"column":7,"nodeType":"1217","messageId":"1218","endLine":496,"endColumn":8},{"ruleId":"1228","severity":1,"message":"1229","line":1,"column":1,"nodeType":"1230","endLine":37,"endColumn":2},{"ruleId":"1223","severity":1,"message":"1231","line":358,"column":62,"nodeType":"1232","messageId":"1226","endLine":362,"endColumn":10},{"ruleId":"1233","severity":1,"message":"1234","line":76,"column":22,"nodeType":"1235","messageId":"1236","endLine":76,"endColumn":35},{"ruleId":"1219","severity":1,"message":"1220","line":45,"column":35,"nodeType":"1221","messageId":"1222","endLine":45,"endColumn":37},{"ruleId":"1219","severity":1,"message":"1220","line":45,"column":61,"nodeType":"1221","messageId":"1222","endLine":45,"endColumn":63},{"ruleId":"1228","severity":1,"message":"1229","line":6,"column":1,"nodeType":"1230","endLine":11,"endColumn":2},{"ruleId":"1228","severity":1,"message":"1229","line":33,"column":1,"nodeType":"1230","endLine":65,"endColumn":2},{"ruleId":"1223","severity":1,"message":"1237","line":13,"column":37,"nodeType":"1225","messageId":"1226","endLine":13,"endColumn":100},{"ruleId":"1215","severity":1,"message":"1216","line":130,"column":5,"nodeType":"1217","messageId":"1218","endLine":211,"endColumn":6},{"ruleId":"1215","severity":1,"message":"1216","line":69,"column":11,"nodeType":"1217","messageId":"1218","endLine":94,"endColumn":12},{"ruleId":"1215","severity":1,"message":"1216","line":203,"column":5,"nodeType":"1217","messageId":"1218","endLine":221,"endColumn":6},{"ruleId":"1223","severity":1,"message":"1224","line":316,"column":38,"nodeType":"1225","messageId":"1226","endLine":318,"endColumn":14},{"ruleId":"1223","severity":1,"message":"1224","line":328,"column":38,"nodeType":"1225","messageId":"1226","endLine":330,"endColumn":14},{"ruleId":"1215","severity":1,"message":"1216","line":121,"column":5,"nodeType":"1217","messageId":"1218","endLine":235,"endColumn":6},{"ruleId":"1223","severity":1,"message":"1224","line":175,"column":32,"nodeType":"1225","messageId":"1226","endLine":186,"endColumn":16},{"ruleId":"1215","severity":1,"message":"1216","line":68,"column":7,"nodeType":"1217","messageId":"1218","endLine":85,"endColumn":8},{"ruleId":"1215","severity":1,"message":"1216","line":196,"column":7,"nodeType":"1217","messageId":"1218","endLine":211,"endColumn":8},{"ruleId":"1215","severity":1,"message":"1216","line":277,"column":5,"nodeType":"1217","messageId":"1218","endLine":317,"endColumn":6},{"ruleId":"1219","severity":1,"message":"1220","line":345,"column":33,"nodeType":"1221","messageId":"1222","endLine":345,"endColumn":35},{"ruleId":"1219","severity":1,"message":"1220","line":345,"column":78,"nodeType":"1221","messageId":"1222","endLine":345,"endColumn":80},{"ruleId":"1215","severity":1,"message":"1216","line":359,"column":9,"nodeType":"1217","messageId":"1218","endLine":377,"endColumn":10},{"ruleId":"1215","severity":1,"message":"1216","line":379,"column":7,"nodeType":"1217","messageId":"1218","endLine":406,"endColumn":8},{"ruleId":"1215","severity":1,"message":"1216","line":118,"column":7,"nodeType":"1217","messageId":"1218","endLine":149,"endColumn":8},{"ruleId":"1215","severity":1,"message":"1216","line":10,"column":5,"nodeType":"1217","messageId":"1218","endLine":24,"endColumn":6},{"ruleId":"1215","severity":1,"message":"1216","line":284,"column":5,"nodeType":"1217","messageId":"1218","endLine":305,"endColumn":6},{"ruleId":"1219","severity":1,"message":"1220","line":485,"column":35,"nodeType":"1221","messageId":"1222","endLine":485,"endColumn":37},{"ruleId":"1219","severity":1,"message":"1220","line":485,"column":64,"nodeType":"1221","messageId":"1222","endLine":485,"endColumn":66},{"ruleId":"1223","severity":1,"message":"1231","line":359,"column":62,"nodeType":"1232","messageId":"1226","endLine":363,"endColumn":10},{"ruleId":"1228","severity":1,"message":"1229","line":1,"column":1,"nodeType":"1230","endLine":37,"endColumn":2},{"ruleId":"1233","severity":1,"message":"1234","line":76,"column":22,"nodeType":"1235","messageId":"1236","endLine":76,"endColumn":35},{"ruleId":"1219","severity":1,"message":"1220","line":45,"column":35,"nodeType":"1221","messageId":"1222","endLine":45,"endColumn":37},{"ruleId":"1219","severity":1,"message":"1220","line":45,"column":61,"nodeType":"1221","messageId":"1222","endLine":45,"endColumn":63},{"ruleId":"1228","severity":1,"message":"1229","line":6,"column":1,"nodeType":"1230","endLine":11,"endColumn":2},{"ruleId":"1228","severity":1,"message":"1229","line":33,"column":1,"nodeType":"1230","endLine":65,"endColumn":2},{"ruleId":"1223","severity":1,"message":"1237","line":13,"column":37,"nodeType":"1225","messageId":"1226","endLine":13,"endColumn":100},"no-native-reassign",["1238"],"no-negated-in-lhs",["1239"],"no-unused-vars","'Row' is defined but never used.","Identifier","unusedVar","'Col' is defined but never used.","'unsavedFiles' is assigned a value but never used.","'ITodo' is defined but never used.","'ESort' is defined but never used.","'message' is defined but never used.","'editId' is assigned a value but never used.","'EmptyStatus' is defined but never used.","react-hooks/exhaustive-deps","React Hook useEffect has missing dependencies: 'menus' and 'targetClass'. Either include them or remove the dependency array.","ArrayExpression",["1240"],"React Hook useEffect has a missing dependency: 'targetKeyCode'. Either include it or remove the dependency array.",["1241"],"'moment' is defined but never used.","'IColumn' is defined but never used.","'ITask' is defined but never used.","'Dropdown' is defined but never used.","'Menu' is defined but never used.","'setTaskRepeat' is assigned a value but never used.","'shortid' is defined but never used.","'ChangeEvent' is defined but never used.","'Select' is defined but never used.","React Hook useEffect has missing dependencies: 'data.branchs', 'data.desc', 'data.startDate', 'data.times', and 'data.title'. Either include them or remove the dependency array.",["1242"],["1238"],["1239"],["1238"],["1239"],"default-case","Expected a default case.","SwitchStatement","missingDefaultCase","no-mixed-operators","Unexpected mix of '||' and '&&'.","LogicalExpression","unexpectedMixedOperator","no-loop-func","Function declared in a loop contains unsafe references to variable(s) 'i'.","ArrowFunctionExpression","unsafeRefs","Unexpected mix of '&&' and '||'.","import/no-anonymous-default-export","Assign object to a variable before exporting as module default","ExportDefaultDeclaration","Function declared in a loop contains unsafe references to variable(s) 'bull'.","FunctionExpression","no-script-url","Script URL is a form of eval.","Literal","unexpectedScriptURL","Function declared in a loop contains unsafe references to variable(s) 'i', 'i'.","no-global-assign","no-unsafe-negation",{"desc":"1243","fix":"1244"},{"desc":"1245","fix":"1246"},{"desc":"1247","fix":"1248"},"Update the dependencies array to be: [menus, targetClass]",{"range":"1249","text":"1250"},"Update the dependencies array to be: [targetKeyCode]",{"range":"1251","text":"1252"},"Update the dependencies array to be: [data.branchs, data.desc, data.id, data.startDate, data.times, data.title]",{"range":"1253","text":"1254"},[1031,1033],"[menus, targetClass]",[686,688],"[targetKeyCode]",[949,958],"[data.branchs, data.desc, data.id, data.startDate, data.times, data.title]"]